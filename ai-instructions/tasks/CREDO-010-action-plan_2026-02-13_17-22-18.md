# CREDO-010 - W3C Verifiable Credentials con Linked Data Proof (BBS+) y Revocacion StatusList2021

## Descripcion de la Tarea

Implementar emision y verificacion de credenciales W3C con formato JSON-LD y firma BbsBlsSignature2020, incluyendo soporte de revocacion via StatusList2021. El flujo no usa DIDComm Issue Credential ni AnonCreds; es emision/verificacion directa via API.

**Comportamiento actual:**
- El sistema tiene issuer, holder y verifier con conexion DIDComm (OOB, conexion).
- No hay emision de credenciales implementada.
- No hay revocacion ni StatusList.
- vdr-service solo sirve DID Documents.

**Comportamiento esperado:**
- Issuer puede emitir credenciales W3C con BBS+ (Linked Data Proof).
- Holder recibe y almacena credenciales (en Storage).
- Verifier puede verificar firma BBS+, resolver DID del issuer desde vdr-service, y comprobar estado de revocacion.
- Issuer puede revocar credenciales; el verifier detecta credenciales revocadas.

---

## Criterios de Aceptacion

1. [ ] Issuer expone endpoint para emitir credencial W3C (JSON-LD + BBS+)
2. [ ] Holder almacena credenciales en Storage (W3cCredentialRecord)
3. [ ] Verifier expone endpoint para verificar credencial (firma + revocacion)
4. [ ] vdr-service o extension sirve StatusList para revocacion
5. [ ] Issuer puede revocar credencial via API
6. [ ] DID del issuer se resuelve desde vdr-service; firma BBS+ verificada con clave publica

---

## Contexto del Proyecto

### Servicios Afectados
- [x] vdr-service (extension para StatusList)
- [x] issuer-service
- [x] holder-service
- [x] verifier-service
- [x] kms-service (extendido: createKey Bls12381G2, POST /sign-bbs)
- [ ] storage-service (sin cambios; ya persiste records)
- [ ] Docker/Infraestructura (variables de entorno si aplica)

### Tecnologias Involucradas
- Runtime: Node.js, TypeScript
- Framework: NestJS
- SSI: Credo-TS (W3C VC, Linked Data Proof)
- Criptografia: BbsBlsSignature2020 (BBS+)
- Persistencia: SQLite (vdr-service, storage)
- Referencia: `docs/extender-vdr-service.md`, `docs/informacion-detallada/revocacion-credenciales-credo.md`, `docs/informacion-detallada/arquitectura-bbs-credenciales.md` (arquitectura BBS implementada)

---

## Pasos de Implementacion

### Paso 1: Extension vdr-service - StatusList2021 (revocacion)

**Descripcion:**
Extender vdr-service para servir listas de estado (StatusList) que permitan verificar si una credencial esta revocada. Para W3C con StatusList2021 no hace falta Schema/Credential Definition de AnonCreds; solo un endpoint que sirva el bitstring.

**Archivos a modificar/crear:**
- `vdr-service/src/status/status.module.ts` (nuevo)
- `vdr-service/src/status/status.controller.ts` (nuevo)
- `vdr-service/src/status/status.service.ts` (nuevo)
- `vdr-service/src/app.module.ts`
- `vdr-service/src/db.ts` o similar (migracion para tabla status_lists)

**Detalles de implementacion:**

Tabla `status_lists`:
```sql
CREATE TABLE status_lists (
  id TEXT PRIMARY KEY,
  issuer_id TEXT NOT NULL,
  purpose TEXT DEFAULT 'revocation',
  encoded_list TEXT NOT NULL,
  updated_at INTEGER
);
```

Endpoints:
- `POST /status/list` - Crear lista (body: `{ issuerId }`). Retorna `{ id, url }` con URL accesible.
- `GET /status/list/:id` - Obtener bitstring (StatusList Credential o solo encodedList segun spec).
- `POST /status/list/:id/revoke` - Marcar indice como revocado (body: `{ statusListIndex }`).

La URL que ira en `credentialStatus` sera algo como: `{VDR_SERVICE_URL}/status/list/{listId}#{statusListIndex}`.

**Notas:**
- Segun Bitstring Status List, la credencial incluye `credentialStatus.statusListCredential` apuntando a la URL de la lista.
- El verifier hace GET a esa URL, obtiene el bitstring, y verifica el bit en `statusListIndex`.
- Actualizar `docs/DID-SERVICE.md` con la nueva seccion de StatusList.

**Recursos utiles:**
- [W3C Bitstring Status List](https://www.w3.org/TR/vc-bitstring-status-list/)
- `docs/extender-vdr-service.md` (seccion W3C + StatusList)

---

### Paso 2: Dependencias Credo - W3C Linked Data Proof y BBS+

**Descripcion:**
Asegurar que issuer y verifier tienen las dependencias para firmar y verificar con BbsBlsSignature2020. Credo soporta Linked Data Proof; verificar paquetes necesarios.

**Archivos a modificar/crear:**
- `issuer-service/package.json`
- `verifier-service/package.json`

**Detalles de implementacion:**
- Verificar si `@credo-ts/core` ya incluye soporte BBS+ en W3C o si se necesita `@mattrglobal/jsonld-signatures-bbs` o similar.
- Credo usa `LinkedDataProofFormat`; la firma BBS+ requiere claves Bls12381G2. El KMS actual solo tiene Ed25519.
- **Importante**: BBS+ usa curvas Bls12381G2, no Ed25519. Opciones:
  a) Implementar creacion de claves Bls12381G2 en KMS para el issuer, o
  b) Usar firma local en el issuer (sin KMS) para BBS+ mientras KMS solo tiene Ed25519.

**Implementado (arquitectura-bbs-credenciales.md):** KMS extendido con createKey Bls12381G2 y POST /sign-bbs. Issuer y verifier usan BbsBlsSignature2020. Claves BLS en KMS; DID Document del issuer tiene #vc-bbs (Bls12381G2Key2020). Ed25519 se mantiene solo para DIDComm.

**Notas:**
- Revisar `@credo-ts/core` - W3C credentials con LD Proof.
- Si BBS+ no es viable sin extender KMS, documentar y usar Ed25519Signature2020 como alternativa para el POC.

---

### Paso 3: Issuer - Emision de credencial W3C

**Descripcion:**
Implementar en issuer-service un endpoint (ej. POST /issue-credential) que cree una credencial W3C JSON-LD, la firme con Linked Data Proof (BBS+ o Ed25519 segun disponibilidad), incluya credentialStatus apuntando al StatusList del vdr-service, y la entregue.

**Archivos a modificar/crear:**
- `issuer-service/src/credentials/credentials.module.ts`
- `issuer-service/src/credentials/credentials.controller.ts`
- `issuer-service/src/credentials/credentials.service.ts`
- `issuer-service/src/credentials/dto/issue-credential.dto.ts`

**Detalles de implementacion:**

Flujo:
1. Recibir body con `credentialSubject`, `type`, etc.
2. Obtener DID del issuer (getIssuerDid() o equivalente).
3. **Si no se provee credentialStatus:** Crear StatusList en vdr-service (POST /status/list) si no existe (persistida en issuer-status-list.json), asignar statusListIndex via POST /status/list/:id/allocate.
4. **Si se provee credentialStatus:** Usarlo tal cual (override manual).
5. Construir JSON credencial con: id, @context, type, issuer, issuanceDate, credentialSubject, credentialStatus.
6. Canonicalizar (RFC 8785 o jsonld).
7. Firmar con clave del issuer (KMS o crypto local segun Paso 2).
8. Agregar proof al documento.
9. (Opcional) Persistir referencia en Storage si se usa flujo Credo; o devolver directamente.

Response: credencial firmada (JSON).

**Notas:**
- credentialStatus formato StatusList2021/Bitstring:
```json
{
  "credentialStatus": {
    "id": "https://vdr-service:4003/status/list/xxx#12345",
    "type": "BitstringStatusListEntry",
    "statusPurpose": "revocation",
    "statusListIndex": "12345",
    "statusListCredential": "https://vdr-service:4003/status/list/xxx"
  }
}
```

---

### Paso 4: Holder - Recepcion y almacenamiento de credencial

**Descripcion:**
Holder debe poder recibir una credencial (via API o DIDComm). Para API directa: endpoint POST /receive-credential que reciba el JSON de la credencial y la guarde en Storage como W3cCredentialRecord.

**Archivos a modificar/crear:**
- `holder-service/src/credentials/credentials.controller.ts`
- `holder-service/src/credentials/credentials.service.ts`

**Detalles de implementacion:**
- POST /receive-credential con body: credencial W3C (JSON).
- Usar Credo para crear W3cCredentialRecord y persistir via RemoteStorageService.
- Credo espera cierta estructura; verificar API de Credo para anadir credencial W3C existente.

Alternativa: si Credo no expone "add credential from JSON" directamente, guardar en Storage con type `W3cCredentialRecord` y estructura esperada por Credo.

**Notas:**
- Consultar Credo docs para anadir credencial W3C al wallet/holder.
- Si el flujo es 100% API (sin DIDComm), el holder recibe por POST; si mezclamos DIDComm mas adelante, el holder tambien puede recibir por mensaje.

---

### Paso 5: Verifier - Verificacion de credencial

**Descripcion:**
Implementar en verifier-service un endpoint (ej. POST /verify-credential) que reciba una credencial, verifique la firma Linked Data Proof (resolviendo el DID del issuer desde vdr-service para obtener la clave publica), y compruebe el estado de revocacion (GET al StatusList en vdr-service).

**Archivos a modificar/crear:**
- `verifier-service/src/credentials/credentials.controller.ts`
- `verifier-service/src/credentials/credentials.service.ts`
- `verifier-service/src/credentials/dto/verify-credential.dto.ts`

**Detalles de implementacion:**

Flujo:
1. Recibir credencial (JSON).
2. Extraer `proof.verificationMethod` (DID + fragmento).
3. Resolver DID del issuer via vdr-service (GET /did/:id).
4. Obtener clave publica del DidDocument (verificationMethod con publicKeyJwk o similar).
5. Canonicalizar documento + proof.
6. Verificar firma con la clave publica.
7. Si existe `credentialStatus`: GET a `statusListCredential` URL, parsear bitstring, comprobar bit en `statusListIndex`. Si bit=1 -> revocado.
8. Retornar resultado: `{ valid: boolean, revoked?: boolean, error?: string }`.

**Notas:**
- Usar CustomDidResolver para resolver did:custom desde vdr-service.
- Decodificar y descomprimir el bitstring (gzip) segun spec Bitstring Status List.

---

### Paso 6: Issuer - Revocacion de credencial

**Descripcion:**
Endpoint en issuer-service para revocar una credencial. El issuer llama a vdr-service (POST /status/list/:id/revoke) con el statusListIndex de la credencial.

**Archivos a modificar/crear:**
- `issuer-service/src/credentials/credentials.controller.ts` (añadir POST /revoke-credential)
- `issuer-service/src/credentials/credentials.service.ts`

**Detalles de implementacion:**
- POST /revoke-credential con body: `{ credentialId }` o `{ statusListId, statusListIndex }`.
- El issuer debe tener registrado cual credencial tiene cual statusListIndex (puede guardar en Storage al emitir).
- Llamar a vdr-service: POST /status/list/:id/revoke { statusListIndex }.

**Notas:**
- Al emitir (Paso 3), guardar mapeo credentialId -> (statusListId, statusListIndex) en Storage o en memoria/DB del issuer para poder revocar despues.

---

### Paso 7: Documentacion y variables de entorno

**Descripcion:**
Actualizar documentacion (README, docs) y definir variables de entorno necesarias.

**Archivos a modificar/crear:**
- `docs/DID-SERVICE.md` - Seccion StatusList
- `docs/informacion-detallada/revocacion-credenciales-credo.md` - Referencia a implementacion
- `README.md` - Mencionar flujo de credenciales W3C
- `docker-compose.yml` - No deberia cambiar; vdr-service ya expuesto

Variables de entorno:
- `VDR_SERVICE_URL` - Ya existe; issuer/verifier lo usan para StatusList
- `STATUS_LIST_BASE_URL` - Opcional; si vdr-service corre en otro host, URL base para construir credentialStatus (ej. `http://localhost:4003` en local, `http://vdr-service:4003` en Docker)

---

### Paso 8: Coleccion Postman (opcional)

**Descripcion:**
Añadir requests a la coleccion Postman para: emitir credencial, recibir credencial (holder), verificar credencial, revocar credencial.

**Archivos a modificar/crear:**
- `postman/Issuer-Holder-Connection.postman_collection.json` o nueva coleccion `W3C-Credentials.postman_collection.json`

---

### Paso Final: Generar Descripcion del Pull Request

**Descripcion:**
Una vez completados todos los pasos anteriores y verificada la implementacion, genera la descripcion completa del Pull Request usando la regla `@pr-description.mdc`.

**Comando a ejecutar:**
```
@pr-description.mdc
```

**Resultado esperado:**
- Archivo generado: `CREDO-010_pr-description_[FECHA-HORA].md` en `ai-instructions/prs/`
- Descripcion completa del PR lista para copiar en Git

---

## Consideraciones Tecnicas

### Performance
- StatusList: bitstring comprimido con gzip; para listas grandes (>100k) considerar cache en verifier.
- Resolucion DID: vdr-service ya es ligero; sin cambios.

### Seguridad
- Solo el issuer debe poder llamar POST /status/list/:id/revoke. vdr-service no tiene auth; en produccion añadir API key o mTLS.
- Validar estructura de credencial antes de firmar.
- Sanitizar statusListIndex (numero valido, dentro del rango).

### Casos Edge
- Credencial sin credentialStatus: verifier puede aceptar (no revocable) o rechazar segun politica.
- DID del issuer no resuelve: verifier debe fallar la verificacion.
- StatusList no accesible: verifier puede rechazar o marcar "revocacion desconocida".
- KMS con BBS+: implementado (createKey Bls12381G2, POST /sign-bbs). Arquitectura en `docs/informacion-detallada/arquitectura-bbs-credenciales.md`.

### Compatibilidad
- Credo W3C: verificar version de @credo-ts/core para Linked Data Proof.
- vdr-service: extension backward-compatible; rutas /status/* son nuevas.

---

## Patrones de Codigo a Usar

- NestJS: controllers, services, DTOs con class-validator.
- Adaptadores: no nuevos para este flujo; usar HTTP client para vdr-service (axios o fetch).
- Credo: W3cCredentialRecord, LinkedDataProofFormat.
- Storage: tipo `W3cCredentialRecord` para credenciales en holder.

---

## Dependencias

### Nuevas Dependencias (si aplica)

```json
{
  "@digitalbazaar/vc": "^7.3.0",
  "jsonld": "^8.3.0",
  "@mattrglobal/bbs-signatures": "^1.3.1"
}
```

**kms-service:** @mattrglobal/bbs-signatures, bs58. Ed25519 mantenido para DIDComm. @digitalbazaar/ed25519-* eliminado del flujo de credenciales.

(O las que Credo use internamente; revisar package.json de credo-ts)

### Variables de Entorno

- `VDR_SERVICE_URL` - URL del vdr-service (issuer, verifier)
- `STATUS_LIST_BASE_URL` - URL base para credentialStatus (opcional; default = VDR_SERVICE_URL)

---

## Archivos Principales Involucrados

1. `vdr-service/src/status/*` - StatusList endpoints
2. `issuer-service/src/credentials/*` - Emision y revocacion
3. `holder-service/src/credentials/*` - Recepcion
4. `verifier-service/src/credentials/*` - Verificacion

---

## Testing

### Tests a Crear/Modificar
- Unit tests: status.service.spec.ts, credentials.service.spec.ts en cada agente
- Integration: flujo completo emitir -> recibir -> verificar -> revocar -> verificar (rechazado)

### Escenarios de Prueba
1. Emitir credencial y verificar: valid
2. Revocar y verificar: invalid (revoked)
3. Credencial con firma invalida: invalid
4. DID no resuelve: invalid

---

## Deployment

### Orden de Deployment
1. vdr-service con extension StatusList
2. issuer-service, holder-service, verifier-service con nuevos endpoints
3. Rebuild: `docker compose build`
4. Restart: `docker compose up -d`

### Verificacion Post-Deployment
- [ ] POST issuer /issue-credential retorna credencial firmada
- [ ] POST holder /receive-credential guarda en Storage
- [ ] POST verifier /verify-credential retorna valid
- [ ] POST issuer /revoke-credential
- [ ] POST verifier /verify-credential retorna revoked

---

**Nota Final:** Este plan debe ejecutarse paso a paso, verificando cada paso antes de continuar con el siguiente. La extension de vdr-service (Paso 1) es prerequisito para credencialStatus. El Paso 2 (BBS+ vs Ed25519) puede condicionar el proof type usado.
