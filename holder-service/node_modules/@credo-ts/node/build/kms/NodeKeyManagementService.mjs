import { _classPrivateFieldInitSpec } from "../_virtual/_@oxc-project_runtime@0.110.0/helpers/classPrivateFieldInitSpec.mjs";
import { _classPrivateFieldGet2 } from "../_virtual/_@oxc-project_runtime@0.110.0/helpers/classPrivateFieldGet2.mjs";
import { assertNodeSupportedEcCrv, assertNodeSupportedOctAlgorithm, assertNodeSupportedOkpCrv, createEcKey, createOctKey, createOkpKey, createRsaKey } from "./crypto/createKey.mjs";
import { nodeSupportedJwaAlgorithm, performSign } from "./crypto/sign.mjs";
import { performDecrypt } from "./crypto/decrypt.mjs";
import { deriveDecryptionKey, deriveEncryptionKey, nodeSupportedKeyAgreementAlgorithms } from "./crypto/deriveKey.mjs";
import { nodeSupportedEncryptionAlgorithms, performEncrypt } from "./crypto/encrypt.mjs";
import { performVerify } from "./crypto/verify.mjs";
import { _classPrivateFieldSet2 } from "../_virtual/_@oxc-project_runtime@0.110.0/helpers/classPrivateFieldSet2.mjs";
import { Kms, TypedArrayEncoder } from "@credo-ts/core";
import { createPrivateKey, createSecretKey, randomBytes, randomUUID } from "node:crypto";

//#region src/kms/NodeKeyManagementService.ts
var _storage = /* @__PURE__ */ new WeakMap();
var NodeKeyManagementService = class {
	constructor(storage) {
		this.backend = "node";
		_classPrivateFieldInitSpec(this, _storage, void 0);
		_classPrivateFieldSet2(_storage, this, storage);
	}
	isOperationSupported(_agentContext, operation) {
		if (operation.operation === "deleteKey") return true;
		if (operation.operation === "randomBytes") return true;
		if (operation.operation === "createKey") {
			try {
				if (operation.type.kty === "RSA") return true;
				if (operation.type.kty === "EC") {
					assertNodeSupportedEcCrv(operation.type);
					return true;
				}
				if (operation.type.kty === "OKP") {
					assertNodeSupportedOkpCrv(operation.type);
					return true;
				}
				if (operation.type.kty === "oct") {
					assertNodeSupportedOctAlgorithm(operation.type);
					return true;
				}
			} catch {
				return false;
			}
			return false;
		}
		if (operation.operation === "importKey") try {
			if (operation.privateJwk.kty === "RSA" || operation.privateJwk.kty === "oct") return true;
			if (operation.privateJwk.kty === "EC") {
				assertNodeSupportedEcCrv({
					kty: operation.privateJwk.kty,
					crv: operation.privateJwk.crv
				});
				return true;
			}
			if (operation.privateJwk.kty === "OKP") {
				assertNodeSupportedOkpCrv({
					kty: operation.privateJwk.kty,
					crv: operation.privateJwk.crv
				});
				return true;
			}
		} catch {
			return false;
		}
		if (operation.operation === "sign" || operation.operation === "verify") return nodeSupportedJwaAlgorithm.includes(operation.algorithm);
		if (operation.operation === "encrypt") {
			if (!nodeSupportedEncryptionAlgorithms.includes(operation.encryption.algorithm)) return false;
			if (!operation.keyAgreement) return true;
			return nodeSupportedKeyAgreementAlgorithms.includes(operation.keyAgreement.algorithm);
		}
		if (operation.operation === "decrypt") {
			if (!nodeSupportedEncryptionAlgorithms.includes(operation.decryption.algorithm)) return false;
			if (!operation.keyAgreement) return true;
			return nodeSupportedKeyAgreementAlgorithms.includes(operation.keyAgreement.algorithm);
		}
		return false;
	}
	randomBytes(_agentContext, options) {
		return randomBytes(options.length);
	}
	async getPublicKey(agentContext, keyId) {
		const privateJwk = await _classPrivateFieldGet2(_storage, this).get(agentContext, keyId);
		if (!privateJwk) return null;
		return Kms.publicJwkFromPrivateJwk(privateJwk);
	}
	async importKey(agentContext, options) {
		const { kid } = options.privateJwk;
		if (kid) await this.assertKeyNotExists(agentContext, kid);
		const privateJwk = {
			...options.privateJwk,
			kid: kid ?? randomUUID()
		};
		try {
			if (privateJwk.kty === "oct") createSecretKey(TypedArrayEncoder.fromBase64(privateJwk.k)).export({ format: "jwk" });
			else if (privateJwk.kty === "EC") {
				assertNodeSupportedEcCrv({
					kty: privateJwk.kty,
					crv: privateJwk.crv
				});
				createPrivateKey({
					format: "jwk",
					key: privateJwk
				});
			} else if (privateJwk.kty === "OKP") {
				assertNodeSupportedOkpCrv({
					kty: privateJwk.kty,
					crv: privateJwk.crv
				});
				createPrivateKey({
					format: "jwk",
					key: privateJwk
				});
			} else if (privateJwk.kty === "RSA") createPrivateKey({
				format: "jwk",
				key: privateJwk
			});
			else throw new Kms.KeyManagementAlgorithmNotSupportedError(`kty '${privateJwk.kty}'`, this.backend);
			await _classPrivateFieldGet2(_storage, this).set(agentContext, privateJwk.kid, privateJwk);
			const publicJwk = Kms.publicJwkFromPrivateJwk(privateJwk);
			return {
				keyId: privateJwk.kid,
				publicJwk: {
					...publicJwk,
					kid: privateJwk.kid
				}
			};
		} catch (error) {
			if (error instanceof Kms.KeyManagementError) throw error;
			throw new Kms.KeyManagementError("Error importing key", { cause: error });
		}
	}
	async deleteKey(agentContext, options) {
		return await _classPrivateFieldGet2(_storage, this).delete(agentContext, options.keyId);
	}
	async createKey(agentContext, options) {
		const { type, keyId } = options;
		if (keyId) await this.assertKeyNotExists(agentContext, keyId);
		try {
			let jwks;
			if (type.kty === "EC") {
				assertNodeSupportedEcCrv(type);
				jwks = await createEcKey(type);
			} else if (type.kty === "OKP") {
				assertNodeSupportedOkpCrv(type);
				jwks = await createOkpKey(type);
			} else if (type.kty === "RSA") jwks = await createRsaKey(type);
			else if (type.kty === "oct") {
				assertNodeSupportedOctAlgorithm(type);
				jwks = await createOctKey(type);
			} else throw new Kms.KeyManagementAlgorithmNotSupportedError(`kty '${type.kty}'`, this.backend);
			jwks.privateJwk.kid = keyId ?? randomUUID();
			jwks.publicJwk.kid = jwks.privateJwk.kid;
			await _classPrivateFieldGet2(_storage, this).set(agentContext, jwks.privateJwk.kid, jwks.privateJwk);
			return {
				publicJwk: jwks.publicJwk,
				keyId: jwks.publicJwk.kid
			};
		} catch (error) {
			if (error instanceof Kms.KeyManagementError) throw error;
			throw new Kms.KeyManagementError("Error creating key", { cause: error });
		}
	}
	async sign(agentContext, options) {
		const { keyId, algorithm, data } = options;
		const key = await this.getKeyAsserted(agentContext, keyId);
		try {
			Kms.assertAllowedSigningAlgForKey(key, algorithm);
			Kms.assertKeyAllowsSign(key);
			return { signature: await performSign(key, algorithm, data) };
		} catch (error) {
			if (error instanceof Kms.KeyManagementError) throw error;
			throw new Kms.KeyManagementError("Error signing with key", { cause: error });
		}
	}
	async verify(agentContext, options) {
		const { algorithm, data, signature } = options;
		try {
			let key;
			if (options.key.keyId) key = await this.getKeyAsserted(agentContext, options.key.keyId);
			else if (options.key.publicJwk?.kty === "EC") {
				assertNodeSupportedEcCrv(options.key.publicJwk);
				key = options.key.publicJwk;
			} else if (options.key.publicJwk?.kty === "OKP") {
				assertNodeSupportedOkpCrv(options.key.publicJwk);
				key = options.key.publicJwk;
			} else if (options.key.publicJwk?.kty === "RSA") key = options.key.publicJwk;
			else throw new Kms.KeyManagementAlgorithmNotSupportedError(`kty ${options.key.kty}`, this.backend);
			Kms.assertAllowedSigningAlgForKey(key, algorithm);
			Kms.assertKeyAllowsVerify(key);
			if (await performVerify(key, algorithm, data, signature)) return {
				verified: true,
				publicJwk: Kms.publicJwkFromPrivateJwk(key)
			};
			return { verified: false };
		} catch (error) {
			if (error instanceof Kms.KeyManagementError) throw error;
			throw new Kms.KeyManagementError("Error verifying with key", { cause: error });
		}
	}
	async encrypt(agentContext, options) {
		const { data, encryption, key } = options;
		Kms.assertSupportedEncryptionAlgorithm(encryption, nodeSupportedEncryptionAlgorithms, this.backend);
		let encryptionKey;
		let encryptedKey;
		if (key.keyId) encryptionKey = await this.getKeyAsserted(agentContext, key.keyId);
		else if (key.privateJwk) encryptionKey = key.privateJwk;
		else if (key.keyAgreement) {
			Kms.assertAllowedKeyDerivationAlgForKey(key.keyAgreement.externalPublicJwk, key.keyAgreement.algorithm);
			Kms.assertKeyAllowsDerive(key.keyAgreement.externalPublicJwk);
			Kms.assertSupportedKeyAgreementAlgorithm(key.keyAgreement, nodeSupportedKeyAgreementAlgorithms, this.backend);
			const privateJwk = await this.getKeyAsserted(agentContext, key.keyAgreement.keyId);
			Kms.assertJwkAsymmetric(privateJwk, key.keyAgreement.keyId);
			Kms.assertAllowedKeyDerivationAlgForKey(privateJwk, key.keyAgreement.algorithm);
			Kms.assertKeyAllowsDerive(privateJwk);
			Kms.assertAsymmetricJwkKeyTypeMatches(privateJwk, key.keyAgreement.externalPublicJwk);
			const { contentEncryptionKey, encryptedContentEncryptionKey } = await deriveEncryptionKey({
				keyAgreement: key.keyAgreement,
				encryption,
				privateJwk
			});
			encryptionKey = contentEncryptionKey;
			encryptedKey = encryptedContentEncryptionKey;
		} else throw new Kms.KeyManagementError("Unexpected key parameter for encrypt");
		if (encryptionKey.kty !== "oct") throw new Kms.KeyManagementAlgorithmNotSupportedError(`kty '${encryptionKey.kty} for content encryption'`, this.backend);
		try {
			Kms.assertAllowedEncryptionAlgForKey(encryptionKey, encryption.algorithm);
			Kms.assertKeyAllowsEncrypt(encryptionKey);
			return {
				...await performEncrypt(encryptionKey, options.encryption, data),
				encryptedKey
			};
		} catch (error) {
			if (error instanceof Kms.KeyManagementError) throw error;
			throw new Kms.KeyManagementError("Error encrypting", { cause: error });
		}
	}
	async decrypt(agentContext, options) {
		const { decryption, encrypted, key } = options;
		Kms.assertSupportedEncryptionAlgorithm(decryption, nodeSupportedEncryptionAlgorithms, this.backend);
		let decryptionKey;
		if (key.keyId) decryptionKey = await this.getKeyAsserted(agentContext, key.keyId);
		else if (key.privateJwk) decryptionKey = key.privateJwk;
		else if (key.keyAgreement) {
			Kms.assertSupportedKeyAgreementAlgorithm(key.keyAgreement, nodeSupportedKeyAgreementAlgorithms, this.backend);
			Kms.assertAllowedKeyDerivationAlgForKey(key.keyAgreement.externalPublicJwk, key.keyAgreement.algorithm);
			Kms.assertKeyAllowsDerive(key.keyAgreement.externalPublicJwk);
			const privateJwk = await this.getKeyAsserted(agentContext, key.keyAgreement.keyId);
			Kms.assertJwkAsymmetric(privateJwk, key.keyAgreement.keyId);
			Kms.assertAllowedKeyDerivationAlgForKey(privateJwk, key.keyAgreement.algorithm);
			Kms.assertKeyAllowsDerive(privateJwk);
			Kms.assertAsymmetricJwkKeyTypeMatches(privateJwk, key.keyAgreement.externalPublicJwk);
			const { contentEncryptionKey } = await deriveDecryptionKey({
				keyAgreement: key.keyAgreement,
				decryption,
				privateJwk
			});
			decryptionKey = contentEncryptionKey;
		} else throw new Kms.KeyManagementError("Unexpected key parameter for decrypt");
		if (decryptionKey.kty !== "oct") throw new Kms.KeyManagementAlgorithmNotSupportedError(`kty '${decryptionKey.kty}' for content encryption`, this.backend);
		try {
			Kms.assertAllowedEncryptionAlgForKey(decryptionKey, decryption.algorithm);
			Kms.assertKeyAllowsEncrypt(decryptionKey);
			return await performDecrypt(decryptionKey, decryption, encrypted);
		} catch (error) {
			if (error instanceof Kms.KeyManagementError) throw error;
			throw new Kms.KeyManagementError("Error decrypting", { cause: error });
		}
	}
	async getKeyAsserted(agentContext, keyId) {
		const storageKey = await _classPrivateFieldGet2(_storage, this).get(agentContext, keyId);
		if (!storageKey) throw new Kms.KeyManagementKeyNotFoundError(keyId, [this.backend]);
		return storageKey;
	}
	async assertKeyNotExists(agentContext, keyId) {
		if (await _classPrivateFieldGet2(_storage, this).get(agentContext, keyId)) throw new Kms.KeyManagementKeyExistsError(keyId, this.backend);
	}
};

//#endregion
export { NodeKeyManagementService };
//# sourceMappingURL=NodeKeyManagementService.mjs.map