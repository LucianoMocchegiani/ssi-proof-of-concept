{"version":3,"file":"NodeKeyManagementService.mjs","names":[],"sources":["../../src/kms/NodeKeyManagementService.ts"],"sourcesContent":["import { createPrivateKey, createSecretKey, randomBytes, randomUUID } from 'node:crypto'\nimport type { AgentContext } from '@credo-ts/core'\nimport { Kms, TypedArrayEncoder } from '@credo-ts/core'\nimport {\n  assertNodeSupportedEcCrv,\n  assertNodeSupportedOctAlgorithm,\n  assertNodeSupportedOkpCrv,\n  createEcKey,\n  createOctKey,\n  createOkpKey,\n  createRsaKey,\n} from './crypto/createKey'\nimport { performDecrypt } from './crypto/decrypt'\nimport { deriveDecryptionKey, deriveEncryptionKey, nodeSupportedKeyAgreementAlgorithms } from './crypto/deriveKey'\nimport { nodeSupportedEncryptionAlgorithms, performEncrypt } from './crypto/encrypt'\nimport { nodeSupportedJwaAlgorithm, performSign } from './crypto/sign'\nimport { performVerify } from './crypto/verify'\nimport type { NodeKeyManagementStorage } from './NodeKeyManagementStorage'\n\nexport class NodeKeyManagementService implements Kms.KeyManagementService {\n  public readonly backend = 'node'\n\n  #storage: NodeKeyManagementStorage\n\n  public constructor(storage: NodeKeyManagementStorage) {\n    this.#storage = storage\n  }\n\n  public isOperationSupported(_agentContext: AgentContext, operation: Kms.KmsOperation): boolean {\n    if (operation.operation === 'deleteKey') return true\n    if (operation.operation === 'randomBytes') return true\n\n    if (operation.operation === 'createKey') {\n      // TODO: probably clean to split the assert methods so we don't need try/catch here\n      try {\n        if (operation.type.kty === 'RSA') {\n          return true\n        }\n\n        if (operation.type.kty === 'EC') {\n          assertNodeSupportedEcCrv(operation.type)\n          return true\n        }\n\n        if (operation.type.kty === 'OKP') {\n          assertNodeSupportedOkpCrv(operation.type)\n          return true\n        }\n\n        if (operation.type.kty === 'oct') {\n          assertNodeSupportedOctAlgorithm(operation.type)\n          return true\n        }\n      } catch {\n        return false\n      }\n\n      return false\n    }\n\n    if (operation.operation === 'importKey') {\n      try {\n        if (operation.privateJwk.kty === 'RSA' || operation.privateJwk.kty === 'oct') {\n          return true\n        }\n\n        if (operation.privateJwk.kty === 'EC') {\n          assertNodeSupportedEcCrv({ kty: operation.privateJwk.kty, crv: operation.privateJwk.crv })\n          return true\n        }\n\n        if (operation.privateJwk.kty === 'OKP') {\n          assertNodeSupportedOkpCrv({ kty: operation.privateJwk.kty, crv: operation.privateJwk.crv })\n          return true\n        }\n      } catch {\n        return false\n      }\n    }\n\n    if (operation.operation === 'sign' || operation.operation === 'verify') {\n      return nodeSupportedJwaAlgorithm.includes(operation.algorithm)\n    }\n\n    if (operation.operation === 'encrypt') {\n      const isSupportedEncryptionAlgorithm = nodeSupportedEncryptionAlgorithms.includes(\n        operation.encryption.algorithm as (typeof nodeSupportedEncryptionAlgorithms)[number]\n      )\n      if (!isSupportedEncryptionAlgorithm) return false\n      if (!operation.keyAgreement) return true\n\n      return nodeSupportedKeyAgreementAlgorithms.includes(\n        operation.keyAgreement.algorithm as (typeof nodeSupportedKeyAgreementAlgorithms)[number]\n      )\n    }\n\n    if (operation.operation === 'decrypt') {\n      const isSupportedEncryptionAlgorithm = nodeSupportedEncryptionAlgorithms.includes(\n        operation.decryption.algorithm as (typeof nodeSupportedEncryptionAlgorithms)[number]\n      )\n      if (!isSupportedEncryptionAlgorithm) return false\n      if (!operation.keyAgreement) return true\n\n      return nodeSupportedKeyAgreementAlgorithms.includes(\n        operation.keyAgreement.algorithm as (typeof nodeSupportedKeyAgreementAlgorithms)[number]\n      )\n    }\n\n    return false\n  }\n\n  public randomBytes(_agentContext: AgentContext, options: Kms.KmsRandomBytesOptions): Kms.KmsRandomBytesReturn {\n    return randomBytes(options.length)\n  }\n\n  public async getPublicKey(agentContext: AgentContext, keyId: string): Promise<Kms.KmsJwkPublic | null> {\n    const privateJwk = await this.#storage.get(agentContext, keyId)\n    if (!privateJwk) return null\n\n    return Kms.publicJwkFromPrivateJwk(privateJwk)\n  }\n\n  public async importKey<Jwk extends Kms.KmsJwkPrivate>(\n    agentContext: AgentContext,\n    options: Kms.KmsImportKeyOptions<Jwk>\n  ): Promise<Kms.KmsImportKeyReturn<Jwk>> {\n    const { kid } = options.privateJwk\n\n    if (kid) await this.assertKeyNotExists(agentContext, kid)\n\n    const privateJwk = {\n      ...options.privateJwk,\n      kid: kid ?? randomUUID(),\n    }\n\n    try {\n      if (privateJwk.kty === 'oct') {\n        // Just check if we can create a secret key instance\n        createSecretKey(TypedArrayEncoder.fromBase64(privateJwk.k)).export({ format: 'jwk' })\n      } else if (privateJwk.kty === 'EC') {\n        assertNodeSupportedEcCrv({ kty: privateJwk.kty, crv: privateJwk.crv })\n        // This validates the JWK\n        createPrivateKey({\n          format: 'jwk',\n          key: privateJwk,\n        })\n      } else if (privateJwk.kty === 'OKP') {\n        assertNodeSupportedOkpCrv({ kty: privateJwk.kty, crv: privateJwk.crv })\n        // This validates the JWK\n        createPrivateKey({\n          format: 'jwk',\n          key: privateJwk,\n        })\n      } else if (privateJwk.kty === 'RSA') {\n        // This validates the JWK\n        createPrivateKey({\n          format: 'jwk',\n          key: privateJwk,\n        })\n      } else {\n        // All kty values supported for now, but can change in the future\n        // @ts-expect-error\n        throw new Kms.KeyManagementAlgorithmNotSupportedError(`kty '${privateJwk.kty}'`, this.backend)\n      }\n\n      await this.#storage.set(agentContext, privateJwk.kid, privateJwk)\n      const publicJwk = Kms.publicJwkFromPrivateJwk(privateJwk)\n\n      return {\n        keyId: privateJwk.kid,\n        publicJwk: {\n          ...publicJwk,\n          kid: privateJwk.kid,\n        },\n      } as Kms.KmsImportKeyReturn<Jwk>\n    } catch (error) {\n      if (error instanceof Kms.KeyManagementError) throw error\n\n      throw new Kms.KeyManagementError('Error importing key', { cause: error })\n    }\n  }\n\n  public async deleteKey(agentContext: AgentContext, options: Kms.KmsDeleteKeyOptions): Promise<boolean> {\n    return await this.#storage.delete(agentContext, options.keyId)\n  }\n\n  public async createKey<Type extends Kms.KmsCreateKeyType>(\n    agentContext: AgentContext,\n    options: Kms.KmsCreateKeyOptions<Type>\n  ): Promise<Kms.KmsCreateKeyReturn<Type>> {\n    const { type, keyId } = options\n\n    if (keyId) await this.assertKeyNotExists(agentContext, keyId)\n\n    try {\n      let jwks: { publicJwk: Kms.KmsJwkPublic; privateJwk: Kms.KmsJwkPrivate }\n      if (type.kty === 'EC') {\n        assertNodeSupportedEcCrv(type)\n        jwks = await createEcKey(type)\n      } else if (type.kty === 'OKP') {\n        assertNodeSupportedOkpCrv(type)\n        jwks = await createOkpKey(type)\n      } else if (type.kty === 'RSA') {\n        jwks = await createRsaKey(type)\n      } else if (type.kty === 'oct') {\n        assertNodeSupportedOctAlgorithm(type)\n        jwks = await createOctKey(type)\n      } else {\n        // @ts-expect-error\n        throw new Kms.KeyManagementAlgorithmNotSupportedError(`kty '${type.kty}'`, this.backend)\n      }\n\n      jwks.privateJwk.kid = keyId ?? randomUUID()\n      jwks.publicJwk.kid = jwks.privateJwk.kid\n\n      await this.#storage.set(agentContext, jwks.privateJwk.kid, jwks.privateJwk)\n\n      return {\n        publicJwk: jwks.publicJwk as Kms.KmsCreateKeyReturn<Type>['publicJwk'],\n        keyId: jwks.publicJwk.kid,\n      }\n    } catch (error) {\n      if (error instanceof Kms.KeyManagementError) throw error\n\n      throw new Kms.KeyManagementError('Error creating key', { cause: error })\n    }\n  }\n\n  public async sign(agentContext: AgentContext, options: Kms.KmsSignOptions): Promise<Kms.KmsSignReturn> {\n    const { keyId, algorithm, data } = options\n\n    // 1. Retrieve the key\n    const key = await this.getKeyAsserted(agentContext, keyId)\n\n    try {\n      // 2. Validate alg and use for key\n      Kms.assertAllowedSigningAlgForKey(key, algorithm)\n      Kms.assertKeyAllowsSign(key)\n\n      // 3. Perform the signing operation\n      const signature = await performSign(key, algorithm, data)\n\n      return {\n        signature,\n      }\n    } catch (error) {\n      if (error instanceof Kms.KeyManagementError) throw error\n\n      throw new Kms.KeyManagementError('Error signing with key', { cause: error })\n    }\n  }\n\n  public async verify(agentContext: AgentContext, options: Kms.KmsVerifyOptions): Promise<Kms.KmsVerifyReturn> {\n    const { algorithm, data, signature } = options\n\n    try {\n      let key: Exclude<Kms.KmsJwkPublic, Kms.KmsJwkPublicOct> | Kms.KmsJwkPrivate\n      if (options.key.keyId) {\n        key = await this.getKeyAsserted(agentContext, options.key.keyId)\n      } else if (options.key.publicJwk?.kty === 'EC') {\n        assertNodeSupportedEcCrv(options.key.publicJwk)\n        key = options.key.publicJwk\n      } else if (options.key.publicJwk?.kty === 'OKP') {\n        assertNodeSupportedOkpCrv(options.key.publicJwk)\n        key = options.key.publicJwk\n      } else if (options.key.publicJwk?.kty === 'RSA') {\n        key = options.key.publicJwk\n      } else {\n        // @ts-expect-error\n        throw new Kms.KeyManagementAlgorithmNotSupportedError(`kty ${options.key.kty}`, this.backend)\n      }\n\n      // 2. Validate alg and use for key\n      Kms.assertAllowedSigningAlgForKey(key, algorithm)\n      Kms.assertKeyAllowsVerify(key)\n\n      // 3. Perform the verify operation\n      const verified = await performVerify(key, algorithm, data, signature)\n      if (verified) {\n        return {\n          verified: true,\n          publicJwk: Kms.publicJwkFromPrivateJwk(key),\n        }\n      }\n\n      return {\n        verified: false,\n      }\n    } catch (error) {\n      if (error instanceof Kms.KeyManagementError) throw error\n\n      throw new Kms.KeyManagementError('Error verifying with key', { cause: error })\n    }\n  }\n\n  public async encrypt(agentContext: AgentContext, options: Kms.KmsEncryptOptions): Promise<Kms.KmsEncryptReturn> {\n    const { data, encryption, key } = options\n\n    Kms.assertSupportedEncryptionAlgorithm(encryption, nodeSupportedEncryptionAlgorithms, this.backend)\n\n    let encryptionKey: Kms.KmsJwkPrivate\n    let encryptedKey: Kms.KmsEncryptedKey | undefined\n\n    if (key.keyId) {\n      encryptionKey = await this.getKeyAsserted(agentContext, key.keyId)\n    } else if (key.privateJwk) {\n      encryptionKey = key.privateJwk\n    } else if (key.keyAgreement) {\n      Kms.assertAllowedKeyDerivationAlgForKey(key.keyAgreement.externalPublicJwk, key.keyAgreement.algorithm)\n      Kms.assertKeyAllowsDerive(key.keyAgreement.externalPublicJwk)\n      Kms.assertSupportedKeyAgreementAlgorithm(key.keyAgreement, nodeSupportedKeyAgreementAlgorithms, this.backend)\n\n      const privateJwk = await this.getKeyAsserted(agentContext, key.keyAgreement.keyId)\n      Kms.assertJwkAsymmetric(privateJwk, key.keyAgreement.keyId)\n      Kms.assertAllowedKeyDerivationAlgForKey(privateJwk, key.keyAgreement.algorithm)\n      Kms.assertKeyAllowsDerive(privateJwk)\n      Kms.assertAsymmetricJwkKeyTypeMatches(privateJwk, key.keyAgreement.externalPublicJwk)\n\n      const { contentEncryptionKey, encryptedContentEncryptionKey } = await deriveEncryptionKey({\n        keyAgreement: key.keyAgreement,\n        encryption,\n        privateJwk,\n      })\n\n      encryptionKey = contentEncryptionKey\n      encryptedKey = encryptedContentEncryptionKey\n    } else {\n      throw new Kms.KeyManagementError('Unexpected key parameter for encrypt')\n    }\n\n    if (encryptionKey.kty !== 'oct') {\n      throw new Kms.KeyManagementAlgorithmNotSupportedError(\n        `kty '${encryptionKey.kty} for content encryption'`,\n        this.backend\n      )\n    }\n\n    try {\n      // 2. Validate alg and use for key\n      Kms.assertAllowedEncryptionAlgForKey(encryptionKey, encryption.algorithm)\n      Kms.assertKeyAllowsEncrypt(encryptionKey)\n\n      // 3. Perform the encryption operation\n      const encrypted = await performEncrypt(encryptionKey, options.encryption, data)\n      return {\n        ...encrypted,\n        encryptedKey,\n      }\n    } catch (error) {\n      if (error instanceof Kms.KeyManagementError) throw error\n\n      throw new Kms.KeyManagementError('Error encrypting', { cause: error })\n    }\n  }\n\n  public async decrypt(agentContext: AgentContext, options: Kms.KmsDecryptOptions): Promise<Kms.KmsDecryptReturn> {\n    const { decryption, encrypted, key } = options\n\n    Kms.assertSupportedEncryptionAlgorithm(decryption, nodeSupportedEncryptionAlgorithms, this.backend)\n\n    let decryptionKey: Kms.KmsJwkPrivate\n    if (key.keyId) {\n      decryptionKey = await this.getKeyAsserted(agentContext, key.keyId)\n    } else if (key.privateJwk) {\n      decryptionKey = key.privateJwk\n    } else if (key.keyAgreement) {\n      Kms.assertSupportedKeyAgreementAlgorithm(key.keyAgreement, nodeSupportedKeyAgreementAlgorithms, this.backend)\n      Kms.assertAllowedKeyDerivationAlgForKey(key.keyAgreement.externalPublicJwk, key.keyAgreement.algorithm)\n      Kms.assertKeyAllowsDerive(key.keyAgreement.externalPublicJwk)\n\n      const privateJwk = await this.getKeyAsserted(agentContext, key.keyAgreement.keyId)\n      Kms.assertJwkAsymmetric(privateJwk, key.keyAgreement.keyId)\n      Kms.assertAllowedKeyDerivationAlgForKey(privateJwk, key.keyAgreement.algorithm)\n      Kms.assertKeyAllowsDerive(privateJwk)\n      Kms.assertAsymmetricJwkKeyTypeMatches(privateJwk, key.keyAgreement.externalPublicJwk)\n\n      const { contentEncryptionKey } = await deriveDecryptionKey({\n        keyAgreement: key.keyAgreement,\n        decryption,\n        privateJwk,\n      })\n\n      decryptionKey = contentEncryptionKey\n    } else {\n      throw new Kms.KeyManagementError('Unexpected key parameter for decrypt')\n    }\n\n    if (decryptionKey.kty !== 'oct') {\n      throw new Kms.KeyManagementAlgorithmNotSupportedError(\n        `kty '${decryptionKey.kty}' for content encryption`,\n        this.backend\n      )\n    }\n\n    try {\n      // 2. Validate alg and use for key\n      Kms.assertAllowedEncryptionAlgForKey(decryptionKey, decryption.algorithm)\n      Kms.assertKeyAllowsEncrypt(decryptionKey)\n\n      // 3. Perform the decryption operation\n      return await performDecrypt(decryptionKey, decryption, encrypted)\n    } catch (error) {\n      if (error instanceof Kms.KeyManagementError) throw error\n\n      throw new Kms.KeyManagementError('Error decrypting', { cause: error })\n    }\n  }\n\n  private async getKeyAsserted(agentContext: AgentContext, keyId: string) {\n    const storageKey = await this.#storage.get(agentContext, keyId)\n    if (!storageKey) {\n      throw new Kms.KeyManagementKeyNotFoundError(keyId, [this.backend])\n    }\n\n    return storageKey\n  }\n\n  private async assertKeyNotExists(agentContext: AgentContext, keyId: string) {\n    const storageKey = await this.#storage.get(agentContext, keyId)\n\n    if (storageKey) {\n      throw new Kms.KeyManagementKeyExistsError(keyId, this.backend)\n    }\n  }\n}\n"],"mappings":"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"}