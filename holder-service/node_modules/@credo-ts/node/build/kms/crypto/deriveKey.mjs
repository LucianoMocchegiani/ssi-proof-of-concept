import { Kms, TypedArrayEncoder } from "@credo-ts/core";
import { createECDH, createHash, getRandomValues, subtle } from "node:crypto";
import { Buffer } from "node:buffer";

//#region src/kms/crypto/deriveKey.ts
const nodeSupportedEcdhKeyDerivationEcCrv = [
	"P-256",
	"P-384",
	"P-521",
	"secp256k1"
];
const nodeSupportedKeyAgreementAlgorithms = [
	"ECDH-ES",
	"ECDH-ES+A128KW",
	"ECDH-ES+A192KW",
	"ECDH-ES+A256KW"
];
function assertNodeSupportedEcdhKeyDerivationCrv(jwk) {
	if (jwk.kty === "OKP" && jwk.crv !== "X25519" || jwk.kty === "EC" && !nodeSupportedEcdhKeyDerivationEcCrv.includes(jwk.crv)) throw new Kms.KeyManagementAlgorithmNotSupportedError(`key derivation with crv '${jwk.crv}' for kty '${jwk.kty}'`, "node");
}
async function deriveEncryptionKey(options) {
	const { keyAgreement, encryption, privateJwk } = options;
	assertNodeSupportedEcdhKeyDerivationCrv(keyAgreement.externalPublicJwk);
	assertNodeSupportedEcdhKeyDerivationCrv(privateJwk);
	const derivedKeyBytes = await deriveKeyEcdhEs({
		keyLength: keyAgreement.algorithm === "ECDH-ES" ? mapContentEncryptionAlgorithmToKeyLength(encryption.algorithm) : keyAgreement.algorithm === "ECDH-ES+A128KW" ? 128 : keyAgreement.algorithm === "ECDH-ES+A192KW" ? 192 : 256,
		usageAlgorithm: keyAgreement.algorithm === "ECDH-ES" ? encryption.algorithm : keyAgreement.algorithm,
		privateJwk,
		publicJwk: keyAgreement.externalPublicJwk,
		apu: keyAgreement.apu,
		apv: keyAgreement.apv
	});
	if (keyAgreement.algorithm === "ECDH-ES") return { contentEncryptionKey: {
		kty: "oct",
		k: derivedKeyBytes.toString("base64url")
	} };
	const derivedKey = await subtle.importKey("raw", derivedKeyBytes, "AES-KW", true, ["wrapKey"]);
	const contentEncryptionKeyBytes = Buffer.from(getRandomValues(new Uint8Array(mapContentEncryptionAlgorithmToKeyLength(encryption.algorithm) >> 3)));
	const contentEncryptionKey = await subtle.importKey("raw", contentEncryptionKeyBytes, "AES-KW", true, ["wrapKey"]);
	const encryptedContentEncryptionKey = await subtle.wrapKey("raw", contentEncryptionKey, derivedKey, "AES-KW");
	return {
		encryptedContentEncryptionKey: { encrypted: Buffer.from(encryptedContentEncryptionKey) },
		contentEncryptionKey: {
			kty: "oct",
			k: contentEncryptionKeyBytes.toString("base64url")
		}
	};
}
async function deriveDecryptionKey(options) {
	const { keyAgreement, decryption, privateJwk } = options;
	assertNodeSupportedEcdhKeyDerivationCrv(keyAgreement.externalPublicJwk);
	assertNodeSupportedEcdhKeyDerivationCrv(privateJwk);
	const derivedKeyBytes = await deriveKeyEcdhEs({
		keyLength: keyAgreement.algorithm === "ECDH-ES" ? mapContentEncryptionAlgorithmToKeyLength(decryption.algorithm) : keyAgreement.algorithm === "ECDH-ES+A128KW" ? 128 : keyAgreement.algorithm === "ECDH-ES+A192KW" ? 192 : 256,
		usageAlgorithm: keyAgreement.algorithm === "ECDH-ES" ? decryption.algorithm : keyAgreement.algorithm,
		privateJwk,
		publicJwk: keyAgreement.externalPublicJwk,
		apu: keyAgreement.apu,
		apv: keyAgreement.apv
	});
	if (keyAgreement.algorithm === "ECDH-ES") return { contentEncryptionKey: {
		kty: "oct",
		k: derivedKeyBytes.toString("base64url")
	} };
	const derivedKey = await subtle.importKey("raw", derivedKeyBytes, "AES-KW", true, ["wrapKey"]);
	const contentEncryptionKey = await subtle.unwrapKey("raw", keyAgreement.encryptedKey.encrypted, derivedKey, "AES-KW", {
		hash: "SHA-256",
		name: "HMAC"
	}, true, ["decrypt"]);
	return { contentEncryptionKey: await subtle.exportKey("jwk", contentEncryptionKey) };
}
/**
* Derive a key using ECDH and Concat KDF
*/
async function deriveKeyEcdhEs(options) {
	const nodeEcdhCurveName = mapCrvToNodeEcdhCurveName(options.privateJwk.crv);
	const nodeConcatKdfHash = mapCrvToHashLength(options.publicJwk.crv);
	const ecdh = createECDH(nodeEcdhCurveName);
	ecdh.setPrivateKey(TypedArrayEncoder.fromBase64(options.privateJwk.d));
	const publicKey = Kms.PublicJwk.fromPublicJwk(options.publicJwk).publicKey;
	if (publicKey.kty === "RSA") throw new Kms.KeyManagementError("Key type RSA is not supported for ECDH-ES");
	const sharedSecret = ecdh.computeSecret(publicKey.publicKey);
	const algorithmData = Buffer.from(options.usageAlgorithm);
	const algorithmID = Buffer.concat([numberTo4ByteUint8Array(algorithmData.length), algorithmData]);
	const apu = options.apu || Buffer.alloc(0);
	const partyUInfo = Buffer.concat([numberTo4ByteUint8Array(apu.length), apu]);
	const apv = options.apv || Buffer.alloc(0);
	const partyVInfo = Buffer.concat([numberTo4ByteUint8Array(apv.length), apv]);
	const otherInfo = Buffer.concat([
		algorithmID,
		partyUInfo,
		partyVInfo,
		numberTo4ByteUint8Array(options.keyLength),
		Buffer.alloc(0)
	]);
	return concatKDF(sharedSecret, options.keyLength, nodeConcatKdfHash, otherInfo);
}
function numberTo4ByteUint8Array(number) {
	const buffer = /* @__PURE__ */ new ArrayBuffer(4);
	new DataView(buffer).setUint32(0, number);
	return new Uint8Array(buffer);
}
/**
* Implements Concat KDF as per NIST SP 800-56A
*/
function concatKDF(secret, length, hashLength, otherInfo) {
	const reps = Math.ceil((length >> 3) / (hashLength >> 3));
	const output = Buffer.alloc(reps * (hashLength >> 3));
	for (let i = 0; i < reps; i++) {
		const counter = Buffer.alloc(4 + secret.length + otherInfo.length);
		counter.writeUInt32BE(i + 1);
		counter.set(secret, 4);
		counter.set(otherInfo, 4 + secret.length);
		createHash(`sha${hashLength}`).update(counter).digest().copy(output, i * hashLength >> 3);
	}
	return output.subarray(0, length >> 3);
}
function mapCrvToNodeEcdhCurveName(crv) {
	switch (crv) {
		case "P-256": return "prime256v1";
		case "P-384": return "secp384r1";
		case "P-521": return "secp521r1";
		case "secp256k1": return "secp256k1";
		case "X25519": return "x25519";
		default: throw new Kms.KeyManagementAlgorithmNotSupportedError(`crv '${crv}' for ECDH-ES`, "node");
	}
}
function mapCrvToHashLength(crv) {
	switch (crv) {
		case "secp256k1":
		case "X25519":
		case "P-256": return 256;
		case "P-384": return 384;
		case "P-521": return 512;
		default: throw new Kms.KeyManagementAlgorithmNotSupportedError(`crv '${crv}' for ECDH-ES`, "node");
	}
}
function mapContentEncryptionAlgorithmToKeyLength(encryptionAlgorithm) {
	switch (encryptionAlgorithm) {
		case "A128CBC":
		case "A128GCM":
		case "A128KW": return 128;
		case "A192KW": return 192;
		case "A128CBC-HS256":
		case "A256CBC":
		case "A256GCM":
		case "C20P":
		case "XC20P":
		case "A256KW": return 256;
		case "A192CBC-HS384":
		case "A192GCM": return 384;
		case "A256CBC-HS512": return 512;
		case "XSALSA20-POLY1305": return 256;
	}
}

//#endregion
export { deriveDecryptionKey, deriveEncryptionKey, nodeSupportedKeyAgreementAlgorithms };
//# sourceMappingURL=deriveKey.mjs.map