{"version":3,"file":"deriveKey.mjs","names":[],"sources":["../../../src/kms/crypto/deriveKey.ts"],"sourcesContent":["import { Buffer } from 'node:buffer'\nimport { createECDH, createHash, getRandomValues, subtle } from 'node:crypto'\nimport { type AnyUint8Array, Kms, TypedArrayEncoder } from '@credo-ts/core'\nimport type { NodeKmsSupportedEcCrvs } from './createKey'\n\nconst nodeSupportedEcdhKeyDerivationEcCrv = [\n  'P-256',\n  'P-384',\n  'P-521',\n  'secp256k1',\n] as const satisfies NodeKmsSupportedEcCrvs[]\n\nexport const nodeSupportedKeyAgreementAlgorithms = [\n  'ECDH-ES',\n  'ECDH-ES+A128KW',\n  'ECDH-ES+A192KW',\n  'ECDH-ES+A256KW',\n] satisfies Kms.KnownJwaKeyAgreementAlgorithm[]\n\nfunction assertNodeSupportedEcdhKeyDerivationCrv<Jwk extends Kms.KmsJwkPrivateAsymmetric | Kms.KmsJwkPublicAsymmetric>(\n  jwk: Jwk\n): asserts jwk is Jwk & { kty: 'OKP' | 'EC'; crv: (typeof nodeSupportedEcdhKeyDerivationEcCrv)[number] | 'X25519' } {\n  if (\n    (jwk.kty === 'OKP' && jwk.crv !== 'X25519') ||\n    (jwk.kty === 'EC' && !(nodeSupportedEcdhKeyDerivationEcCrv as string[]).includes(jwk.crv))\n  ) {\n    throw new Kms.KeyManagementAlgorithmNotSupportedError(\n      `key derivation with crv '${jwk.crv}' for kty '${jwk.kty}'`,\n      'node'\n    )\n  }\n}\n\ntype NodeSupportedKeyAgreementDecryptOptions = Kms.KmsKeyAgreementDecryptOptions & {\n  algorithm: (typeof nodeSupportedKeyAgreementAlgorithms)[number]\n}\ntype NodeSupportedKeyAgreementEncryptOptions = Kms.KmsKeyAgreementEncryptOptions & {\n  algorithm: (typeof nodeSupportedKeyAgreementAlgorithms)[number]\n}\n\nexport async function deriveEncryptionKey(options: {\n  keyAgreement: NodeSupportedKeyAgreementEncryptOptions\n  privateJwk: Kms.KmsJwkPrivateAsymmetric\n  encryption: Kms.KmsEncryptDataEncryption\n}) {\n  const { keyAgreement, encryption, privateJwk } = options\n\n  assertNodeSupportedEcdhKeyDerivationCrv(keyAgreement.externalPublicJwk)\n  assertNodeSupportedEcdhKeyDerivationCrv(privateJwk)\n\n  const keyLength =\n    keyAgreement.algorithm === 'ECDH-ES'\n      ? mapContentEncryptionAlgorithmToKeyLength(encryption.algorithm)\n      : keyAgreement.algorithm === 'ECDH-ES+A128KW'\n        ? 128\n        : keyAgreement.algorithm === 'ECDH-ES+A192KW'\n          ? 192\n          : 256\n\n  const derivedKeyBytes = await deriveKeyEcdhEs({\n    keyLength,\n    usageAlgorithm: keyAgreement.algorithm === 'ECDH-ES' ? encryption.algorithm : keyAgreement.algorithm,\n    privateJwk,\n    publicJwk: keyAgreement.externalPublicJwk,\n    apu: keyAgreement.apu,\n    apv: keyAgreement.apv,\n  })\n\n  if (keyAgreement.algorithm === 'ECDH-ES') {\n    return {\n      // TODO: will be more efficient to return node key instance\n      contentEncryptionKey: {\n        kty: 'oct',\n        k: derivedKeyBytes.toString('base64url'),\n      } as const,\n    }\n  }\n\n  // Key wrapping\n  const derivedKey = await subtle.importKey('raw', derivedKeyBytes, 'AES-KW', true, ['wrapKey'])\n  const contentEncryptionKeyBytes = Buffer.from(\n    getRandomValues(new Uint8Array(mapContentEncryptionAlgorithmToKeyLength(encryption.algorithm) >> 3))\n  )\n  const contentEncryptionKey = await subtle.importKey('raw', contentEncryptionKeyBytes, 'AES-KW', true, ['wrapKey'])\n  const encryptedContentEncryptionKey = await subtle.wrapKey('raw', contentEncryptionKey, derivedKey, 'AES-KW')\n\n  return {\n    encryptedContentEncryptionKey: {\n      encrypted: Buffer.from(encryptedContentEncryptionKey),\n    } satisfies Kms.KmsEncryptedKey,\n    contentEncryptionKey: {\n      kty: 'oct',\n      k: contentEncryptionKeyBytes.toString('base64url'),\n    } as const,\n  }\n}\n\nexport async function deriveDecryptionKey(options: {\n  keyAgreement: NodeSupportedKeyAgreementDecryptOptions\n  privateJwk: Kms.KmsJwkPrivateAsymmetric\n  decryption: Kms.KmsDecryptDataDecryption\n}) {\n  const { keyAgreement, decryption, privateJwk } = options\n\n  assertNodeSupportedEcdhKeyDerivationCrv(keyAgreement.externalPublicJwk)\n  assertNodeSupportedEcdhKeyDerivationCrv(privateJwk)\n\n  const keyLength =\n    keyAgreement.algorithm === 'ECDH-ES'\n      ? mapContentEncryptionAlgorithmToKeyLength(decryption.algorithm)\n      : keyAgreement.algorithm === 'ECDH-ES+A128KW'\n        ? 128\n        : keyAgreement.algorithm === 'ECDH-ES+A192KW'\n          ? 192\n          : 256\n\n  const derivedKeyBytes = await deriveKeyEcdhEs({\n    keyLength,\n    usageAlgorithm: keyAgreement.algorithm === 'ECDH-ES' ? decryption.algorithm : keyAgreement.algorithm,\n    privateJwk: privateJwk,\n    publicJwk: keyAgreement.externalPublicJwk,\n    apu: keyAgreement.apu,\n    apv: keyAgreement.apv,\n  })\n\n  if (keyAgreement.algorithm === 'ECDH-ES') {\n    return {\n      // TODO: will be more efficient to return node key instance\n      contentEncryptionKey: {\n        kty: 'oct',\n        k: derivedKeyBytes.toString('base64url'),\n      } as const,\n    }\n  }\n\n  // Key wrapping\n  const derivedKey = await subtle.importKey('raw', derivedKeyBytes, 'AES-KW', true, ['wrapKey'])\n\n  const contentEncryptionKey = await subtle.unwrapKey(\n    'raw',\n    keyAgreement.encryptedKey.encrypted,\n    derivedKey,\n    'AES-KW',\n    // algorithm used is irrelevant\n    { hash: 'SHA-256', name: 'HMAC' },\n    true,\n    ['decrypt']\n  )\n\n  return {\n    contentEncryptionKey: (await subtle.exportKey('jwk', contentEncryptionKey)) as Kms.KmsJwkPrivate,\n  }\n}\n\n/**\n * Derive a key using ECDH and Concat KDF\n */\nasync function deriveKeyEcdhEs(options: {\n  keyLength: number\n  /**\n   * This is only used for the AlgorithmID in KDF\n   */\n  usageAlgorithm: string\n  apv?: AnyUint8Array\n  apu?: AnyUint8Array\n  privateJwk: Kms.KmsJwkPrivateEc | Kms.KmsJwkPrivateOkp\n  publicJwk: Kms.KmsJwkPublicEc | Kms.KmsJwkPublicOkp\n}): Promise<Buffer> {\n  // const privateKey = createPrivateKey({ format: 'jwk', key: options.privateJwk })\n  // const publicKey = createPublicKey({ format: 'jwk', key: options.publicJwk })\n\n  // Create ECDH instance based on curve\n  const nodeEcdhCurveName = mapCrvToNodeEcdhCurveName(options.privateJwk.crv)\n  const nodeConcatKdfHash = mapCrvToHashLength(options.publicJwk.crv)\n\n  const ecdh = createECDH(nodeEcdhCurveName)\n\n  // Set private key\n  ecdh.setPrivateKey(TypedArrayEncoder.fromBase64(options.privateJwk.d))\n\n  const publicKey = Kms.PublicJwk.fromPublicJwk(options.publicJwk).publicKey\n  if (publicKey.kty === 'RSA') {\n    throw new Kms.KeyManagementError('Key type RSA is not supported for ECDH-ES')\n  }\n\n  // Compute shared secret\n  const sharedSecret = ecdh.computeSecret(publicKey.publicKey)\n\n  // Prepare AlgorithmID for KDF (Datalen || Data)\n  const algorithmData = Buffer.from(options.usageAlgorithm) // ASCII representation of alg\n  const algorithmID = Buffer.concat([\n    numberTo4ByteUint8Array(algorithmData.length), // Datalen: 32-bit big-endian counter\n    algorithmData, // Data: ASCII representation of algorithm\n  ])\n\n  // Prepare PartyUInfo with proper length prefix\n  const apu = options.apu || Buffer.alloc(0)\n  const partyUInfo = Buffer.concat([\n    numberTo4ByteUint8Array(apu.length), // Datalen: 32-bit big-endian counter\n    apu, // Data: PartyUInfo value\n  ])\n\n  // Prepare PartyVInfo with proper length prefix\n  const apv = options.apv || Buffer.alloc(0)\n  const partyVInfo = Buffer.concat([\n    numberTo4ByteUint8Array(apv.length), // Datalen: 32-bit big-endian counter\n    apv, // Data: PartyVInfo value\n  ])\n\n  // Prepare otherInfo for KDF\n  const otherInfo = Buffer.concat([\n    algorithmID, // AlgorithmID: Datalen || Data\n    partyUInfo, // PartyUInfo: Datalen || Data\n    partyVInfo, // PartyVInfo: Datalen || Data\n    numberTo4ByteUint8Array(options.keyLength), // SuppPubInfo: 32-bit big-endian rep of keydatalen\n    Buffer.alloc(0), // SuppPrivInfo (empty octet sequence)\n  ])\n\n  // Derive final key using Concat KDF\n  return concatKDF(sharedSecret, options.keyLength, nodeConcatKdfHash, otherInfo)\n}\n\nfunction numberTo4ByteUint8Array(number: number) {\n  const buffer = new ArrayBuffer(4)\n  const view = new DataView(buffer)\n  view.setUint32(0, number)\n  return new Uint8Array(buffer)\n}\n\n/**\n * Implements Concat KDF as per NIST SP 800-56A\n */\nfunction concatKDF(secret: Buffer, length: number, hashLength: ConcatKdfHashLength, otherInfo: Buffer): Buffer {\n  const reps = Math.ceil((length >> 3) / (hashLength >> 3))\n  const output = Buffer.alloc(reps * (hashLength >> 3))\n\n  for (let i = 0; i < reps; i++) {\n    const counter = Buffer.alloc(4 + secret.length + otherInfo.length)\n    counter.writeUInt32BE(i + 1)\n    counter.set(secret, 4)\n    counter.set(otherInfo, 4 + secret.length)\n\n    createHash(`sha${hashLength}`)\n      .update(counter)\n      .digest()\n      .copy(output, (i * hashLength) >> 3)\n  }\n\n  return output.subarray(0, length >> 3)\n}\n\nfunction mapCrvToNodeEcdhCurveName(crv: Kms.KmsJwkPublicEc['crv'] | Kms.KmsJwkPublicOkp['crv']) {\n  switch (crv) {\n    case 'P-256':\n      return 'prime256v1'\n    case 'P-384':\n      return 'secp384r1'\n    case 'P-521':\n      return 'secp521r1'\n    case 'secp256k1':\n      return 'secp256k1'\n    case 'X25519':\n      return 'x25519'\n    default:\n      throw new Kms.KeyManagementAlgorithmNotSupportedError(`crv '${crv}' for ECDH-ES`, 'node')\n  }\n}\n\ntype ConcatKdfHashLength = ReturnType<typeof mapCrvToHashLength>\nfunction mapCrvToHashLength(crv: Kms.KmsJwkPublicEc['crv'] | Kms.KmsJwkPublicOkp['crv']) {\n  switch (crv) {\n    case 'secp256k1':\n    case 'X25519':\n    case 'P-256':\n      return 256\n    case 'P-384':\n      return 384\n    case 'P-521':\n      return 512\n    default:\n      throw new Kms.KeyManagementAlgorithmNotSupportedError(`crv '${crv}' for ECDH-ES`, 'node')\n  }\n}\n\n// TODO: might be worthwhile to add this to core?\n// TODO: we might want to have a separate definition per algorithm\n// defines things such as required key length.\nfunction mapContentEncryptionAlgorithmToKeyLength(\n  encryptionAlgorithm: Kms.KnownJwaContentEncryptionAlgorithm | Kms.KnownJwaKeyEncryptionAlgorithm\n): number {\n  switch (encryptionAlgorithm) {\n    case 'A128CBC':\n    case 'A128GCM':\n    case 'A128KW':\n      return 128\n    case 'A192KW':\n      return 192\n    case 'A128CBC-HS256':\n    case 'A256CBC':\n    case 'A256GCM':\n    case 'C20P':\n    case 'XC20P':\n    case 'A256KW':\n      return 256\n\n    case 'A192CBC-HS384':\n    case 'A192GCM':\n      return 384\n    case 'A256CBC-HS512':\n      return 512\n    case 'XSALSA20-POLY1305':\n      return 256\n  }\n}\n"],"mappings":"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"}