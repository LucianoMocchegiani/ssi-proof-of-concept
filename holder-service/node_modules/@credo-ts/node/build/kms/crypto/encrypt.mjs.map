{"version":3,"file":"encrypt.mjs","names":[],"sources":["../../../src/kms/crypto/encrypt.ts"],"sourcesContent":["import { Buffer } from 'node:buffer'\nimport type { CipherGCM } from 'node:crypto'\nimport { createCipheriv, createSecretKey, randomBytes } from 'node:crypto'\nimport { type AnyUint8Array, Kms, type Uint8ArrayBuffer } from '@credo-ts/core'\n\nimport { performSign } from './sign'\n\nexport const nodeSupportedEncryptionAlgorithms = [\n  'A128CBC',\n  'A256CBC',\n  'A128CBC-HS256',\n  'A192CBC-HS384',\n  'A256CBC-HS512',\n  'A128GCM',\n  'A192GCM',\n  'A256GCM',\n  'C20P',\n] as const satisfies Kms.KnownJwaContentEncryptionAlgorithm[]\n\nexport async function performEncrypt(\n  key: Kms.KmsJwkPrivateOct,\n  dataEncryption: Kms.KmsEncryptDataEncryption,\n  data: AnyUint8Array\n): Promise<{ encrypted: Uint8ArrayBuffer; tag?: Uint8ArrayBuffer; iv: AnyUint8Array }> {\n  const secretKeyBytes = Buffer.from(key.k, 'base64url')\n  const nodeKey = createSecretKey(secretKeyBytes)\n\n  // Create cipher with key and IV\n  if (dataEncryption.algorithm === 'A128CBC' || dataEncryption.algorithm === 'A256CBC') {\n    const nodeAlgorithm = dataEncryption.algorithm === 'A128CBC' ? 'aes-128-cbc' : 'aes-256-cbc'\n\n    // IV should be exactly 16 bytes (128 bits) for CBC mode\n    const iv = dataEncryption.iv ?? randomBytes(16)\n\n    const cipher = createCipheriv(nodeAlgorithm, nodeKey, iv)\n\n    // Get encrypted data\n    const encrypted = Buffer.concat([cipher.update(data), cipher.final()])\n\n    return { encrypted, iv }\n  }\n  if (\n    dataEncryption.algorithm === 'A128CBC-HS256' ||\n    dataEncryption.algorithm === 'A192CBC-HS384' ||\n    dataEncryption.algorithm === 'A256CBC-HS512'\n  ) {\n    // Map algorithms to their corresponding CBC and HMAC settings\n    const algSettings = {\n      'A128CBC-HS256': { cbcAlg: 'aes-128-cbc', hmacAlg: 'HS256', keySize: 16 } as const,\n      'A192CBC-HS384': { cbcAlg: 'aes-192-cbc', hmacAlg: 'HS384', keySize: 24 } as const,\n      'A256CBC-HS512': { cbcAlg: 'aes-256-cbc', hmacAlg: 'HS512', keySize: 32 } as const,\n    }[dataEncryption.algorithm]\n\n    // IV should be exactly 16 bytes (128 bits) for CBC mode\n    const iv = dataEncryption.iv ?? randomBytes(16)\n\n    // Split the input key into MAC and ENC keys (MAC key is first half, ENC key is second half)\n    const macKey = secretKeyBytes.subarray(0, algSettings.keySize)\n    const encKey = createSecretKey(secretKeyBytes.subarray(algSettings.keySize))\n\n    // Perform encryption\n    const cipher = createCipheriv(algSettings.cbcAlg, encKey, iv)\n    const encrypted = Buffer.concat([cipher.update(data), cipher.final()])\n\n    // Calculate authentication tag\n    // AL (Associated Length) is 64-bit big-endian length of AAD in bits\n    const al = Buffer.alloc(8)\n    const aadLength = dataEncryption.aad ? dataEncryption.aad.length * 8 : 0\n    al.writeBigUInt64BE(BigInt(aadLength))\n\n    // Create concatenated buffer for MAC calculation\n    const macData = Buffer.concat([\n      // If AAD exists, include it first, otherwise empty buffer\n      dataEncryption.aad ?? Buffer.alloc(0),\n      iv, // Initial Vector\n      encrypted, // Ciphertext\n      al, // Associated Length (AL)\n    ])\n\n    const hmac = await performSign({ kty: 'oct', k: macKey.toString('base64url') }, algSettings.hmacAlg, macData)\n    const tag = Buffer.from(hmac).subarray(0, algSettings.keySize) // Truncate to appropriate size\n\n    return { encrypted, tag, iv }\n  }\n  if (\n    dataEncryption.algorithm === 'A128GCM' ||\n    dataEncryption.algorithm === 'A192GCM' ||\n    dataEncryption.algorithm === 'A256GCM'\n  ) {\n    const nodeAlgorithm =\n      dataEncryption.algorithm === 'A128GCM'\n        ? 'aes-128-gcm'\n        : dataEncryption.algorithm === 'A192GCM'\n          ? 'aes-192-gcm'\n          : 'aes-256-gcm'\n\n    // IV should be exactly 12 bytes (96 bits) for GCM\n    const iv = dataEncryption.iv ?? randomBytes(12)\n\n    const cipher = createCipheriv(nodeAlgorithm, nodeKey, iv)\n\n    // If AAD is provided, update the cipher with it before encryption\n    if (dataEncryption.aad) {\n      cipher.setAAD(dataEncryption.aad)\n    }\n\n    // Get encrypted data\n    const encrypted = Buffer.concat([cipher.update(data), cipher.final()])\n\n    // Get auth tag - must be saved to verify decryption\n    const tag = cipher.getAuthTag() as Uint8ArrayBuffer\n\n    return {\n      encrypted,\n      tag,\n      iv,\n    }\n  }\n  if (dataEncryption.algorithm === 'C20P') {\n    // IV should be exactly 12 bytes (96 bits) for C20P\n    const iv = dataEncryption.iv ?? randomBytes(12)\n\n    const cipher: CipherGCM = createCipheriv('chacha20-poly1305', nodeKey, iv, {\n      authTagLength: 16,\n    })\n\n    // If AAD is provided, update the cipher with it before encryption\n    if (dataEncryption.aad) {\n      cipher.setAAD(dataEncryption.aad)\n    }\n\n    // Get encrypted data\n    const encrypted = Buffer.concat([cipher.update(data), cipher.final()])\n\n    // Get auth tag - must be saved to verify decryption\n    const tag = cipher.getAuthTag() as Uint8ArrayBuffer\n\n    return {\n      encrypted,\n      tag,\n      iv,\n    }\n  }\n\n  throw new Kms.KeyManagementAlgorithmNotSupportedError(\n    `JWA content encryption algorithm '${dataEncryption.algorithm}'`,\n    'node'\n  )\n}\n"],"mappings":";;;;;;AAOA,MAAa,oCAAoC;CAC/C;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACD;AAED,eAAsB,eACpB,KACA,gBACA,MACqF;CACrF,MAAM,iBAAiB,OAAO,KAAK,IAAI,GAAG,YAAY;CACtD,MAAM,UAAU,gBAAgB,eAAe;AAG/C,KAAI,eAAe,cAAc,aAAa,eAAe,cAAc,WAAW;EACpF,MAAM,gBAAgB,eAAe,cAAc,YAAY,gBAAgB;EAG/E,MAAM,KAAK,eAAe,MAAM,YAAY,GAAG;EAE/C,MAAM,SAAS,eAAe,eAAe,SAAS,GAAG;AAKzD,SAAO;GAAE,WAFS,OAAO,OAAO,CAAC,OAAO,OAAO,KAAK,EAAE,OAAO,OAAO,CAAC,CAAC;GAElD;GAAI;;AAE1B,KACE,eAAe,cAAc,mBAC7B,eAAe,cAAc,mBAC7B,eAAe,cAAc,iBAC7B;EAEA,MAAM,cAAc;GAClB,iBAAiB;IAAE,QAAQ;IAAe,SAAS;IAAS,SAAS;IAAI;GACzE,iBAAiB;IAAE,QAAQ;IAAe,SAAS;IAAS,SAAS;IAAI;GACzE,iBAAiB;IAAE,QAAQ;IAAe,SAAS;IAAS,SAAS;IAAI;GAC1E,CAAC,eAAe;EAGjB,MAAM,KAAK,eAAe,MAAM,YAAY,GAAG;EAG/C,MAAM,SAAS,eAAe,SAAS,GAAG,YAAY,QAAQ;EAC9D,MAAM,SAAS,gBAAgB,eAAe,SAAS,YAAY,QAAQ,CAAC;EAG5E,MAAM,SAAS,eAAe,YAAY,QAAQ,QAAQ,GAAG;EAC7D,MAAM,YAAY,OAAO,OAAO,CAAC,OAAO,OAAO,KAAK,EAAE,OAAO,OAAO,CAAC,CAAC;EAItE,MAAM,KAAK,OAAO,MAAM,EAAE;EAC1B,MAAM,YAAY,eAAe,MAAM,eAAe,IAAI,SAAS,IAAI;AACvE,KAAG,iBAAiB,OAAO,UAAU,CAAC;EAGtC,MAAM,UAAU,OAAO,OAAO;GAE5B,eAAe,OAAO,OAAO,MAAM,EAAE;GACrC;GACA;GACA;GACD,CAAC;EAEF,MAAM,OAAO,MAAM,YAAY;GAAE,KAAK;GAAO,GAAG,OAAO,SAAS,YAAY;GAAE,EAAE,YAAY,SAAS,QAAQ;AAG7G,SAAO;GAAE;GAAW,KAFR,OAAO,KAAK,KAAK,CAAC,SAAS,GAAG,YAAY,QAAQ;GAErC;GAAI;;AAE/B,KACE,eAAe,cAAc,aAC7B,eAAe,cAAc,aAC7B,eAAe,cAAc,WAC7B;EACA,MAAM,gBACJ,eAAe,cAAc,YACzB,gBACA,eAAe,cAAc,YAC3B,gBACA;EAGR,MAAM,KAAK,eAAe,MAAM,YAAY,GAAG;EAE/C,MAAM,SAAS,eAAe,eAAe,SAAS,GAAG;AAGzD,MAAI,eAAe,IACjB,QAAO,OAAO,eAAe,IAAI;AASnC,SAAO;GACL,WANgB,OAAO,OAAO,CAAC,OAAO,OAAO,KAAK,EAAE,OAAO,OAAO,CAAC,CAAC;GAOpE,KAJU,OAAO,YAAY;GAK7B;GACD;;AAEH,KAAI,eAAe,cAAc,QAAQ;EAEvC,MAAM,KAAK,eAAe,MAAM,YAAY,GAAG;EAE/C,MAAM,SAAoB,eAAe,qBAAqB,SAAS,IAAI,EACzE,eAAe,IAChB,CAAC;AAGF,MAAI,eAAe,IACjB,QAAO,OAAO,eAAe,IAAI;AASnC,SAAO;GACL,WANgB,OAAO,OAAO,CAAC,OAAO,OAAO,KAAK,EAAE,OAAO,OAAO,CAAC,CAAC;GAOpE,KAJU,OAAO,YAAY;GAK7B;GACD;;AAGH,OAAM,IAAI,IAAI,wCACZ,qCAAqC,eAAe,UAAU,IAC9D,OACD"}