import { performSign } from "./sign.mjs";
import { Kms } from "@credo-ts/core";
import { createCipheriv, createSecretKey, randomBytes } from "node:crypto";
import { Buffer } from "node:buffer";

//#region src/kms/crypto/encrypt.ts
const nodeSupportedEncryptionAlgorithms = [
	"A128CBC",
	"A256CBC",
	"A128CBC-HS256",
	"A192CBC-HS384",
	"A256CBC-HS512",
	"A128GCM",
	"A192GCM",
	"A256GCM",
	"C20P"
];
async function performEncrypt(key, dataEncryption, data) {
	const secretKeyBytes = Buffer.from(key.k, "base64url");
	const nodeKey = createSecretKey(secretKeyBytes);
	if (dataEncryption.algorithm === "A128CBC" || dataEncryption.algorithm === "A256CBC") {
		const nodeAlgorithm = dataEncryption.algorithm === "A128CBC" ? "aes-128-cbc" : "aes-256-cbc";
		const iv = dataEncryption.iv ?? randomBytes(16);
		const cipher = createCipheriv(nodeAlgorithm, nodeKey, iv);
		return {
			encrypted: Buffer.concat([cipher.update(data), cipher.final()]),
			iv
		};
	}
	if (dataEncryption.algorithm === "A128CBC-HS256" || dataEncryption.algorithm === "A192CBC-HS384" || dataEncryption.algorithm === "A256CBC-HS512") {
		const algSettings = {
			"A128CBC-HS256": {
				cbcAlg: "aes-128-cbc",
				hmacAlg: "HS256",
				keySize: 16
			},
			"A192CBC-HS384": {
				cbcAlg: "aes-192-cbc",
				hmacAlg: "HS384",
				keySize: 24
			},
			"A256CBC-HS512": {
				cbcAlg: "aes-256-cbc",
				hmacAlg: "HS512",
				keySize: 32
			}
		}[dataEncryption.algorithm];
		const iv = dataEncryption.iv ?? randomBytes(16);
		const macKey = secretKeyBytes.subarray(0, algSettings.keySize);
		const encKey = createSecretKey(secretKeyBytes.subarray(algSettings.keySize));
		const cipher = createCipheriv(algSettings.cbcAlg, encKey, iv);
		const encrypted = Buffer.concat([cipher.update(data), cipher.final()]);
		const al = Buffer.alloc(8);
		const aadLength = dataEncryption.aad ? dataEncryption.aad.length * 8 : 0;
		al.writeBigUInt64BE(BigInt(aadLength));
		const macData = Buffer.concat([
			dataEncryption.aad ?? Buffer.alloc(0),
			iv,
			encrypted,
			al
		]);
		const hmac = await performSign({
			kty: "oct",
			k: macKey.toString("base64url")
		}, algSettings.hmacAlg, macData);
		return {
			encrypted,
			tag: Buffer.from(hmac).subarray(0, algSettings.keySize),
			iv
		};
	}
	if (dataEncryption.algorithm === "A128GCM" || dataEncryption.algorithm === "A192GCM" || dataEncryption.algorithm === "A256GCM") {
		const nodeAlgorithm = dataEncryption.algorithm === "A128GCM" ? "aes-128-gcm" : dataEncryption.algorithm === "A192GCM" ? "aes-192-gcm" : "aes-256-gcm";
		const iv = dataEncryption.iv ?? randomBytes(12);
		const cipher = createCipheriv(nodeAlgorithm, nodeKey, iv);
		if (dataEncryption.aad) cipher.setAAD(dataEncryption.aad);
		return {
			encrypted: Buffer.concat([cipher.update(data), cipher.final()]),
			tag: cipher.getAuthTag(),
			iv
		};
	}
	if (dataEncryption.algorithm === "C20P") {
		const iv = dataEncryption.iv ?? randomBytes(12);
		const cipher = createCipheriv("chacha20-poly1305", nodeKey, iv, { authTagLength: 16 });
		if (dataEncryption.aad) cipher.setAAD(dataEncryption.aad);
		return {
			encrypted: Buffer.concat([cipher.update(data), cipher.final()]),
			tag: cipher.getAuthTag(),
			iv
		};
	}
	throw new Kms.KeyManagementAlgorithmNotSupportedError(`JWA content encryption algorithm '${dataEncryption.algorithm}'`, "node");
}

//#endregion
export { nodeSupportedEncryptionAlgorithms, performEncrypt };
//# sourceMappingURL=encrypt.mjs.map