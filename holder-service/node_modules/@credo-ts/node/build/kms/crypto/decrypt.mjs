import { performSign } from "./sign.mjs";
import { Kms } from "@credo-ts/core";
import { createDecipheriv, createSecretKey, timingSafeEqual } from "node:crypto";
import { Buffer } from "node:buffer";

//#region src/kms/crypto/decrypt.ts
async function performDecrypt(key, dataDecryption, encrypted) {
	const secretKeyBytes = Buffer.from(key.k, "base64url");
	const nodeKey = createSecretKey(secretKeyBytes);
	if (dataDecryption.algorithm === "A128CBC" || dataDecryption.algorithm === "A256CBC") {
		const decipher = createDecipheriv(dataDecryption.algorithm === "A128CBC" ? "aes-128-cbc" : "aes-256-cbc", nodeKey, dataDecryption.iv);
		return { data: Buffer.concat([decipher.update(encrypted), decipher.final()]) };
	}
	if (dataDecryption.algorithm === "A128GCM" || dataDecryption.algorithm === "A192GCM" || dataDecryption.algorithm === "A256GCM") {
		const decipher = createDecipheriv(dataDecryption.algorithm === "A128GCM" ? "aes-128-gcm" : dataDecryption.algorithm === "A192GCM" ? "aes-192-gcm" : "aes-256-gcm", nodeKey, dataDecryption.iv);
		decipher.setAuthTag(dataDecryption.tag);
		if (dataDecryption.aad) decipher.setAAD(dataDecryption.aad);
		return { data: Buffer.concat([decipher.update(encrypted), decipher.final()]) };
	}
	if (dataDecryption.algorithm === "A128CBC-HS256" || dataDecryption.algorithm === "A192CBC-HS384" || dataDecryption.algorithm === "A256CBC-HS512") {
		const algSettings = {
			"A128CBC-HS256": {
				cbcAlg: "aes-128-cbc",
				hmacAlg: "HS256",
				keySize: 16
			},
			"A192CBC-HS384": {
				cbcAlg: "aes-192-cbc",
				hmacAlg: "HS384",
				keySize: 24
			},
			"A256CBC-HS512": {
				cbcAlg: "aes-256-cbc",
				hmacAlg: "HS512",
				keySize: 32
			}
		}[dataDecryption.algorithm];
		const macKey = secretKeyBytes.subarray(0, algSettings.keySize);
		const encKey = createSecretKey(secretKeyBytes.subarray(algSettings.keySize));
		const al = Buffer.alloc(8);
		const aadLength = dataDecryption.aad ? dataDecryption.aad.length * 8 : 0;
		al.writeBigUInt64BE(BigInt(aadLength));
		const macData = Buffer.concat([
			dataDecryption.aad ?? Buffer.alloc(0),
			dataDecryption.iv,
			encrypted,
			al
		]);
		const hmac = await performSign({
			kty: "oct",
			k: macKey.toString("base64url")
		}, algSettings.hmacAlg, macData);
		if (!timingSafeEqual(Buffer.from(hmac).subarray(0, algSettings.keySize), dataDecryption.tag)) throw new Kms.KeyManagementError(`Error during verification of authentication tag with decryption algorithm '${dataDecryption.algorithm}'`);
		const decipher = createDecipheriv(algSettings.cbcAlg, encKey, dataDecryption.iv);
		return { data: Buffer.concat([decipher.update(encrypted), decipher.final()]) };
	}
	if (dataDecryption.algorithm === "C20P") {
		const decipher = createDecipheriv("chacha20-poly1305", nodeKey, dataDecryption.iv, { authTagLength: 16 });
		decipher.setAuthTag(dataDecryption.tag);
		if (dataDecryption.aad) decipher.setAAD(dataDecryption.aad);
		return { data: Buffer.concat([decipher.update(encrypted), decipher.final()]) };
	}
	throw new Kms.KeyManagementAlgorithmNotSupportedError(`JWA content decryption algorithm '${dataDecryption.algorithm}'`, "node");
}

//#endregion
export { performDecrypt };
//# sourceMappingURL=decrypt.mjs.map