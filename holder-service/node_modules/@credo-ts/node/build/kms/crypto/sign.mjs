import { Kms, TypedArrayEncoder } from "@credo-ts/core";
import { constants, createHmac, createPrivateKey, createSecretKey, sign } from "node:crypto";
import { promisify } from "node:util";

//#region src/kms/crypto/sign.ts
const sign$1 = promisify(sign);
function performSign(key, algorithm, data) {
	const nodeAlgorithm = mapJwaSignatureAlgorithmToNode(algorithm);
	const nodeKey = key.kty === "oct" ? createSecretKey(TypedArrayEncoder.fromBase64(key.k)) : createPrivateKey({
		format: "jwk",
		key
	});
	switch (key.kty) {
		case "RSA":
		case "OKP": return sign$1(nodeAlgorithm, data, algorithm.startsWith("PS") ? {
			key: nodeKey,
			padding: constants.RSA_PKCS1_PSS_PADDING,
			saltLength: Number.parseInt(algorithm.slice(2), 10) / 8
		} : nodeKey);
		case "EC": return sign$1(nodeAlgorithm, data, nodeKey).then((derSignature) => Kms.derEcSignatureToRaw(derSignature, key.crv));
		case "oct": return createHmac(nodeAlgorithm, nodeKey).update(data).digest();
		default: throw new Kms.KeyManagementAlgorithmNotSupportedError(`kty '${key.kty}'`, "node");
	}
}
const nodeSupportedJwaAlgorithm = [
	"RS256",
	"PS256",
	"HS256",
	"ES256",
	"ES256K",
	"RS384",
	"PS384",
	"HS384",
	"ES384",
	"RS512",
	"PS512",
	"HS512",
	"ES512",
	"EdDSA",
	"Ed25519"
];
function mapJwaSignatureAlgorithmToNode(algorithm) {
	switch (algorithm) {
		case "RS256":
		case "PS256":
		case "HS256":
		case "ES256":
		case "ES256K": return "sha256";
		case "RS384":
		case "PS384":
		case "HS384":
		case "ES384": return "sha384";
		case "RS512":
		case "PS512":
		case "HS512":
		case "ES512": return "sha512";
		case "EdDSA":
		case "Ed25519": return;
		default: throw new Kms.KeyManagementAlgorithmNotSupportedError(`JWA algorithm '${algorithm}'`, "node");
	}
}

//#endregion
export { mapJwaSignatureAlgorithmToNode, nodeSupportedJwaAlgorithm, performSign };
//# sourceMappingURL=sign.mjs.map