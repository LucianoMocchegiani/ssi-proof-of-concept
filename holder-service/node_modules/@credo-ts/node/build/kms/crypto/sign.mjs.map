{"version":3,"file":"sign.mjs","names":["sign","_sign"],"sources":["../../../src/kms/crypto/sign.ts"],"sourcesContent":["import { sign as _sign, constants, createHmac, createPrivateKey, createSecretKey } from 'node:crypto'\nimport { promisify } from 'node:util'\nimport type { AnyUint8Array, CanBePromise, Uint8ArrayBuffer } from '@credo-ts/core'\nimport { Kms, TypedArrayEncoder } from '@credo-ts/core'\n\nconst sign = promisify(_sign)\n\nexport function performSign(\n  key: Kms.KmsJwkPrivate,\n  algorithm: Kms.KnownJwaSignatureAlgorithm,\n  data: AnyUint8Array\n): CanBePromise<Uint8ArrayBuffer> {\n  const nodeAlgorithm = mapJwaSignatureAlgorithmToNode(algorithm)\n  const nodeKey =\n    key.kty === 'oct' ? createSecretKey(TypedArrayEncoder.fromBase64(key.k)) : createPrivateKey({ format: 'jwk', key })\n\n  switch (key.kty) {\n    case 'RSA':\n    case 'OKP': {\n      const nodeKeyInput = algorithm.startsWith('PS')\n        ? // For RSA-PSS, we need to set padding\n          {\n            key: nodeKey,\n            padding: constants.RSA_PKCS1_PSS_PADDING,\n            saltLength: Number.parseInt(algorithm.slice(2), 10) / 8,\n          }\n        : nodeKey\n\n      return sign(nodeAlgorithm, data, nodeKeyInput) as Promise<Uint8ArrayBuffer>\n    }\n    case 'EC': {\n      // Node returns EC signatures as DER encoded, but we need raw\n      return sign(nodeAlgorithm, data, nodeKey).then((derSignature) =>\n        Kms.derEcSignatureToRaw(derSignature, key.crv)\n      ) as Promise<Uint8ArrayBuffer>\n    }\n    case 'oct': {\n      return createHmac(nodeAlgorithm as string, nodeKey)\n        .update(data)\n        .digest() as Uint8ArrayBuffer\n    }\n    default:\n      // @ts-expect-error\n      throw new Kms.KeyManagementAlgorithmNotSupportedError(`kty '${key.kty}'`, 'node')\n  }\n}\n\nexport const nodeSupportedJwaAlgorithm = [\n  'RS256',\n  'PS256',\n  'HS256',\n  'ES256',\n  'ES256K',\n  'RS384',\n  'PS384',\n  'HS384',\n  'ES384',\n  'RS512',\n  'PS512',\n  'HS512',\n  'ES512',\n  'EdDSA',\n  'Ed25519',\n] as const satisfies Kms.KnownJwaSignatureAlgorithm[]\n\nexport function mapJwaSignatureAlgorithmToNode(algorithm: Kms.KnownJwaSignatureAlgorithm) {\n  switch (algorithm) {\n    case 'RS256':\n    case 'PS256':\n    case 'HS256':\n    case 'ES256':\n    case 'ES256K':\n      return 'sha256'\n    case 'RS384':\n    case 'PS384':\n    case 'HS384':\n    case 'ES384':\n      return 'sha384'\n    case 'RS512':\n    case 'PS512':\n    case 'HS512':\n    case 'ES512':\n      return 'sha512'\n    // For EdDSA it's derived based on the key\n    case 'EdDSA':\n    case 'Ed25519':\n      return undefined\n    default:\n      throw new Kms.KeyManagementAlgorithmNotSupportedError(`JWA algorithm '${algorithm}'`, 'node')\n  }\n}\n"],"mappings":";;;;;AAKA,MAAMA,SAAO,UAAUC,KAAM;AAE7B,SAAgB,YACd,KACA,WACA,MACgC;CAChC,MAAM,gBAAgB,+BAA+B,UAAU;CAC/D,MAAM,UACJ,IAAI,QAAQ,QAAQ,gBAAgB,kBAAkB,WAAW,IAAI,EAAE,CAAC,GAAG,iBAAiB;EAAE,QAAQ;EAAO;EAAK,CAAC;AAErH,SAAQ,IAAI,KAAZ;EACE,KAAK;EACL,KAAK,MAUH,QAAOD,OAAK,eAAe,MATN,UAAU,WAAW,KAAK,GAE3C;GACE,KAAK;GACL,SAAS,UAAU;GACnB,YAAY,OAAO,SAAS,UAAU,MAAM,EAAE,EAAE,GAAG,GAAG;GACvD,GACD,QAE0C;EAEhD,KAAK,KAEH,QAAOA,OAAK,eAAe,MAAM,QAAQ,CAAC,MAAM,iBAC9C,IAAI,oBAAoB,cAAc,IAAI,IAAI,CAC/C;EAEH,KAAK,MACH,QAAO,WAAW,eAAyB,QAAQ,CAChD,OAAO,KAAK,CACZ,QAAQ;EAEb,QAEE,OAAM,IAAI,IAAI,wCAAwC,QAAQ,IAAI,IAAI,IAAI,OAAO;;;AAIvF,MAAa,4BAA4B;CACvC;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACD;AAED,SAAgB,+BAA+B,WAA2C;AACxF,SAAQ,WAAR;EACE,KAAK;EACL,KAAK;EACL,KAAK;EACL,KAAK;EACL,KAAK,SACH,QAAO;EACT,KAAK;EACL,KAAK;EACL,KAAK;EACL,KAAK,QACH,QAAO;EACT,KAAK;EACL,KAAK;EACL,KAAK;EACL,KAAK,QACH,QAAO;EAET,KAAK;EACL,KAAK,UACH;EACF,QACE,OAAM,IAAI,IAAI,wCAAwC,kBAAkB,UAAU,IAAI,OAAO"}