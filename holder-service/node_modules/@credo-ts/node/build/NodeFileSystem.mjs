import { CredoError, TypedArrayEncoder } from "@credo-ts/core";
import { createHash } from "crypto";
import fs, { promises } from "fs";
import http from "http";
import https from "https";
import { homedir, tmpdir } from "os";
import { dirname } from "path";

//#region src/NodeFileSystem.ts
const { access, readFile, writeFile, mkdir, rm, unlink, copyFile } = promises;
var NodeFileSystem = class {
	/**
	* Create new NodeFileSystem class instance.
	*
	* @param baseDataPath The base path to use for reading and writing data files used within the framework.
	* Files will be created under baseDataPath/.afj directory. If not specified, it will be set to homedir()
	* @param baseCachePath The base path to use for reading and writing cache files used within the framework.
	* Files will be created under baseCachePath/.afj directory. If not specified, it will be set to homedir()
	* @param baseTempPath The base path to use for reading and writing temporary files within the framework.
	* Files will be created under baseTempPath/.afj directory. If not specified, it will be set to tmpdir()
	*/
	constructor(options) {
		this.dataPath = options?.baseDataPath ? `${options?.baseDataPath}/.afj` : `${homedir()}/.afj/data`;
		this.cachePath = options?.baseCachePath ? `${options?.baseCachePath}/.afj` : `${homedir()}/.afj/cache`;
		this.tempPath = `${options?.baseTempPath ?? tmpdir()}/.afj`;
	}
	async exists(path) {
		try {
			await access(path);
			return true;
		} catch {
			return false;
		}
	}
	async createDirectory(path) {
		await mkdir(dirname(path), { recursive: true });
	}
	async copyFile(sourcePath, destinationPath) {
		await copyFile(sourcePath, destinationPath);
	}
	async write(path, data) {
		await mkdir(dirname(path), { recursive: true });
		return writeFile(path, data, { encoding: "utf-8" });
	}
	async read(path) {
		return readFile(path, { encoding: "utf-8" });
	}
	async delete(path) {
		await rm(path, {
			recursive: true,
			force: true
		});
	}
	async downloadToFile(url, path, options) {
		const httpMethod = url.startsWith("https") ? https : http;
		await mkdir(dirname(path), { recursive: true });
		const file = fs.createWriteStream(path);
		const hash = options.verifyHash ? createHash("sha256") : void 0;
		return new Promise((resolve, reject) => {
			httpMethod.get(url, (response) => {
				if (response.statusCode !== 200) reject(`Unable to download file from url: ${url}. Response status was ${response.statusCode}`);
				hash && response.pipe(hash);
				response.pipe(file);
				file.on("finish", async () => {
					file.close();
					if (hash && options.verifyHash?.hash) {
						hash.end();
						const digest = hash.digest();
						if (digest.compare(options.verifyHash.hash) !== 0) {
							await fs.promises.unlink(path);
							reject(new CredoError(`Hash of downloaded file does not match expected hash. Expected: ${options.verifyHash.hash}, Actual: ${TypedArrayEncoder.toUtf8String(digest)})}`));
						}
					}
					resolve();
				});
			}).on("error", async (error) => {
				await unlink(path);
				reject(`Unable to download file from url: ${url}. ${error.message}`);
			});
		});
	}
};

//#endregion
export { NodeFileSystem };
//# sourceMappingURL=NodeFileSystem.mjs.map