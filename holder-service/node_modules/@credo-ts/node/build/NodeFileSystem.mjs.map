{"version":3,"file":"NodeFileSystem.mjs","names":[],"sources":["../src/NodeFileSystem.ts"],"sourcesContent":["import type { DownloadToFileOptions, FileSystem } from '@credo-ts/core'\nimport { CredoError, TypedArrayEncoder } from '@credo-ts/core'\nimport { createHash } from 'crypto'\nimport fs, { promises } from 'fs'\nimport http from 'http'\nimport https from 'https'\nimport { homedir, tmpdir } from 'os'\nimport { dirname } from 'path'\n\nconst { access, readFile, writeFile, mkdir, rm, unlink, copyFile } = promises\n\nexport class NodeFileSystem implements FileSystem {\n  public readonly dataPath\n  public readonly cachePath\n  public readonly tempPath\n\n  /**\n   * Create new NodeFileSystem class instance.\n   *\n   * @param baseDataPath The base path to use for reading and writing data files used within the framework.\n   * Files will be created under baseDataPath/.afj directory. If not specified, it will be set to homedir()\n   * @param baseCachePath The base path to use for reading and writing cache files used within the framework.\n   * Files will be created under baseCachePath/.afj directory. If not specified, it will be set to homedir()\n   * @param baseTempPath The base path to use for reading and writing temporary files within the framework.\n   * Files will be created under baseTempPath/.afj directory. If not specified, it will be set to tmpdir()\n   */\n  public constructor(options?: { baseDataPath?: string; baseCachePath?: string; baseTempPath?: string }) {\n    this.dataPath = options?.baseDataPath ? `${options?.baseDataPath}/.afj` : `${homedir()}/.afj/data`\n    this.cachePath = options?.baseCachePath ? `${options?.baseCachePath}/.afj` : `${homedir()}/.afj/cache`\n    this.tempPath = `${options?.baseTempPath ?? tmpdir()}/.afj`\n  }\n\n  public async exists(path: string) {\n    try {\n      await access(path)\n      return true\n    } catch {\n      return false\n    }\n  }\n\n  public async createDirectory(path: string): Promise<void> {\n    await mkdir(dirname(path), { recursive: true })\n  }\n\n  public async copyFile(sourcePath: string, destinationPath: string): Promise<void> {\n    await copyFile(sourcePath, destinationPath)\n  }\n\n  public async write(path: string, data: string): Promise<void> {\n    // Make sure parent directories exist\n    await mkdir(dirname(path), { recursive: true })\n\n    return writeFile(path, data, { encoding: 'utf-8' })\n  }\n\n  public async read(path: string): Promise<string> {\n    return readFile(path, { encoding: 'utf-8' })\n  }\n\n  public async delete(path: string): Promise<void> {\n    await rm(path, { recursive: true, force: true })\n  }\n\n  public async downloadToFile(url: string, path: string, options: DownloadToFileOptions) {\n    const httpMethod = url.startsWith('https') ? https : http\n\n    // Make sure parent directories exist\n    await mkdir(dirname(path), { recursive: true })\n\n    const file = fs.createWriteStream(path)\n    const hash = options.verifyHash ? createHash('sha256') : undefined\n\n    return new Promise<void>((resolve, reject) => {\n      httpMethod\n        .get(url, (response) => {\n          // check if response is success\n          if (response.statusCode !== 200) {\n            reject(`Unable to download file from url: ${url}. Response status was ${response.statusCode}`)\n          }\n\n          hash && response.pipe(hash)\n          response.pipe(file)\n          file.on('finish', async () => {\n            file.close()\n\n            if (hash && options.verifyHash?.hash) {\n              hash.end()\n              const digest = hash.digest()\n              if (digest.compare(options.verifyHash.hash) !== 0) {\n                await fs.promises.unlink(path)\n\n                reject(\n                  new CredoError(\n                    `Hash of downloaded file does not match expected hash. Expected: ${\n                      options.verifyHash.hash\n                    }, Actual: ${TypedArrayEncoder.toUtf8String(digest)})}`\n                  )\n                )\n              }\n            }\n            resolve()\n          })\n        })\n        .on('error', async (error) => {\n          // Handle errors\n          await unlink(path) // Delete the file async. (But we don't check the result)\n          reject(`Unable to download file from url: ${url}. ${error.message}`)\n        })\n    })\n  }\n}\n"],"mappings":";;;;;;;;;AASA,MAAM,EAAE,QAAQ,UAAU,WAAW,OAAO,IAAI,QAAQ,aAAa;AAErE,IAAa,iBAAb,MAAkD;;;;;;;;;;;CAehD,AAAO,YAAY,SAAoF;AACrG,OAAK,WAAW,SAAS,eAAe,GAAG,SAAS,aAAa,SAAS,GAAG,SAAS,CAAC;AACvF,OAAK,YAAY,SAAS,gBAAgB,GAAG,SAAS,cAAc,SAAS,GAAG,SAAS,CAAC;AAC1F,OAAK,WAAW,GAAG,SAAS,gBAAgB,QAAQ,CAAC;;CAGvD,MAAa,OAAO,MAAc;AAChC,MAAI;AACF,SAAM,OAAO,KAAK;AAClB,UAAO;UACD;AACN,UAAO;;;CAIX,MAAa,gBAAgB,MAA6B;AACxD,QAAM,MAAM,QAAQ,KAAK,EAAE,EAAE,WAAW,MAAM,CAAC;;CAGjD,MAAa,SAAS,YAAoB,iBAAwC;AAChF,QAAM,SAAS,YAAY,gBAAgB;;CAG7C,MAAa,MAAM,MAAc,MAA6B;AAE5D,QAAM,MAAM,QAAQ,KAAK,EAAE,EAAE,WAAW,MAAM,CAAC;AAE/C,SAAO,UAAU,MAAM,MAAM,EAAE,UAAU,SAAS,CAAC;;CAGrD,MAAa,KAAK,MAA+B;AAC/C,SAAO,SAAS,MAAM,EAAE,UAAU,SAAS,CAAC;;CAG9C,MAAa,OAAO,MAA6B;AAC/C,QAAM,GAAG,MAAM;GAAE,WAAW;GAAM,OAAO;GAAM,CAAC;;CAGlD,MAAa,eAAe,KAAa,MAAc,SAAgC;EACrF,MAAM,aAAa,IAAI,WAAW,QAAQ,GAAG,QAAQ;AAGrD,QAAM,MAAM,QAAQ,KAAK,EAAE,EAAE,WAAW,MAAM,CAAC;EAE/C,MAAM,OAAO,GAAG,kBAAkB,KAAK;EACvC,MAAM,OAAO,QAAQ,aAAa,WAAW,SAAS,GAAG;AAEzD,SAAO,IAAI,SAAe,SAAS,WAAW;AAC5C,cACG,IAAI,MAAM,aAAa;AAEtB,QAAI,SAAS,eAAe,IAC1B,QAAO,qCAAqC,IAAI,wBAAwB,SAAS,aAAa;AAGhG,YAAQ,SAAS,KAAK,KAAK;AAC3B,aAAS,KAAK,KAAK;AACnB,SAAK,GAAG,UAAU,YAAY;AAC5B,UAAK,OAAO;AAEZ,SAAI,QAAQ,QAAQ,YAAY,MAAM;AACpC,WAAK,KAAK;MACV,MAAM,SAAS,KAAK,QAAQ;AAC5B,UAAI,OAAO,QAAQ,QAAQ,WAAW,KAAK,KAAK,GAAG;AACjD,aAAM,GAAG,SAAS,OAAO,KAAK;AAE9B,cACE,IAAI,WACF,mEACE,QAAQ,WAAW,KACpB,YAAY,kBAAkB,aAAa,OAAO,CAAC,IACrD,CACF;;;AAGL,cAAS;MACT;KACF,CACD,GAAG,SAAS,OAAO,UAAU;AAE5B,UAAM,OAAO,KAAK;AAClB,WAAO,qCAAqC,IAAI,IAAI,MAAM,UAAU;KACpE;IACJ"}