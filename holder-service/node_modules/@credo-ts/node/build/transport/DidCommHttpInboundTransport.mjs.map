{"version":3,"file":"DidCommHttpInboundTransport.mjs","names":[],"sources":["../../src/transport/DidCommHttpInboundTransport.ts"],"sourcesContent":["import type { AgentContext } from '@credo-ts/core'\nimport { CredoError, EventEmitter, utils } from '@credo-ts/core'\nimport type {\n  DidCommEncryptedMessage,\n  DidCommInboundTransport,\n  DidCommMessageProcessedEvent,\n  DidCommMessageReceivedEvent,\n  DidCommTransportSession,\n} from '@credo-ts/didcomm'\nimport { DidCommEventTypes, DidCommMimeType, DidCommModuleConfig, DidCommTransportService } from '@credo-ts/didcomm'\nimport type { Express, Request, Response } from 'express'\nimport express, { text } from 'express'\nimport type { Server } from 'http'\nimport { filter, firstValueFrom, ReplaySubject, take, timeout } from 'rxjs'\n\nconst supportedContentTypes: string[] = [DidCommMimeType.V0, DidCommMimeType.V1]\n\nexport class DidCommHttpInboundTransport implements DidCommInboundTransport {\n  public readonly app: Express\n  private port: number\n  private path: string\n  private _server?: Server\n  private processedMessageListenerTimeoutMs: number\n\n  public get server() {\n    return this._server\n  }\n\n  public constructor({\n    app,\n    path,\n    port,\n    processedMessageListenerTimeoutMs,\n  }: {\n    app?: Express\n    path?: string\n    port: number\n    processedMessageListenerTimeoutMs?: number\n  }) {\n    this.port = port\n    this.processedMessageListenerTimeoutMs = processedMessageListenerTimeoutMs ?? 10000 // timeout after 10 seconds\n\n    // Create Express App\n    this.app = app ?? express()\n    this.path = path ?? '/'\n\n    this.app.use(text({ type: supportedContentTypes, limit: '5mb' }))\n  }\n\n  public async start(agentContext: AgentContext) {\n    const transportService = agentContext.dependencyManager.resolve(DidCommTransportService)\n\n    agentContext.config.logger.debug('Starting HTTP inbound transport', {\n      port: this.port,\n    })\n\n    this.app.post(this.path, async (req, res) => {\n      const contentType = req.headers['content-type']\n\n      if (!contentType || !supportedContentTypes.includes(contentType)) {\n        return res\n          .status(415)\n          .send(`Unsupported content-type. Supported content-types are: ${supportedContentTypes.join(', ')}`)\n      }\n\n      const session = new HttpTransportSession(utils.uuid(), req, res)\n      // We want to make sure the session is removed if the connection is closed, as it\n      // can't be used anymore then. This could happen if the client abruptly closes the connection.\n      req.once('close', () => transportService.removeSession(session))\n\n      try {\n        const message = req.body\n        const encryptedMessage = JSON.parse(message) as DidCommEncryptedMessage\n\n        const eventEmitter = agentContext.dependencyManager.resolve(EventEmitter)\n        const observable = eventEmitter.observable<DidCommMessageProcessedEvent>(\n          DidCommEventTypes.DidCommMessageProcessed\n        )\n        const subject = new ReplaySubject(1)\n\n        observable\n          .pipe(\n            filter((e) => e.type === DidCommEventTypes.DidCommMessageProcessed),\n            filter((e) => e.payload.encryptedMessage === encryptedMessage),\n            timeout({\n              first: this.processedMessageListenerTimeoutMs,\n              meta: 'DidCommHttpInboundTransport.start',\n            }),\n            take(1) // automatically unsubscribe after the first matching event\n          )\n          .subscribe(subject)\n\n        eventEmitter.emit<DidCommMessageReceivedEvent>(agentContext, {\n          type: DidCommEventTypes.DidCommMessageReceived,\n          payload: {\n            message: encryptedMessage,\n            session: session,\n          },\n        })\n\n        // Wait for message to be processed\n        await firstValueFrom(subject)\n\n        // If agent did not use session when processing message we need to send response here.\n        if (!res.headersSent) {\n          res.status(200).end()\n        }\n      } catch (error) {\n        agentContext.config.logger.error(`Error processing inbound message: ${error.message}`, error)\n\n        if (!res.headersSent) {\n          res.status(500).send('Error processing message')\n        }\n      } finally {\n        transportService.removeSession(session)\n      }\n    })\n\n    this._server = this.app.listen(this.port)\n  }\n\n  public async stop(): Promise<void> {\n    return new Promise((resolve, reject) => this._server?.close((err) => (err ? reject(err) : resolve())))\n  }\n}\n\nexport class HttpTransportSession implements DidCommTransportSession {\n  public id: string\n  public readonly type = 'http'\n  public req: Request\n  public res: Response\n\n  public constructor(id: string, req: Request, res: Response) {\n    this.id = id\n    this.req = req\n    this.res = res\n  }\n\n  public async close(): Promise<void> {\n    if (!this.res.headersSent) {\n      this.res.status(200).end()\n    }\n  }\n\n  public async send(agentContext: AgentContext, encryptedMessage: DidCommEncryptedMessage): Promise<void> {\n    if (this.res.headersSent) {\n      throw new CredoError(`${this.type} transport session has been closed.`)\n    }\n\n    // By default we take the agent config's default DIDComm content-type\n    const didcommConfig = agentContext.dependencyManager.resolve(DidCommModuleConfig)\n    let responseMimeType = didcommConfig.didCommMimeType as string\n\n    // However, if the request mime-type is a mime-type that is supported by us, we use that\n    // to minimize the chance of interoperability issues\n    const requestMimeType = this.req.headers['content-type']\n    if (requestMimeType && supportedContentTypes.includes(requestMimeType)) {\n      responseMimeType = requestMimeType\n    }\n\n    this.res.status(200).contentType(responseMimeType).json(encryptedMessage).end()\n  }\n}\n"],"mappings":";;;;;;AAeA,MAAM,wBAAkC,CAAC,gBAAgB,IAAI,gBAAgB,GAAG;AAEhF,IAAa,8BAAb,MAA4E;CAO1E,IAAW,SAAS;AAClB,SAAO,KAAK;;CAGd,AAAO,YAAY,EACjB,KACA,MACA,MACA,qCAMC;AACD,OAAK,OAAO;AACZ,OAAK,oCAAoC,qCAAqC;AAG9E,OAAK,MAAM,OAAO,SAAS;AAC3B,OAAK,OAAO,QAAQ;AAEpB,OAAK,IAAI,IAAI,KAAK;GAAE,MAAM;GAAuB,OAAO;GAAO,CAAC,CAAC;;CAGnE,MAAa,MAAM,cAA4B;EAC7C,MAAM,mBAAmB,aAAa,kBAAkB,QAAQ,wBAAwB;AAExF,eAAa,OAAO,OAAO,MAAM,mCAAmC,EAClE,MAAM,KAAK,MACZ,CAAC;AAEF,OAAK,IAAI,KAAK,KAAK,MAAM,OAAO,KAAK,QAAQ;GAC3C,MAAM,cAAc,IAAI,QAAQ;AAEhC,OAAI,CAAC,eAAe,CAAC,sBAAsB,SAAS,YAAY,CAC9D,QAAO,IACJ,OAAO,IAAI,CACX,KAAK,0DAA0D,sBAAsB,KAAK,KAAK,GAAG;GAGvG,MAAM,UAAU,IAAI,qBAAqB,MAAM,MAAM,EAAE,KAAK,IAAI;AAGhE,OAAI,KAAK,eAAe,iBAAiB,cAAc,QAAQ,CAAC;AAEhE,OAAI;IACF,MAAM,UAAU,IAAI;IACpB,MAAM,mBAAmB,KAAK,MAAM,QAAQ;IAE5C,MAAM,eAAe,aAAa,kBAAkB,QAAQ,aAAa;IACzE,MAAM,aAAa,aAAa,WAC9B,kBAAkB,wBACnB;IACD,MAAM,UAAU,IAAI,cAAc,EAAE;AAEpC,eACG,KACC,QAAQ,MAAM,EAAE,SAAS,kBAAkB,wBAAwB,EACnE,QAAQ,MAAM,EAAE,QAAQ,qBAAqB,iBAAiB,EAC9D,QAAQ;KACN,OAAO,KAAK;KACZ,MAAM;KACP,CAAC,EACF,KAAK,EAAE,CACR,CACA,UAAU,QAAQ;AAErB,iBAAa,KAAkC,cAAc;KAC3D,MAAM,kBAAkB;KACxB,SAAS;MACP,SAAS;MACA;MACV;KACF,CAAC;AAGF,UAAM,eAAe,QAAQ;AAG7B,QAAI,CAAC,IAAI,YACP,KAAI,OAAO,IAAI,CAAC,KAAK;YAEhB,OAAO;AACd,iBAAa,OAAO,OAAO,MAAM,qCAAqC,MAAM,WAAW,MAAM;AAE7F,QAAI,CAAC,IAAI,YACP,KAAI,OAAO,IAAI,CAAC,KAAK,2BAA2B;aAE1C;AACR,qBAAiB,cAAc,QAAQ;;IAEzC;AAEF,OAAK,UAAU,KAAK,IAAI,OAAO,KAAK,KAAK;;CAG3C,MAAa,OAAsB;AACjC,SAAO,IAAI,SAAS,SAAS,WAAW,KAAK,SAAS,OAAO,QAAS,MAAM,OAAO,IAAI,GAAG,SAAS,CAAE,CAAC;;;AAI1G,IAAa,uBAAb,MAAqE;CAMnE,AAAO,YAAY,IAAY,KAAc,KAAe;OAJ5C,OAAO;AAKrB,OAAK,KAAK;AACV,OAAK,MAAM;AACX,OAAK,MAAM;;CAGb,MAAa,QAAuB;AAClC,MAAI,CAAC,KAAK,IAAI,YACZ,MAAK,IAAI,OAAO,IAAI,CAAC,KAAK;;CAI9B,MAAa,KAAK,cAA4B,kBAA0D;AACtG,MAAI,KAAK,IAAI,YACX,OAAM,IAAI,WAAW,GAAG,KAAK,KAAK,qCAAqC;EAKzE,IAAI,mBADkB,aAAa,kBAAkB,QAAQ,oBAAoB,CAC5C;EAIrC,MAAM,kBAAkB,KAAK,IAAI,QAAQ;AACzC,MAAI,mBAAmB,sBAAsB,SAAS,gBAAgB,CACpE,oBAAmB;AAGrB,OAAK,IAAI,OAAO,IAAI,CAAC,YAAY,iBAAiB,CAAC,KAAK,iBAAiB,CAAC,KAAK"}