import { CredoError, EventEmitter, utils } from "@credo-ts/core";
import { DidCommEventTypes, DidCommMimeType, DidCommModuleConfig, DidCommTransportService } from "@credo-ts/didcomm";
import express, { text } from "express";
import { ReplaySubject, filter, firstValueFrom, take, timeout } from "rxjs";

//#region src/transport/DidCommHttpInboundTransport.ts
const supportedContentTypes = [DidCommMimeType.V0, DidCommMimeType.V1];
var DidCommHttpInboundTransport = class {
	get server() {
		return this._server;
	}
	constructor({ app, path, port, processedMessageListenerTimeoutMs }) {
		this.port = port;
		this.processedMessageListenerTimeoutMs = processedMessageListenerTimeoutMs ?? 1e4;
		this.app = app ?? express();
		this.path = path ?? "/";
		this.app.use(text({
			type: supportedContentTypes,
			limit: "5mb"
		}));
	}
	async start(agentContext) {
		const transportService = agentContext.dependencyManager.resolve(DidCommTransportService);
		agentContext.config.logger.debug("Starting HTTP inbound transport", { port: this.port });
		this.app.post(this.path, async (req, res) => {
			const contentType = req.headers["content-type"];
			if (!contentType || !supportedContentTypes.includes(contentType)) return res.status(415).send(`Unsupported content-type. Supported content-types are: ${supportedContentTypes.join(", ")}`);
			const session = new HttpTransportSession(utils.uuid(), req, res);
			req.once("close", () => transportService.removeSession(session));
			try {
				const message = req.body;
				const encryptedMessage = JSON.parse(message);
				const eventEmitter = agentContext.dependencyManager.resolve(EventEmitter);
				const observable = eventEmitter.observable(DidCommEventTypes.DidCommMessageProcessed);
				const subject = new ReplaySubject(1);
				observable.pipe(filter((e) => e.type === DidCommEventTypes.DidCommMessageProcessed), filter((e) => e.payload.encryptedMessage === encryptedMessage), timeout({
					first: this.processedMessageListenerTimeoutMs,
					meta: "DidCommHttpInboundTransport.start"
				}), take(1)).subscribe(subject);
				eventEmitter.emit(agentContext, {
					type: DidCommEventTypes.DidCommMessageReceived,
					payload: {
						message: encryptedMessage,
						session
					}
				});
				await firstValueFrom(subject);
				if (!res.headersSent) res.status(200).end();
			} catch (error) {
				agentContext.config.logger.error(`Error processing inbound message: ${error.message}`, error);
				if (!res.headersSent) res.status(500).send("Error processing message");
			} finally {
				transportService.removeSession(session);
			}
		});
		this._server = this.app.listen(this.port);
	}
	async stop() {
		return new Promise((resolve, reject) => this._server?.close((err) => err ? reject(err) : resolve()));
	}
};
var HttpTransportSession = class {
	constructor(id, req, res) {
		this.type = "http";
		this.id = id;
		this.req = req;
		this.res = res;
	}
	async close() {
		if (!this.res.headersSent) this.res.status(200).end();
	}
	async send(agentContext, encryptedMessage) {
		if (this.res.headersSent) throw new CredoError(`${this.type} transport session has been closed.`);
		let responseMimeType = agentContext.dependencyManager.resolve(DidCommModuleConfig).didCommMimeType;
		const requestMimeType = this.req.headers["content-type"];
		if (requestMimeType && supportedContentTypes.includes(requestMimeType)) responseMimeType = requestMimeType;
		this.res.status(200).contentType(responseMimeType).json(encryptedMessage).end();
	}
};

//#endregion
export { DidCommHttpInboundTransport };
//# sourceMappingURL=DidCommHttpInboundTransport.mjs.map