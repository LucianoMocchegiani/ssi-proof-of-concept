import WebSocket, { WebSocketServer } from "ws";
import { CredoError, EventEmitter, utils } from "@credo-ts/core";
import { DidCommEventTypes, DidCommModuleConfig, DidCommTransportService } from "@credo-ts/didcomm";

//#region src/transport/DidCommWsInboundTransport.ts
var DidCommWsInboundTransport = class {
	constructor({ server, port }) {
		this.socketIds = {};
		this.socketServer = server ?? new WebSocketServer({ port });
	}
	async start(agentContext) {
		const transportService = agentContext.dependencyManager.resolve(DidCommTransportService);
		this.logger = agentContext.config.logger;
		const wsEndpoint = agentContext.dependencyManager.resolve(DidCommModuleConfig).endpoints.find((e) => e.startsWith("ws"));
		this.logger.debug("Starting WS inbound transport", { endpoint: wsEndpoint });
		this.socketServer.on("connection", (socket) => {
			const socketId = utils.uuid();
			this.logger.debug("Socket connected.");
			if (!this.socketIds[socketId]) {
				this.logger.debug(`Saving new socket with id ${socketId}.`);
				this.socketIds[socketId] = socket;
				const session = new WebSocketTransportSession(socketId, socket, this.logger);
				this.listenOnWebSocketMessages(agentContext, socket, session);
				socket.on("close", () => {
					this.logger.debug("Socket closed.");
					transportService.removeSession(session);
				});
			} else this.logger.debug(`Socket with id ${socketId} already exists.`);
		});
	}
	async stop() {
		this.logger.debug("Closing WebSocket Server");
		return new Promise((resolve, reject) => {
			this.socketServer.close((error) => {
				if (error) reject(error);
				resolve();
			});
		});
	}
	listenOnWebSocketMessages(agentContext, socket, session) {
		socket.addEventListener("message", async (event) => {
			this.logger.debug("WebSocket message event received.", { url: event.target.url });
			try {
				const encryptedMessage = JSON.parse(event.data);
				agentContext.dependencyManager.resolve(EventEmitter).emit(agentContext, {
					type: DidCommEventTypes.DidCommMessageReceived,
					payload: {
						message: encryptedMessage,
						session
					}
				});
			} catch (error) {
				this.logger.error(`Error processing message: ${error}`);
			}
		});
	}
};
var WebSocketTransportSession = class {
	constructor(id, socket, logger) {
		this.type = "WebSocket";
		this.id = id;
		this.socket = socket;
		this.logger = logger;
	}
	async send(_agentContext, encryptedMessage) {
		if (this.socket.readyState !== WebSocket.OPEN) throw new CredoError(`${this.type} transport session has been closed.`);
		this.socket.send(JSON.stringify(encryptedMessage), (error) => {
			if (error != void 0) {
				this.logger.debug(`Error sending message: ${error}`);
				throw new CredoError(`${this.type} send message failed.`, { cause: error });
			}
			this.logger.debug(`${this.type} sent message successfully.`);
		});
	}
	async close() {
		if (this.socket.readyState === WebSocket.OPEN) this.socket.close();
	}
};

//#endregion
export { DidCommWsInboundTransport };
//# sourceMappingURL=DidCommWsInboundTransport.mjs.map