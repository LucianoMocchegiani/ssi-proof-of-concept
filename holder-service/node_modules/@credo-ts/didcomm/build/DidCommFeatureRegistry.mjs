import { __decorate } from "./_virtual/_@oxc-project_runtime@0.110.0/helpers/decorate.mjs";
import { injectable } from "@credo-ts/core";

//#region src/DidCommFeatureRegistry.ts
let DidCommFeatureRegistry = class DidCommFeatureRegistry {
	constructor() {
		this.features = [];
	}
	/**
	* Register a single or set of Features on the registry
	*
	* @param features set of {Feature} objects or any inherited class
	*/
	register(...features) {
		for (const feature of features) {
			const index = this.features.findIndex((item) => item.type === feature.type && item.id === feature.id);
			if (index > -1) this.features[index] = this.features[index].combine(feature);
			else this.features.push(feature);
		}
	}
	/**
	* Perform a set of queries in the registry, supporting wildcards (*) as
	* expressed in Aries RFC 0557.
	*
	* @see https://github.com/hyperledger/aries-rfcs/blob/560ffd23361f16a01e34ccb7dcc908ec28c5ddb1/features/0557-discover-features-v2/README.md
	*
	* @param queries set of {FeatureQuery} objects to query features
	* @returns array containing all matching features (can be empty)
	*/
	query(...queries) {
		const output = [];
		for (const query of queries) {
			const items = this.features.filter((item) => item.type === query.featureType);
			if (query.match === "*") output.push(...items);
			else if (query.match.endsWith("*")) {
				const match = query.match.slice(0, -1);
				output.push(...items.filter((m) => m.id.startsWith(match)));
			} else output.push(...items.filter((m) => m.id === query.match));
		}
		return output;
	}
};
DidCommFeatureRegistry = __decorate([injectable()], DidCommFeatureRegistry);

//#endregion
export { DidCommFeatureRegistry };
//# sourceMappingURL=DidCommFeatureRegistry.mjs.map