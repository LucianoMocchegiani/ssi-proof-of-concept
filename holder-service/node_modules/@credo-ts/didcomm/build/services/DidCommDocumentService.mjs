import { __decorate } from "../_virtual/_@oxc-project_runtime@0.110.0/helpers/decorate.mjs";
import { __decorateMetadata } from "../_virtual/_@oxc-project_runtime@0.110.0/helpers/decorateMetadata.mjs";
import { AgentContext, CredoError, DidCommV1Service, DidRecord, DidRepository, DidResolverService, IndyAgentService, Kms, RecordNotFoundError, findMatchingEd25519Key, getPublicJwkFromVerificationMethod, injectable, parseDid, verkeyToPublicJwk } from "@credo-ts/core";

//#region src/services/DidCommDocumentService.ts
var _ref, _ref2;
let DidCommDocumentService = class DidCommDocumentService {
	constructor(didResolverService, didRepository) {
		this.didResolverService = didResolverService;
		this.didRepository = didRepository;
	}
	async resolveServicesFromDid(agentContext, did) {
		const didDocument = await this.didResolverService.resolveDidDocument(agentContext, did);
		const resolvedServices = [];
		const didCommServices = parseDid(did).fragment ? didDocument.didCommServices.filter((service) => service.id === did) : didDocument.didCommServices;
		for (const didCommService of didCommServices) if (didCommService.type === IndyAgentService.type) resolvedServices.push({
			id: didCommService.id,
			recipientKeys: didCommService.recipientKeys.map(verkeyToPublicJwk),
			routingKeys: didCommService.routingKeys?.map(verkeyToPublicJwk) || [],
			serviceEndpoint: didCommService.serviceEndpoint
		});
		else if (didCommService.type === DidCommV1Service.type) {
			const routingKeys = [];
			for (const routingKey of didCommService.routingKeys ?? []) {
				const publicJwk = getPublicJwkFromVerificationMethod((await this.didResolverService.resolveDidDocument(agentContext, routingKey)).dereferenceKey(routingKey, ["authentication", "keyAgreement"]));
				if (!publicJwk.is(Kms.Ed25519PublicJwk)) throw new CredoError(`Expected Ed25519PublicJwk but found ${publicJwk.JwkClass.name}`);
				routingKeys.push(publicJwk);
			}
			const recipientKeys = didCommService.recipientKeys.map((recipientKeyReference) => {
				const publicJwk = getPublicJwkFromVerificationMethod(didDocument.dereferenceKey(recipientKeyReference, ["authentication", "keyAgreement"]));
				if (publicJwk.is(Kms.X25519PublicJwk)) {
					const matchingEd25519Key = findMatchingEd25519Key(publicJwk, didDocument);
					if (matchingEd25519Key) return matchingEd25519Key.publicJwk;
				}
				if (!publicJwk.is(Kms.Ed25519PublicJwk)) throw new CredoError(`Expected Ed25519PublicJwk but found ${publicJwk.JwkClass.name}`);
				return publicJwk;
			});
			resolvedServices.push({
				id: didCommService.id,
				recipientKeys,
				routingKeys,
				serviceEndpoint: didCommService.serviceEndpoint
			});
		}
		return resolvedServices;
	}
	async resolveCreatedDidDocumentWithKeysByRecipientKey(agentContext, publicJwk) {
		let didRecord = await this.didRepository.findCreatedDidByRecipientKey(agentContext, publicJwk);
		if (!didRecord && publicJwk.is(Kms.Ed25519PublicJwk)) {
			const x25519PublicJwk = publicJwk.convertTo(Kms.X25519PublicJwk);
			didRecord = await this.didRepository.findCreatedDidByRecipientKey(agentContext, x25519PublicJwk);
		}
		if (!didRecord) throw new RecordNotFoundError(`Created did for public jwk ${publicJwk.jwkTypeHumanDescription} not found`, { recordType: DidRecord.type });
		if (didRecord.didDocument) return {
			keys: didRecord.keys,
			didDocument: didRecord.didDocument
		};
		const didDocument = await this.didResolverService.resolveDidDocument(agentContext, didRecord.did);
		return {
			keys: didRecord.keys,
			didDocument
		};
	}
};
DidCommDocumentService = __decorate([injectable(), __decorateMetadata("design:paramtypes", [typeof (_ref = typeof DidResolverService !== "undefined" && DidResolverService) === "function" ? _ref : Object, typeof (_ref2 = typeof DidRepository !== "undefined" && DidRepository) === "function" ? _ref2 : Object])], DidCommDocumentService);

//#endregion
export { DidCommDocumentService };
//# sourceMappingURL=DidCommDocumentService.mjs.map