{"version":3,"file":"DidCommDocumentService.mjs","names":[],"sources":["../../src/services/DidCommDocumentService.ts"],"sourcesContent":["import {\n  AgentContext,\n  CredoError,\n  DidCommV1Service,\n  DidRecord,\n  DidRepository,\n  DidResolverService,\n  findMatchingEd25519Key,\n  getPublicJwkFromVerificationMethod,\n  IndyAgentService,\n  injectable,\n  Kms,\n  parseDid,\n  RecordNotFoundError,\n  type ResolvedDidCommService,\n  verkeyToPublicJwk,\n} from '@credo-ts/core'\n\n@injectable()\nexport class DidCommDocumentService {\n  private didResolverService: DidResolverService\n  private didRepository: DidRepository\n\n  public constructor(didResolverService: DidResolverService, didRepository: DidRepository) {\n    this.didResolverService = didResolverService\n    this.didRepository = didRepository\n  }\n\n  public async resolveServicesFromDid(agentContext: AgentContext, did: string): Promise<ResolvedDidCommService[]> {\n    const didDocument = await this.didResolverService.resolveDidDocument(agentContext, did)\n\n    const resolvedServices: ResolvedDidCommService[] = []\n\n    // If did specifies a particular service, filter by its id\n    const didCommServices = parseDid(did).fragment\n      ? didDocument.didCommServices.filter((service) => service.id === did)\n      : didDocument.didCommServices\n\n    // FIXME: we currently retrieve did documents for all didcomm services in the did document, and we don't have caching\n    // yet so this will re-trigger ledger resolves for each one. Should we only resolve the first service, then the second service, etc...?\n    for (const didCommService of didCommServices) {\n      if (didCommService.type === IndyAgentService.type) {\n        // IndyAgentService (DidComm v0) has keys encoded as raw publicKeyBase58 (verkeys)\n        resolvedServices.push({\n          id: didCommService.id,\n          recipientKeys: didCommService.recipientKeys.map(verkeyToPublicJwk),\n          routingKeys: didCommService.routingKeys?.map(verkeyToPublicJwk) || [],\n          serviceEndpoint: didCommService.serviceEndpoint,\n        })\n      } else if (didCommService.type === DidCommV1Service.type) {\n        // Resolve dids to DIDDocs to retrieve routingKeys\n        const routingKeys: Kms.PublicJwk<Kms.Ed25519PublicJwk>[] = []\n        for (const routingKey of didCommService.routingKeys ?? []) {\n          const routingDidDocument = await this.didResolverService.resolveDidDocument(agentContext, routingKey)\n          const publicJwk = getPublicJwkFromVerificationMethod(\n            routingDidDocument.dereferenceKey(routingKey, ['authentication', 'keyAgreement'])\n          )\n\n          // FIXME: we should handle X25519 here as well\n          if (!publicJwk.is(Kms.Ed25519PublicJwk)) {\n            throw new CredoError(`Expected Ed25519PublicJwk but found ${publicJwk.JwkClass.name}`)\n          }\n\n          routingKeys.push(publicJwk)\n        }\n\n        // DidCommV1Service has keys encoded as key references\n\n        // Dereference recipientKeys\n        const recipientKeys = didCommService.recipientKeys.map((recipientKeyReference) => {\n          // FIXME: we allow authentication keys as historically ed25519 keys have been used in did documents\n          // for didcomm. In the future we should update this to only be allowed for IndyAgent and DidCommV1 services\n          // as didcomm v2 doesn't have this issue anymore\n          const publicJwk = getPublicJwkFromVerificationMethod(\n            didDocument.dereferenceKey(recipientKeyReference, ['authentication', 'keyAgreement'])\n          )\n\n          // try to find a matching Ed25519 key (https://sovrin-foundation.github.io/sovrin/spec/did-method-spec-template.html#did-document-notes)\n          // FIXME: Now that indy-sdk is deprecated, we should look into the possiblty of using the X25519 key directly\n          // removing the need to also include the Ed25519 key in the did document.\n          if (publicJwk.is(Kms.X25519PublicJwk)) {\n            const matchingEd25519Key = findMatchingEd25519Key(publicJwk, didDocument)\n            if (matchingEd25519Key) return matchingEd25519Key.publicJwk\n          }\n\n          if (!publicJwk.is(Kms.Ed25519PublicJwk)) {\n            throw new CredoError(`Expected Ed25519PublicJwk but found ${publicJwk.JwkClass.name}`)\n          }\n\n          return publicJwk\n        })\n\n        resolvedServices.push({\n          id: didCommService.id,\n          recipientKeys,\n          routingKeys,\n          serviceEndpoint: didCommService.serviceEndpoint,\n        })\n      }\n    }\n\n    return resolvedServices\n  }\n\n  public async resolveCreatedDidDocumentWithKeysByRecipientKey(agentContext: AgentContext, publicJwk: Kms.PublicJwk) {\n    let didRecord = await this.didRepository.findCreatedDidByRecipientKey(agentContext, publicJwk)\n\n    // DIDComm v1 messages are sent with the Ed25519 key. However a did document may contain the X25519 key\n    // In that case we transform it to an X25519 key\n    if (!didRecord && publicJwk.is(Kms.Ed25519PublicJwk)) {\n      const x25519PublicJwk = publicJwk.convertTo(Kms.X25519PublicJwk)\n      didRecord = await this.didRepository.findCreatedDidByRecipientKey(agentContext, x25519PublicJwk)\n    }\n\n    if (!didRecord) {\n      throw new RecordNotFoundError(`Created did for public jwk ${publicJwk.jwkTypeHumanDescription} not found`, {\n        recordType: DidRecord.type,\n      })\n    }\n\n    if (didRecord.didDocument) {\n      return {\n        keys: didRecord.keys,\n        didDocument: didRecord.didDocument,\n      }\n    }\n\n    // TODO: we should somehow store the did document on the record if the did method allows it\n    // E.g. for did:key we don't want to store it, but if we still have a did:indy record we do want to store it\n    // If the did document is not stored on the did record, we resolve it\n    const didDocument = await this.didResolverService.resolveDidDocument(agentContext, didRecord.did)\n\n    return {\n      keys: didRecord.keys,\n      didDocument,\n    }\n  }\n}\n"],"mappings":";;;;;;AAmBO,mCAAM,uBAAuB;CAIlC,AAAO,YAAY,oBAAwC,eAA8B;AACvF,OAAK,qBAAqB;AAC1B,OAAK,gBAAgB;;CAGvB,MAAa,uBAAuB,cAA4B,KAAgD;EAC9G,MAAM,cAAc,MAAM,KAAK,mBAAmB,mBAAmB,cAAc,IAAI;EAEvF,MAAM,mBAA6C,EAAE;EAGrD,MAAM,kBAAkB,SAAS,IAAI,CAAC,WAClC,YAAY,gBAAgB,QAAQ,YAAY,QAAQ,OAAO,IAAI,GACnE,YAAY;AAIhB,OAAK,MAAM,kBAAkB,gBAC3B,KAAI,eAAe,SAAS,iBAAiB,KAE3C,kBAAiB,KAAK;GACpB,IAAI,eAAe;GACnB,eAAe,eAAe,cAAc,IAAI,kBAAkB;GAClE,aAAa,eAAe,aAAa,IAAI,kBAAkB,IAAI,EAAE;GACrE,iBAAiB,eAAe;GACjC,CAAC;WACO,eAAe,SAAS,iBAAiB,MAAM;GAExD,MAAM,cAAqD,EAAE;AAC7D,QAAK,MAAM,cAAc,eAAe,eAAe,EAAE,EAAE;IAEzD,MAAM,YAAY,oCADS,MAAM,KAAK,mBAAmB,mBAAmB,cAAc,WAAW,EAEhF,eAAe,YAAY,CAAC,kBAAkB,eAAe,CAAC,CAClF;AAGD,QAAI,CAAC,UAAU,GAAG,IAAI,iBAAiB,CACrC,OAAM,IAAI,WAAW,uCAAuC,UAAU,SAAS,OAAO;AAGxF,gBAAY,KAAK,UAAU;;GAM7B,MAAM,gBAAgB,eAAe,cAAc,KAAK,0BAA0B;IAIhF,MAAM,YAAY,mCAChB,YAAY,eAAe,uBAAuB,CAAC,kBAAkB,eAAe,CAAC,CACtF;AAKD,QAAI,UAAU,GAAG,IAAI,gBAAgB,EAAE;KACrC,MAAM,qBAAqB,uBAAuB,WAAW,YAAY;AACzE,SAAI,mBAAoB,QAAO,mBAAmB;;AAGpD,QAAI,CAAC,UAAU,GAAG,IAAI,iBAAiB,CACrC,OAAM,IAAI,WAAW,uCAAuC,UAAU,SAAS,OAAO;AAGxF,WAAO;KACP;AAEF,oBAAiB,KAAK;IACpB,IAAI,eAAe;IACnB;IACA;IACA,iBAAiB,eAAe;IACjC,CAAC;;AAIN,SAAO;;CAGT,MAAa,gDAAgD,cAA4B,WAA0B;EACjH,IAAI,YAAY,MAAM,KAAK,cAAc,6BAA6B,cAAc,UAAU;AAI9F,MAAI,CAAC,aAAa,UAAU,GAAG,IAAI,iBAAiB,EAAE;GACpD,MAAM,kBAAkB,UAAU,UAAU,IAAI,gBAAgB;AAChE,eAAY,MAAM,KAAK,cAAc,6BAA6B,cAAc,gBAAgB;;AAGlG,MAAI,CAAC,UACH,OAAM,IAAI,oBAAoB,8BAA8B,UAAU,wBAAwB,aAAa,EACzG,YAAY,UAAU,MACvB,CAAC;AAGJ,MAAI,UAAU,YACZ,QAAO;GACL,MAAM,UAAU;GAChB,aAAa,UAAU;GACxB;EAMH,MAAM,cAAc,MAAM,KAAK,mBAAmB,mBAAmB,cAAc,UAAU,IAAI;AAEjG,SAAO;GACL,MAAM,UAAU;GAChB;GACD;;;qCArHJ,YAAY"}