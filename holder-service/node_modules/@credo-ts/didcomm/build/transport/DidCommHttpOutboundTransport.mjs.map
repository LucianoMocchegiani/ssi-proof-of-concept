{"version":3,"file":"DidCommHttpOutboundTransport.mjs","names":[],"sources":["../../src/transport/DidCommHttpOutboundTransport.ts"],"sourcesContent":["import type { AgentContext, Logger } from '@credo-ts/core'\nimport { CredoError, EventEmitter, JsonEncoder } from '@credo-ts/core'\nimport { Subject } from 'rxjs'\nimport type { DidCommMessageReceivedEvent } from '../DidCommEvents'\nimport { DidCommEventTypes } from '../DidCommEvents'\nimport { DidCommModuleConfig } from '../DidCommModuleConfig'\nimport type { DidCommOutboundPackage } from '../types'\nimport { isValidJweStructure } from '../util/JWE'\nimport type { DidCommOutboundTransport } from './DidCommOutboundTransport'\n\nexport class DidCommHttpOutboundTransport implements DidCommOutboundTransport {\n  private agentContext!: AgentContext\n  private logger!: Logger\n  private fetch!: typeof fetch\n  private isActive = false\n\n  private outboundSessionCount = 0\n  private outboundSessionsObservable = new Subject()\n\n  public supportedSchemes = ['http', 'https']\n\n  public async start(agentContext: AgentContext): Promise<void> {\n    this.agentContext = agentContext\n    this.logger = this.agentContext.config.logger\n    this.fetch = this.agentContext.config.agentDependencies.fetch\n    this.isActive = true\n    this.outboundSessionCount = 0\n\n    this.logger.debug('Starting HTTP outbound DIDComm transport')\n  }\n\n  public async stop(): Promise<void> {\n    this.logger.debug('Stopping HTTP outbound DIDComm transport')\n    this.isActive = false\n\n    if (this.outboundSessionCount === 0) {\n      this.agentContext.config.logger.debug(\n        'No open outbound HTTP sessions. Immediately stopping DidCommHttpOutboundTransport'\n      )\n      return\n    }\n\n    this.agentContext.config.logger.debug(\n      `Still ${this.outboundSessionCount} open outbound HTTP sessions. Waiting for sessions to close before stopping DidCommHttpOutboundTransport`\n    )\n    // Track all 'closed' sessions\n    // TODO: add timeout? -> we have a timeout on the request\n    return new Promise((resolve) =>\n      this.outboundSessionsObservable.subscribe(() => {\n        this.agentContext.config.logger.debug(\n          `${this.outboundSessionCount} DidCommHttpOutboundTransport sessions still active`\n        )\n        if (this.outboundSessionCount === 0) resolve()\n      })\n    )\n  }\n\n  public async sendMessage(outboundPackage: DidCommOutboundPackage) {\n    const { payload, endpoint } = outboundPackage\n    const didCommMimeType = this.agentContext.dependencyManager.resolve(DidCommModuleConfig).didCommMimeType\n\n    if (!this.isActive) {\n      throw new CredoError('Outbound transport is not active. Not sending message.')\n    }\n\n    if (!endpoint) {\n      throw new CredoError(`Missing endpoint. I don't know how and where to send the message.`)\n    }\n\n    this.logger.debug(`Sending outbound message to endpoint '${outboundPackage.endpoint}'`, {\n      payload: outboundPackage.payload,\n    })\n\n    try {\n      const abortController = new AbortController()\n      const id = setTimeout(() => abortController.abort(), 15000)\n      this.outboundSessionCount++\n\n      let response: Response | undefined\n      let responseMessage: string | undefined\n      try {\n        response = await this.fetch(endpoint, {\n          method: 'POST',\n          body: JSON.stringify(payload),\n          headers: { 'Content-Type': didCommMimeType },\n          signal: abortController.signal as NonNullable<RequestInit['signal']>,\n        })\n        clearTimeout(id)\n        responseMessage = await response.text()\n      } catch (error) {\n        // Request is aborted after 15 seconds, but that doesn't necessarily mean the request\n        // went wrong. ACA-Py keeps the socket alive until it has a response message. So we assume\n        // that if the error was aborted and we had return routing enabled, we should ignore the error.\n        if (error.name === 'AbortError' && outboundPackage.responseRequested) {\n          this.logger.debug(\n            'Request was aborted due to timeout. Not throwing error due to return routing on sent message'\n          )\n        } else {\n          throw error\n        }\n      }\n\n      // TODO: do we just want to ignore messages that were returned if we didn't request it?\n      // TODO: check response header type (and also update inbound transports to use the correct headers types)\n      if (response && responseMessage) {\n        this.logger.debug('Response received', { responseMessage, status: response.status })\n\n        // This should not happen\n        if (!this.isActive) {\n          this.logger.error(\n            'Received response message over DidCommHttpOutboundTransport while transport was not active.'\n          )\n        }\n\n        try {\n          const encryptedMessage = JsonEncoder.fromString(responseMessage)\n          if (!isValidJweStructure(encryptedMessage)) {\n            this.logger.error(\n              `Received a response from the other agent but the structure of the incoming message is not a DIDComm message: ${responseMessage}`\n            )\n            return\n          }\n          // Emit event with the received agent message.\n          const eventEmitter = this.agentContext.dependencyManager.resolve(EventEmitter)\n          eventEmitter.emit<DidCommMessageReceivedEvent>(this.agentContext, {\n            type: DidCommEventTypes.DidCommMessageReceived,\n            payload: {\n              message: encryptedMessage,\n            },\n          })\n        } catch (_error) {\n          this.logger.debug('Unable to parse response message')\n        }\n      } else {\n        this.logger.debug('No response received.')\n      }\n    } catch (error) {\n      this.logger.error(`Error sending message to ${endpoint}: ${error.message}`, {\n        error,\n        message: error.message,\n        body: payload,\n        didCommMimeType,\n      })\n      throw new CredoError(`Error sending message to ${endpoint}: ${error.message}`, { cause: error })\n    } finally {\n      this.outboundSessionCount--\n      this.outboundSessionsObservable.next(undefined)\n    }\n  }\n}\n"],"mappings":";;;;;;;AAUA,IAAa,+BAAb,MAA8E;;OAIpE,WAAW;OAEX,uBAAuB;OACvB,6BAA6B,IAAI,SAAS;OAE3C,mBAAmB,CAAC,QAAQ,QAAQ;;CAE3C,MAAa,MAAM,cAA2C;AAC5D,OAAK,eAAe;AACpB,OAAK,SAAS,KAAK,aAAa,OAAO;AACvC,OAAK,QAAQ,KAAK,aAAa,OAAO,kBAAkB;AACxD,OAAK,WAAW;AAChB,OAAK,uBAAuB;AAE5B,OAAK,OAAO,MAAM,2CAA2C;;CAG/D,MAAa,OAAsB;AACjC,OAAK,OAAO,MAAM,2CAA2C;AAC7D,OAAK,WAAW;AAEhB,MAAI,KAAK,yBAAyB,GAAG;AACnC,QAAK,aAAa,OAAO,OAAO,MAC9B,oFACD;AACD;;AAGF,OAAK,aAAa,OAAO,OAAO,MAC9B,SAAS,KAAK,qBAAqB,0GACpC;AAGD,SAAO,IAAI,SAAS,YAClB,KAAK,2BAA2B,gBAAgB;AAC9C,QAAK,aAAa,OAAO,OAAO,MAC9B,GAAG,KAAK,qBAAqB,qDAC9B;AACD,OAAI,KAAK,yBAAyB,EAAG,UAAS;IAC9C,CACH;;CAGH,MAAa,YAAY,iBAAyC;EAChE,MAAM,EAAE,SAAS,aAAa;EAC9B,MAAM,kBAAkB,KAAK,aAAa,kBAAkB,QAAQ,oBAAoB,CAAC;AAEzF,MAAI,CAAC,KAAK,SACR,OAAM,IAAI,WAAW,yDAAyD;AAGhF,MAAI,CAAC,SACH,OAAM,IAAI,WAAW,oEAAoE;AAG3F,OAAK,OAAO,MAAM,yCAAyC,gBAAgB,SAAS,IAAI,EACtF,SAAS,gBAAgB,SAC1B,CAAC;AAEF,MAAI;GACF,MAAM,kBAAkB,IAAI,iBAAiB;GAC7C,MAAM,KAAK,iBAAiB,gBAAgB,OAAO,EAAE,KAAM;AAC3D,QAAK;GAEL,IAAI;GACJ,IAAI;AACJ,OAAI;AACF,eAAW,MAAM,KAAK,MAAM,UAAU;KACpC,QAAQ;KACR,MAAM,KAAK,UAAU,QAAQ;KAC7B,SAAS,EAAE,gBAAgB,iBAAiB;KAC5C,QAAQ,gBAAgB;KACzB,CAAC;AACF,iBAAa,GAAG;AAChB,sBAAkB,MAAM,SAAS,MAAM;YAChC,OAAO;AAId,QAAI,MAAM,SAAS,gBAAgB,gBAAgB,kBACjD,MAAK,OAAO,MACV,+FACD;QAED,OAAM;;AAMV,OAAI,YAAY,iBAAiB;AAC/B,SAAK,OAAO,MAAM,qBAAqB;KAAE;KAAiB,QAAQ,SAAS;KAAQ,CAAC;AAGpF,QAAI,CAAC,KAAK,SACR,MAAK,OAAO,MACV,8FACD;AAGH,QAAI;KACF,MAAM,mBAAmB,YAAY,WAAW,gBAAgB;AAChE,SAAI,CAAC,oBAAoB,iBAAiB,EAAE;AAC1C,WAAK,OAAO,MACV,gHAAgH,kBACjH;AACD;;AAIF,KADqB,KAAK,aAAa,kBAAkB,QAAQ,aAAa,CACjE,KAAkC,KAAK,cAAc;MAChE,MAAM,kBAAkB;MACxB,SAAS,EACP,SAAS,kBACV;MACF,CAAC;aACK,QAAQ;AACf,UAAK,OAAO,MAAM,mCAAmC;;SAGvD,MAAK,OAAO,MAAM,wBAAwB;WAErC,OAAO;AACd,QAAK,OAAO,MAAM,4BAA4B,SAAS,IAAI,MAAM,WAAW;IAC1E;IACA,SAAS,MAAM;IACf,MAAM;IACN;IACD,CAAC;AACF,SAAM,IAAI,WAAW,4BAA4B,SAAS,IAAI,MAAM,WAAW,EAAE,OAAO,OAAO,CAAC;YACxF;AACR,QAAK;AACL,QAAK,2BAA2B,KAAK,OAAU"}