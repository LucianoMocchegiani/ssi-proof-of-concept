import { DidCommEventTypes } from "../DidCommEvents.mjs";
import { isValidJweStructure } from "../util/JWE.mjs";
import { DidCommModuleConfig } from "../DidCommModuleConfig.mjs";
import { CredoError, EventEmitter, JsonEncoder } from "@credo-ts/core";
import { Subject } from "rxjs";

//#region src/transport/DidCommHttpOutboundTransport.ts
var DidCommHttpOutboundTransport = class {
	constructor() {
		this.isActive = false;
		this.outboundSessionCount = 0;
		this.outboundSessionsObservable = new Subject();
		this.supportedSchemes = ["http", "https"];
	}
	async start(agentContext) {
		this.agentContext = agentContext;
		this.logger = this.agentContext.config.logger;
		this.fetch = this.agentContext.config.agentDependencies.fetch;
		this.isActive = true;
		this.outboundSessionCount = 0;
		this.logger.debug("Starting HTTP outbound DIDComm transport");
	}
	async stop() {
		this.logger.debug("Stopping HTTP outbound DIDComm transport");
		this.isActive = false;
		if (this.outboundSessionCount === 0) {
			this.agentContext.config.logger.debug("No open outbound HTTP sessions. Immediately stopping DidCommHttpOutboundTransport");
			return;
		}
		this.agentContext.config.logger.debug(`Still ${this.outboundSessionCount} open outbound HTTP sessions. Waiting for sessions to close before stopping DidCommHttpOutboundTransport`);
		return new Promise((resolve) => this.outboundSessionsObservable.subscribe(() => {
			this.agentContext.config.logger.debug(`${this.outboundSessionCount} DidCommHttpOutboundTransport sessions still active`);
			if (this.outboundSessionCount === 0) resolve();
		}));
	}
	async sendMessage(outboundPackage) {
		const { payload, endpoint } = outboundPackage;
		const didCommMimeType = this.agentContext.dependencyManager.resolve(DidCommModuleConfig).didCommMimeType;
		if (!this.isActive) throw new CredoError("Outbound transport is not active. Not sending message.");
		if (!endpoint) throw new CredoError(`Missing endpoint. I don't know how and where to send the message.`);
		this.logger.debug(`Sending outbound message to endpoint '${outboundPackage.endpoint}'`, { payload: outboundPackage.payload });
		try {
			const abortController = new AbortController();
			const id = setTimeout(() => abortController.abort(), 15e3);
			this.outboundSessionCount++;
			let response;
			let responseMessage;
			try {
				response = await this.fetch(endpoint, {
					method: "POST",
					body: JSON.stringify(payload),
					headers: { "Content-Type": didCommMimeType },
					signal: abortController.signal
				});
				clearTimeout(id);
				responseMessage = await response.text();
			} catch (error) {
				if (error.name === "AbortError" && outboundPackage.responseRequested) this.logger.debug("Request was aborted due to timeout. Not throwing error due to return routing on sent message");
				else throw error;
			}
			if (response && responseMessage) {
				this.logger.debug("Response received", {
					responseMessage,
					status: response.status
				});
				if (!this.isActive) this.logger.error("Received response message over DidCommHttpOutboundTransport while transport was not active.");
				try {
					const encryptedMessage = JsonEncoder.fromString(responseMessage);
					if (!isValidJweStructure(encryptedMessage)) {
						this.logger.error(`Received a response from the other agent but the structure of the incoming message is not a DIDComm message: ${responseMessage}`);
						return;
					}
					this.agentContext.dependencyManager.resolve(EventEmitter).emit(this.agentContext, {
						type: DidCommEventTypes.DidCommMessageReceived,
						payload: { message: encryptedMessage }
					});
				} catch (_error) {
					this.logger.debug("Unable to parse response message");
				}
			} else this.logger.debug("No response received.");
		} catch (error) {
			this.logger.error(`Error sending message to ${endpoint}: ${error.message}`, {
				error,
				message: error.message,
				body: payload,
				didCommMimeType
			});
			throw new CredoError(`Error sending message to ${endpoint}: ${error.message}`, { cause: error });
		} finally {
			this.outboundSessionCount--;
			this.outboundSessionsObservable.next(void 0);
		}
	}
};

//#endregion
export { DidCommHttpOutboundTransport };
//# sourceMappingURL=DidCommHttpOutboundTransport.mjs.map