import { __decorate } from "../../_virtual/_@oxc-project_runtime@0.110.0/helpers/decorate.mjs";
import { __decorateMetadata } from "../../_virtual/_@oxc-project_runtime@0.110.0/helpers/decorateMetadata.mjs";
import { AgentContext, injectable, utils } from "@credo-ts/core";

//#region src/transport/queue/InMemoryQueueTransportRepository.ts
let InMemoryQueueTransportRepository = class InMemoryQueueTransportRepository {
	constructor() {
		this.messages = [];
	}
	getAvailableMessageCount(_agentContext, options) {
		const { connectionId, recipientDid } = options;
		return this.messages.filter((msg) => msg.connectionId === connectionId && (recipientDid === void 0 || msg.recipientDids.includes(recipientDid)) && msg.state === "pending").length;
	}
	takeFromQueue(agentContext, options) {
		const { connectionId, recipientDid, limit, deleteMessages } = options;
		let messages = this.messages.filter((msg) => msg.connectionId === connectionId && msg.state === "pending" && (recipientDid === void 0 || msg.recipientDids.includes(recipientDid)));
		const messagesToTake = limit ?? messages.length;
		messages = messages.slice(0, messagesToTake);
		agentContext.config.logger.debug(`Taking ${messagesToTake} messages from queue for connection ${connectionId}`);
		for (const msg of messages) {
			const index = this.messages.findIndex((item) => item.id === msg.id);
			if (index !== -1) this.messages[index].state = "sending";
		}
		if (deleteMessages) this.removeMessages(agentContext, {
			connectionId,
			messageIds: messages.map((msg) => msg.id)
		});
		return messages;
	}
	addMessage(_agentContext, options) {
		const { connectionId, recipientDids, payload } = options;
		const id = utils.uuid();
		this.messages.push({
			id,
			receivedAt: options.receivedAt ?? /* @__PURE__ */ new Date(),
			connectionId,
			encryptedMessage: payload,
			recipientDids,
			state: "pending"
		});
		return id;
	}
	removeMessages(_agentContext, options) {
		const { messageIds } = options;
		for (const messageId of messageIds) {
			const messageIndex = this.messages.findIndex((item) => item.id === messageId);
			if (messageIndex > -1) this.messages.splice(messageIndex, 1);
		}
	}
};
InMemoryQueueTransportRepository = __decorate([injectable(), __decorateMetadata("design:paramtypes", [])], InMemoryQueueTransportRepository);

//#endregion
export { InMemoryQueueTransportRepository };
//# sourceMappingURL=InMemoryQueueTransportRepository.mjs.map