import { DidCommEventTypes } from "../DidCommEvents.mjs";
import { isValidJweStructure } from "../util/JWE.mjs";
import { DidCommTransportEventTypes } from "./DidCommTransportEventTypes.mjs";
import { Buffer, CredoError, EventEmitter, JsonEncoder } from "@credo-ts/core";

//#region src/transport/DidCommWsOutboundTransport.ts
var DidCommWsOutboundTransport = class {
	constructor() {
		this.transportTable = /* @__PURE__ */ new Map();
		this.supportedSchemes = ["ws", "wss"];
		this.isActive = false;
		this.handleMessageEvent = (event) => {
			this.logger.trace("WebSocket message event received.", { url: event.target.url });
			const payload = JsonEncoder.fromBuffer(event.data);
			if (!isValidJweStructure(payload)) throw new Error(`Received a response from the other agent but the structure of the incoming message is not a DIDComm message: ${payload}`);
			this.logger.debug("Payload received from mediator:", payload);
			this.agentContext.dependencyManager.resolve(EventEmitter).emit(this.agentContext, {
				type: DidCommEventTypes.DidCommMessageReceived,
				payload: { message: payload }
			});
		};
	}
	async start(agentContext) {
		this.agentContext = agentContext;
		this.logger = agentContext.config.logger;
		this.logger.debug("Starting WS outbound DIDComm transport");
		this.WebSocketClass = agentContext.config.agentDependencies.WebSocketClass;
		this.isActive = true;
	}
	async stop() {
		this.logger.debug("Stopping WS outbound DIDComm transport");
		this.isActive = false;
		const stillOpenSocketClosingPromises = [];
		for (const [, socket] of this.transportTable) {
			socket.removeEventListener("message", this.handleMessageEvent);
			if (socket.readyState !== this.WebSocketClass.CLOSED) {
				stillOpenSocketClosingPromises.push(new Promise((resolve) => {
					const closeHandler = () => {
						socket.removeEventListener("close", closeHandler);
						resolve();
					};
					socket.addEventListener("close", closeHandler);
				}));
				socket.close();
			}
		}
		await Promise.all(stillOpenSocketClosingPromises);
	}
	async sendMessage(outboundPackage) {
		const { payload, endpoint, connectionId } = outboundPackage;
		this.logger.debug(`Sending outbound message to endpoint '${endpoint}' over WebSocket transport.`, { payload });
		if (!this.isActive) throw new CredoError("Outbound transport is not active. Not sending message.");
		if (!endpoint) throw new CredoError("Missing connection or endpoint. I don't know how and where to send the message.");
		const socketId = `${endpoint}-${connectionId}`;
		const isNewSocket = !this.hasOpenSocket(socketId);
		const socket = await this.resolveSocket({
			socketId,
			endpoint,
			connectionId
		});
		socket.send(Buffer.from(JSON.stringify(payload)));
		if (isNewSocket && !outboundPackage.responseRequested) socket.close();
	}
	hasOpenSocket(socketId) {
		return this.transportTable.get(socketId) !== void 0;
	}
	async resolveSocket({ socketId, endpoint, connectionId }) {
		let socket = this.transportTable.get(socketId);
		if (!socket || socket.readyState === this.WebSocketClass.CLOSING) {
			if (!endpoint) throw new CredoError(`Missing endpoint. I don't know how and where to send the message.`);
			socket = await this.createSocketConnection({
				endpoint,
				socketId,
				connectionId
			});
			this.transportTable.set(socketId, socket);
			this.listenOnWebSocketMessages(socket);
		}
		if (socket.readyState !== this.WebSocketClass.OPEN) throw new CredoError("Socket is not open.");
		return socket;
	}
	listenOnWebSocketMessages(socket) {
		socket.addEventListener("message", this.handleMessageEvent);
	}
	createSocketConnection({ socketId, endpoint, connectionId }) {
		return new Promise((resolve, reject) => {
			this.logger.debug(`Connecting to WebSocket ${endpoint}`);
			const socket = new this.WebSocketClass(endpoint);
			const eventEmitter = this.agentContext.dependencyManager.resolve(EventEmitter);
			socket.onopen = () => {
				this.logger.debug(`Successfully connected to WebSocket ${endpoint}`);
				resolve(socket);
				eventEmitter.emit(this.agentContext, {
					type: DidCommTransportEventTypes.DidCommOutboundWebSocketOpenedEvent,
					payload: {
						socketId,
						connectionId
					}
				});
			};
			socket.onerror = (error) => {
				this.logger.debug(`Error while connecting to WebSocket ${endpoint}`, { error });
				reject(error);
			};
			socket.onclose = async () => {
				this.logger.debug(`WebSocket closing to ${endpoint}`);
				socket.removeEventListener("message", this.handleMessageEvent);
				this.transportTable.delete(socketId);
				eventEmitter.emit(this.agentContext, {
					type: DidCommTransportEventTypes.DidCommOutboundWebSocketClosedEvent,
					payload: {
						socketId,
						connectionId
					}
				});
			};
		});
	}
};

//#endregion
export { DidCommWsOutboundTransport };
//# sourceMappingURL=DidCommWsOutboundTransport.mjs.map