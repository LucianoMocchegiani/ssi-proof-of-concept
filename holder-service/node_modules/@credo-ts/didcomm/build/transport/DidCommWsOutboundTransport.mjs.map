{"version":3,"file":"DidCommWsOutboundTransport.mjs","names":[],"sources":["../../src/transport/DidCommWsOutboundTransport.ts"],"sourcesContent":["import type { AgentContext, Logger } from '@credo-ts/core'\nimport { Buffer, CredoError, EventEmitter, JsonEncoder } from '@credo-ts/core'\nimport type { WebSocket } from 'ws'\nimport type { DidCommMessageReceivedEvent } from '../DidCommEvents'\nimport { DidCommEventTypes } from '../DidCommEvents'\nimport type { DidCommOutboundPackage } from '../types'\nimport { isValidJweStructure } from '../util/JWE'\nimport type { DidCommOutboundTransport } from './DidCommOutboundTransport'\nimport type {\n  DidCommOutboundWebSocketClosedEvent,\n  DidCommOutboundWebSocketOpenedEvent,\n} from './DidCommTransportEventTypes'\n\nimport { DidCommTransportEventTypes } from './DidCommTransportEventTypes'\n\nexport class DidCommWsOutboundTransport implements DidCommOutboundTransport {\n  private transportTable: Map<string, WebSocket> = new Map<string, WebSocket>()\n  private agentContext!: AgentContext\n  private logger!: Logger\n  private WebSocketClass!: typeof WebSocket\n  public supportedSchemes = ['ws', 'wss']\n  private isActive = false\n\n  public async start(agentContext: AgentContext): Promise<void> {\n    this.agentContext = agentContext\n\n    this.logger = agentContext.config.logger\n\n    this.logger.debug('Starting WS outbound DIDComm transport')\n    this.WebSocketClass = agentContext.config.agentDependencies.WebSocketClass\n\n    this.isActive = true\n  }\n\n  public async stop() {\n    this.logger.debug('Stopping WS outbound DIDComm transport')\n    this.isActive = false\n\n    const stillOpenSocketClosingPromises: Array<Promise<void>> = []\n\n    for (const [, socket] of this.transportTable) {\n      socket.removeEventListener('message', this.handleMessageEvent)\n      if (socket.readyState !== this.WebSocketClass.CLOSED) {\n        stillOpenSocketClosingPromises.push(\n          new Promise((resolve) => {\n            const closeHandler = () => {\n              socket.removeEventListener('close', closeHandler)\n              resolve()\n            }\n\n            socket.addEventListener('close', closeHandler)\n          })\n        )\n\n        socket.close()\n      }\n    }\n\n    // Wait for all open websocket connections to have been closed\n    await Promise.all(stillOpenSocketClosingPromises)\n  }\n\n  public async sendMessage(outboundPackage: DidCommOutboundPackage) {\n    const { payload, endpoint, connectionId } = outboundPackage\n    this.logger.debug(`Sending outbound message to endpoint '${endpoint}' over WebSocket transport.`, {\n      payload,\n    })\n\n    if (!this.isActive) {\n      throw new CredoError('Outbound transport is not active. Not sending message.')\n    }\n\n    if (!endpoint) {\n      throw new CredoError(\"Missing connection or endpoint. I don't know how and where to send the message.\")\n    }\n\n    const socketId = `${endpoint}-${connectionId}`\n    const isNewSocket = !this.hasOpenSocket(socketId)\n    const socket = await this.resolveSocket({ socketId, endpoint, connectionId })\n\n    // If the socket was created for this message and we don't have return routing enabled\n    // We can close the socket as it shouldn't return messages anymore\n    // make sure to use the socket in a manner that is compliant with the https://developer.mozilla.org/en-US/docs/Web/API/WebSocket\n    // (React Native) and https://github.com/websockets/ws (NodeJs)\n    socket.send(Buffer.from(JSON.stringify(payload)))\n    if (isNewSocket && !outboundPackage.responseRequested) {\n      socket.close()\n    }\n  }\n\n  private hasOpenSocket(socketId: string) {\n    return this.transportTable.get(socketId) !== undefined\n  }\n\n  private async resolveSocket({\n    socketId,\n    endpoint,\n    connectionId,\n  }: {\n    socketId: string\n    endpoint?: string\n    connectionId?: string\n  }) {\n    // If we already have a socket connection use it\n    let socket = this.transportTable.get(socketId)\n\n    if (!socket || socket.readyState === this.WebSocketClass.CLOSING) {\n      if (!endpoint) {\n        throw new CredoError(`Missing endpoint. I don't know how and where to send the message.`)\n      }\n      socket = await this.createSocketConnection({\n        endpoint,\n        socketId,\n        connectionId,\n      })\n      this.transportTable.set(socketId, socket)\n      this.listenOnWebSocketMessages(socket)\n    }\n\n    if (socket.readyState !== this.WebSocketClass.OPEN) {\n      throw new CredoError('Socket is not open.')\n    }\n\n    return socket\n  }\n\n  // NOTE: Because this method is passed to the event handler this must be a lambda method\n  // so 'this' is scoped to the 'WsDidCommOutboundTransport' class instance\n  // biome-ignore lint/suspicious/noExplicitAny: no explanation\n  private handleMessageEvent = (event: any) => {\n    this.logger.trace('WebSocket message event received.', { url: event.target.url })\n    const payload = JsonEncoder.fromBuffer(event.data)\n    if (!isValidJweStructure(payload)) {\n      throw new Error(\n        `Received a response from the other agent but the structure of the incoming message is not a DIDComm message: ${payload}`\n      )\n    }\n    this.logger.debug('Payload received from mediator:', payload)\n\n    const eventEmitter = this.agentContext.dependencyManager.resolve(EventEmitter)\n\n    eventEmitter.emit<DidCommMessageReceivedEvent>(this.agentContext, {\n      type: DidCommEventTypes.DidCommMessageReceived,\n      payload: {\n        message: payload,\n      },\n    })\n  }\n\n  private listenOnWebSocketMessages(socket: WebSocket) {\n    socket.addEventListener('message', this.handleMessageEvent)\n  }\n\n  private createSocketConnection({\n    socketId,\n    endpoint,\n    connectionId,\n  }: {\n    socketId: string\n    endpoint: string\n    connectionId?: string\n  }): Promise<WebSocket> {\n    return new Promise((resolve, reject) => {\n      this.logger.debug(`Connecting to WebSocket ${endpoint}`)\n      const socket = new this.WebSocketClass(endpoint)\n      const eventEmitter = this.agentContext.dependencyManager.resolve(EventEmitter)\n\n      socket.onopen = () => {\n        this.logger.debug(`Successfully connected to WebSocket ${endpoint}`)\n        resolve(socket)\n\n        eventEmitter.emit<DidCommOutboundWebSocketOpenedEvent>(this.agentContext, {\n          type: DidCommTransportEventTypes.DidCommOutboundWebSocketOpenedEvent,\n          payload: {\n            socketId,\n            connectionId: connectionId,\n          },\n        })\n      }\n\n      socket.onerror = (error) => {\n        this.logger.debug(`Error while connecting to WebSocket ${endpoint}`, {\n          error,\n        })\n        reject(error)\n      }\n\n      socket.onclose = async () => {\n        this.logger.debug(`WebSocket closing to ${endpoint}`)\n        socket.removeEventListener('message', this.handleMessageEvent)\n        this.transportTable.delete(socketId)\n\n        eventEmitter.emit<DidCommOutboundWebSocketClosedEvent>(this.agentContext, {\n          type: DidCommTransportEventTypes.DidCommOutboundWebSocketClosedEvent,\n          payload: {\n            socketId,\n            connectionId: connectionId,\n          },\n        })\n      }\n    })\n  }\n}\n"],"mappings":"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"}