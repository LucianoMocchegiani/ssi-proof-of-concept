import { DidCommProtocol } from "../../../../models/features/DidCommProtocol.mjs";
import "../../../../models/index.mjs";
import { AckStatus } from "../../../../messages/common/DidCommAckMessage.mjs";
import "../../../../messages/index.mjs";
import { DidCommConnectionService } from "../../../connections/services/DidCommConnectionService.mjs";
import "../../../connections/index.mjs";
import { DidCommMessageRepository } from "../../../../repository/DidCommMessageRepository.mjs";
import { DidCommMessageRole } from "../../../../repository/DidCommMessageRole.mjs";
import "../../../../repository/index.mjs";
import { DidCommAutoAcceptCredential } from "../../models/DidCommCredentialAutoAcceptType.mjs";
import { DidCommCredentialProblemReportReason } from "../../models/DidCommCredentialProblemReportReason.mjs";
import { DidCommCredentialRole } from "../../models/DidCommCredentialRole.mjs";
import { DidCommCredentialState } from "../../models/DidCommCredentialState.mjs";
import "../../models/index.mjs";
import { DidCommCredentialsModuleConfig } from "../../DidCommCredentialsModuleConfig.mjs";
import { DidCommCredentialExchangeRecord } from "../../repository/DidCommCredentialExchangeRecord.mjs";
import { DidCommCredentialExchangeRepository } from "../../repository/DidCommCredentialExchangeRepository.mjs";
import "../../repository/index.mjs";
import { composeAutoAccept } from "../../util/composeAutoAccept.mjs";
import { arePreviewAttributesEqual } from "../../util/previewAttributes.mjs";
import { DidCommBaseCredentialProtocol } from "../DidCommBaseCredentialProtocol.mjs";
import { DidCommCredentialV2AckMessage } from "./messages/DidCommCredentialV2AckMessage.mjs";
import { DidCommCredentialV2ProblemReportMessage } from "./messages/DidCommCredentialV2ProblemReportMessage.mjs";
import { DidCommIssueCredentialV2Message } from "./messages/DidCommIssueCredentialV2Message.mjs";
import { DidCommOfferCredentialV2Message } from "./messages/DidCommOfferCredentialV2Message.mjs";
import { DidCommProposeCredentialV2Message } from "./messages/DidCommProposeCredentialV2Message.mjs";
import { DidCommRequestCredentialV2Message } from "./messages/DidCommRequestCredentialV2Message.mjs";
import "./messages/index.mjs";
import { DidCommCredentialFormatCoordinator } from "./DidCommCredentialFormatCoordinator.mjs";
import { DidCommCredentialV2AckHandler } from "./handlers/DidCommCredentialV2AckHandler.mjs";
import { DidCommCredentialV2ProblemReportHandler } from "./handlers/DidCommCredentialV2ProblemReportHandler.mjs";
import { DidCommIssueCredentialV2Handler } from "./handlers/DidCommIssueCredentialV2Handler.mjs";
import { DidCommOfferCredentialV2Handler } from "./handlers/DidCommOfferCredentialV2Handler.mjs";
import { DidCommProposeCredentialV2Handler } from "./handlers/DidCommProposeCredentialV2Handler.mjs";
import { DidCommRequestCredentialV2Handler } from "./handlers/DidCommRequestCredentialV2Handler.mjs";
import "./handlers/index.mjs";
import { CredoError, utils } from "@credo-ts/core";

//#region src/modules/credentials/protocol/v2/DidCommCredentialV2Protocol.ts
var DidCommCredentialV2Protocol = class extends DidCommBaseCredentialProtocol {
	constructor({ credentialFormats }) {
		super();
		this.credentialFormatCoordinator = new DidCommCredentialFormatCoordinator();
		this.version = "v2";
		this.credentialFormats = credentialFormats;
	}
	/**
	* Registers the protocol implementation (handlers, feature registry) on the agent.
	*/
	register(messageHandlerRegistry, featureRegistry) {
		messageHandlerRegistry.registerMessageHandlers([
			new DidCommProposeCredentialV2Handler(this),
			new DidCommOfferCredentialV2Handler(this),
			new DidCommRequestCredentialV2Handler(this),
			new DidCommIssueCredentialV2Handler(this),
			new DidCommCredentialV2AckHandler(this),
			new DidCommCredentialV2ProblemReportHandler(this)
		]);
		featureRegistry.register(new DidCommProtocol({
			id: "https://didcomm.org/issue-credential/2.0",
			roles: ["holder", "issuer"]
		}));
	}
	/**
	* Create a {@link DidCommProposeCredentialV2Message} not bound to an existing credential exchange.
	*
	* @param proposal The ProposeCredentialOptions object containing the important fields for the credential message
	* @returns Object containing proposal message and associated credential record
	*
	*/
	async createProposal(agentContext, { connectionRecord, credentialFormats, comment, goal, goalCode, autoAcceptCredential }) {
		agentContext.config.logger.debug("Get the Format Service and Create Proposal Message");
		const credentialRepository = agentContext.dependencyManager.resolve(DidCommCredentialExchangeRepository);
		const formatServices = this.getFormatServices(credentialFormats);
		if (formatServices.length === 0) throw new CredoError("Unable to create proposal. No supported formats");
		const credentialExchangeRecord = new DidCommCredentialExchangeRecord({
			connectionId: connectionRecord.id,
			threadId: utils.uuid(),
			state: DidCommCredentialState.ProposalSent,
			role: DidCommCredentialRole.Holder,
			autoAcceptCredential,
			protocolVersion: "v2"
		});
		const proposalMessage = await this.credentialFormatCoordinator.createProposal(agentContext, {
			credentialFormats,
			credentialExchangeRecord,
			formatServices,
			comment,
			goal,
			goalCode
		});
		agentContext.config.logger.debug("Save record and emit state change event");
		await credentialRepository.save(agentContext, credentialExchangeRecord);
		this.emitStateChangedEvent(agentContext, credentialExchangeRecord, null);
		return {
			credentialExchangeRecord,
			message: proposalMessage
		};
	}
	/**
	* Method called by {@link DidCommProposeCredentialV2Handler} on reception of a propose credential message
	* We do the necessary processing here to accept the proposal and do the state change, emit event etc.
	* @param messageContext the inbound propose credential message
	* @returns credential record appropriate for this incoming message (once accepted)
	*/
	async processProposal(messageContext) {
		const { message: proposalMessage, connection, agentContext } = messageContext;
		agentContext.config.logger.debug(`Processing credential proposal with id ${proposalMessage.id}`);
		const credentialRepository = agentContext.dependencyManager.resolve(DidCommCredentialExchangeRepository);
		const didCommMessageRepository = agentContext.dependencyManager.resolve(DidCommMessageRepository);
		const connectionService = agentContext.dependencyManager.resolve(DidCommConnectionService);
		let credentialExchangeRecord = await this.findByProperties(messageContext.agentContext, {
			threadId: proposalMessage.threadId,
			role: DidCommCredentialRole.Issuer
		});
		const formatServices = this.getFormatServicesFromMessage(proposalMessage.formats);
		if (formatServices.length === 0) throw new CredoError("Unable to process proposal. No supported formats");
		if (credentialExchangeRecord) {
			const proposalCredentialMessage = await didCommMessageRepository.findAgentMessage(messageContext.agentContext, {
				associatedRecordId: credentialExchangeRecord.id,
				messageClass: DidCommProposeCredentialV2Message,
				role: DidCommMessageRole.Receiver
			});
			const offerCredentialMessage = await didCommMessageRepository.findAgentMessage(messageContext.agentContext, {
				associatedRecordId: credentialExchangeRecord.id,
				messageClass: DidCommOfferCredentialV2Message,
				role: DidCommMessageRole.Sender
			});
			credentialExchangeRecord.assertProtocolVersion("v2");
			credentialExchangeRecord.assertState(DidCommCredentialState.OfferSent);
			await connectionService.assertConnectionOrOutOfBandExchange(messageContext, {
				lastReceivedMessage: proposalCredentialMessage ?? void 0,
				lastSentMessage: offerCredentialMessage ?? void 0,
				expectedConnectionId: credentialExchangeRecord.connectionId
			});
			if (!credentialExchangeRecord?.connectionId) {
				await connectionService.matchIncomingMessageToRequestMessageInOutOfBandExchange(messageContext, { expectedConnectionId: credentialExchangeRecord?.connectionId });
				credentialExchangeRecord.connectionId = connection?.id;
			}
			await this.credentialFormatCoordinator.processProposal(messageContext.agentContext, {
				credentialExchangeRecord,
				formatServices,
				message: proposalMessage
			});
			await this.updateState(messageContext.agentContext, credentialExchangeRecord, DidCommCredentialState.ProposalReceived);
			return credentialExchangeRecord;
		}
		await connectionService.assertConnectionOrOutOfBandExchange(messageContext);
		credentialExchangeRecord = new DidCommCredentialExchangeRecord({
			connectionId: connection?.id,
			threadId: proposalMessage.threadId,
			parentThreadId: proposalMessage.thread?.parentThreadId,
			state: DidCommCredentialState.ProposalReceived,
			role: DidCommCredentialRole.Issuer,
			protocolVersion: "v2"
		});
		await this.credentialFormatCoordinator.processProposal(messageContext.agentContext, {
			credentialExchangeRecord,
			formatServices,
			message: proposalMessage
		});
		await credentialRepository.save(messageContext.agentContext, credentialExchangeRecord);
		this.emitStateChangedEvent(messageContext.agentContext, credentialExchangeRecord, null);
		return credentialExchangeRecord;
	}
	async acceptProposal(agentContext, { credentialExchangeRecord, credentialFormats, autoAcceptCredential, comment, goal, goalCode }) {
		credentialExchangeRecord.assertProtocolVersion("v2");
		credentialExchangeRecord.assertState(DidCommCredentialState.ProposalReceived);
		const didCommMessageRepository = agentContext.dependencyManager.resolve(DidCommMessageRepository);
		let formatServices = this.getFormatServices(credentialFormats ?? {});
		if (formatServices.length === 0) {
			const proposalMessage = await didCommMessageRepository.getAgentMessage(agentContext, {
				associatedRecordId: credentialExchangeRecord.id,
				messageClass: DidCommProposeCredentialV2Message,
				role: DidCommMessageRole.Receiver
			});
			formatServices = this.getFormatServicesFromMessage(proposalMessage.formats);
		}
		if (formatServices.length === 0) throw new CredoError("Unable to accept proposal. No supported formats provided as input or in proposal message");
		const offerMessage = await this.credentialFormatCoordinator.acceptProposal(agentContext, {
			credentialExchangeRecord,
			formatServices,
			comment,
			goal,
			goalCode,
			credentialFormats
		});
		credentialExchangeRecord.autoAcceptCredential = autoAcceptCredential ?? credentialExchangeRecord.autoAcceptCredential;
		await this.updateState(agentContext, credentialExchangeRecord, DidCommCredentialState.OfferSent);
		return {
			credentialExchangeRecord,
			message: offerMessage
		};
	}
	/**
	* Negotiate a credential proposal as issuer (by sending a credential offer message) to the connection
	* associated with the credential record.
	*
	* @param options configuration for the offer see {@link NegotiateCredentialProposalOptions}
	* @returns Credential exchange record associated with the credential offer
	*
	*/
	async negotiateProposal(agentContext, { credentialExchangeRecord, credentialFormats, autoAcceptCredential, comment, goal, goalCode }) {
		credentialExchangeRecord.assertProtocolVersion("v2");
		credentialExchangeRecord.assertState(DidCommCredentialState.ProposalReceived);
		if (!credentialExchangeRecord.connectionId) throw new CredoError(`No connectionId found for credential record '${credentialExchangeRecord.id}'. Connection-less issuance does not support negotiation.`);
		const formatServices = this.getFormatServices(credentialFormats);
		if (formatServices.length === 0) throw new CredoError("Unable to create offer. No supported formats");
		const offerMessage = await this.credentialFormatCoordinator.createOffer(agentContext, {
			formatServices,
			credentialFormats,
			credentialExchangeRecord,
			comment,
			goal,
			goalCode
		});
		credentialExchangeRecord.autoAcceptCredential = autoAcceptCredential ?? credentialExchangeRecord.autoAcceptCredential;
		await this.updateState(agentContext, credentialExchangeRecord, DidCommCredentialState.OfferSent);
		return {
			credentialExchangeRecord,
			message: offerMessage
		};
	}
	/**
	* Create a {@link DidCommOfferCredentialV2Message} as beginning of protocol process. If no connectionId is provided, the
	* exchange will be created without a connection for usage in oob and connection-less issuance.
	*
	* @param formatService {@link DidCommCredentialFormatService} the format service object containing format-specific logic
	* @param options attributes of the original offer
	* @returns Object containing offer message and associated credential record
	*
	*/
	async createOffer(agentContext, { credentialFormats, autoAcceptCredential, comment, goal, goalCode, connectionRecord }) {
		const credentialRepository = agentContext.dependencyManager.resolve(DidCommCredentialExchangeRepository);
		const formatServices = this.getFormatServices(credentialFormats);
		if (formatServices.length === 0) throw new CredoError("Unable to create offer. No supported formats");
		const credentialExchangeRecord = new DidCommCredentialExchangeRecord({
			connectionId: connectionRecord?.id,
			threadId: utils.uuid(),
			state: DidCommCredentialState.OfferSent,
			role: DidCommCredentialRole.Issuer,
			autoAcceptCredential,
			protocolVersion: "v2"
		});
		const offerMessage = await this.credentialFormatCoordinator.createOffer(agentContext, {
			formatServices,
			credentialFormats,
			credentialExchangeRecord,
			comment,
			goal,
			goalCode
		});
		agentContext.config.logger.debug(`Saving record and emitting state changed for credential exchange record ${credentialExchangeRecord.id}`);
		await credentialRepository.save(agentContext, credentialExchangeRecord);
		this.emitStateChangedEvent(agentContext, credentialExchangeRecord, null);
		return {
			credentialExchangeRecord,
			message: offerMessage
		};
	}
	/**
	* Method called by {@link DidCommOfferCredentialV2Handler} on reception of a offer credential message
	* We do the necessary processing here to accept the offer and do the state change, emit event etc.
	* @param messageContext the inbound offer credential message
	* @returns credential record appropriate for this incoming message (once accepted)
	*/
	async processOffer(messageContext) {
		const { message: offerMessage, connection, agentContext } = messageContext;
		agentContext.config.logger.debug(`Processing credential offer with id ${offerMessage.id}`);
		const credentialRepository = agentContext.dependencyManager.resolve(DidCommCredentialExchangeRepository);
		const didCommMessageRepository = agentContext.dependencyManager.resolve(DidCommMessageRepository);
		const connectionService = agentContext.dependencyManager.resolve(DidCommConnectionService);
		let credentialExchangeRecord = await this.findByProperties(messageContext.agentContext, {
			threadId: offerMessage.threadId,
			role: DidCommCredentialRole.Holder,
			connectionId: connection?.id
		});
		const formatServices = this.getFormatServicesFromMessage(offerMessage.formats);
		if (formatServices.length === 0) throw new CredoError("Unable to process offer. No supported formats");
		if (credentialExchangeRecord) {
			const proposeCredentialMessage = await didCommMessageRepository.findAgentMessage(messageContext.agentContext, {
				associatedRecordId: credentialExchangeRecord.id,
				messageClass: DidCommProposeCredentialV2Message,
				role: DidCommMessageRole.Sender
			});
			const offerCredentialMessage = await didCommMessageRepository.findAgentMessage(messageContext.agentContext, {
				associatedRecordId: credentialExchangeRecord.id,
				messageClass: DidCommOfferCredentialV2Message,
				role: DidCommMessageRole.Receiver
			});
			credentialExchangeRecord.assertProtocolVersion("v2");
			credentialExchangeRecord.assertState(DidCommCredentialState.ProposalSent);
			await connectionService.assertConnectionOrOutOfBandExchange(messageContext, {
				lastReceivedMessage: offerCredentialMessage ?? void 0,
				lastSentMessage: proposeCredentialMessage ?? void 0,
				expectedConnectionId: credentialExchangeRecord.connectionId
			});
			await this.credentialFormatCoordinator.processOffer(messageContext.agentContext, {
				credentialExchangeRecord,
				formatServices,
				message: offerMessage
			});
			await this.updateState(messageContext.agentContext, credentialExchangeRecord, DidCommCredentialState.OfferReceived);
			return credentialExchangeRecord;
		}
		await connectionService.assertConnectionOrOutOfBandExchange(messageContext);
		agentContext.config.logger.debug("No credential record found for offer, creating a new one");
		credentialExchangeRecord = new DidCommCredentialExchangeRecord({
			connectionId: connection?.id,
			threadId: offerMessage.threadId,
			parentThreadId: offerMessage.thread?.parentThreadId,
			state: DidCommCredentialState.OfferReceived,
			role: DidCommCredentialRole.Holder,
			protocolVersion: "v2"
		});
		await this.credentialFormatCoordinator.processOffer(messageContext.agentContext, {
			credentialExchangeRecord,
			formatServices,
			message: offerMessage
		});
		agentContext.config.logger.debug("Saving credential record and emit offer-received event");
		await credentialRepository.save(messageContext.agentContext, credentialExchangeRecord);
		this.emitStateChangedEvent(messageContext.agentContext, credentialExchangeRecord, null);
		return credentialExchangeRecord;
	}
	async acceptOffer(agentContext, { credentialExchangeRecord, autoAcceptCredential, comment, goal, goalCode, credentialFormats }) {
		const didCommMessageRepository = agentContext.dependencyManager.resolve(DidCommMessageRepository);
		credentialExchangeRecord.assertProtocolVersion("v2");
		credentialExchangeRecord.assertState(DidCommCredentialState.OfferReceived);
		let formatServices = this.getFormatServices(credentialFormats ?? {});
		if (formatServices.length === 0) {
			const offerMessage = await didCommMessageRepository.getAgentMessage(agentContext, {
				associatedRecordId: credentialExchangeRecord.id,
				messageClass: DidCommOfferCredentialV2Message,
				role: DidCommMessageRole.Receiver
			});
			formatServices = this.getFormatServicesFromMessage(offerMessage.formats);
		}
		if (formatServices.length === 0) throw new CredoError("Unable to accept offer. No supported formats provided as input or in offer message");
		const message = await this.credentialFormatCoordinator.acceptOffer(agentContext, {
			credentialExchangeRecord,
			formatServices,
			comment,
			goal,
			goalCode,
			credentialFormats
		});
		credentialExchangeRecord.autoAcceptCredential = autoAcceptCredential ?? credentialExchangeRecord.autoAcceptCredential;
		await this.updateState(agentContext, credentialExchangeRecord, DidCommCredentialState.RequestSent);
		return {
			credentialExchangeRecord,
			message
		};
	}
	/**
	* Create a {@link ProposePresentationMessage} as response to a received credential offer.
	* To create a proposal not bound to an existing credential exchange, use {@link createProposal}.
	*
	* @param options configuration to use for the proposal
	* @returns Object containing proposal message and associated credential record
	*
	*/
	async negotiateOffer(agentContext, { credentialExchangeRecord, credentialFormats, autoAcceptCredential, comment, goal, goalCode }) {
		credentialExchangeRecord.assertProtocolVersion("v2");
		credentialExchangeRecord.assertState(DidCommCredentialState.OfferReceived);
		if (!credentialExchangeRecord.connectionId) throw new CredoError(`No connectionId found for credential record '${credentialExchangeRecord.id}'. Connection-less issuance does not support negotiation.`);
		const formatServices = this.getFormatServices(credentialFormats);
		if (formatServices.length === 0) throw new CredoError("Unable to create proposal. No supported formats");
		const proposalMessage = await this.credentialFormatCoordinator.createProposal(agentContext, {
			formatServices,
			credentialFormats,
			credentialExchangeRecord,
			comment,
			goal,
			goalCode
		});
		credentialExchangeRecord.autoAcceptCredential = autoAcceptCredential ?? credentialExchangeRecord.autoAcceptCredential;
		await this.updateState(agentContext, credentialExchangeRecord, DidCommCredentialState.ProposalSent);
		return {
			credentialExchangeRecord,
			message: proposalMessage
		};
	}
	/**
	* Create a {@link DidCommRequestCredentialV2Message} as beginning of protocol process.
	* @returns Object containing offer message and associated credential record
	*
	*/
	async createRequest(agentContext, { credentialFormats, autoAcceptCredential, comment, goal, goalCode, connectionRecord }) {
		const credentialRepository = agentContext.dependencyManager.resolve(DidCommCredentialExchangeRepository);
		const formatServices = this.getFormatServices(credentialFormats);
		if (formatServices.length === 0) throw new CredoError("Unable to create request. No supported formats");
		const credentialExchangeRecord = new DidCommCredentialExchangeRecord({
			connectionId: connectionRecord.id,
			threadId: utils.uuid(),
			state: DidCommCredentialState.RequestSent,
			role: DidCommCredentialRole.Holder,
			autoAcceptCredential,
			protocolVersion: "v2"
		});
		const requestMessage = await this.credentialFormatCoordinator.createRequest(agentContext, {
			formatServices,
			credentialFormats,
			credentialExchangeRecord,
			comment,
			goal,
			goalCode
		});
		agentContext.config.logger.debug(`Saving record and emitting state changed for credential exchange record ${credentialExchangeRecord.id}`);
		await credentialRepository.save(agentContext, credentialExchangeRecord);
		this.emitStateChangedEvent(agentContext, credentialExchangeRecord, null);
		return {
			credentialExchangeRecord,
			message: requestMessage
		};
	}
	/**
	* Process a received {@link RequestCredentialMessage}. This will not accept the credential request
	* or send a credential. It will only update the existing credential record with
	* the information from the credential request message. Use {@link createCredential}
	* after calling this method to create a credential.
	*z
	* @param messageContext The message context containing a v2 credential request message
	* @returns credential record associated with the credential request message
	*
	*/
	async processRequest(messageContext) {
		const { message: requestMessage, connection, agentContext } = messageContext;
		const credentialRepository = agentContext.dependencyManager.resolve(DidCommCredentialExchangeRepository);
		const didCommMessageRepository = agentContext.dependencyManager.resolve(DidCommMessageRepository);
		const connectionService = agentContext.dependencyManager.resolve(DidCommConnectionService);
		agentContext.config.logger.debug(`Processing credential request with id ${requestMessage.id}`);
		let credentialExchangeRecord = await this.findByProperties(messageContext.agentContext, {
			threadId: requestMessage.threadId,
			role: DidCommCredentialRole.Issuer
		});
		const formatServices = this.getFormatServicesFromMessage(requestMessage.formats);
		if (formatServices.length === 0) throw new CredoError("Unable to process request. No supported formats");
		if (credentialExchangeRecord) {
			const proposalMessage = await didCommMessageRepository.findAgentMessage(messageContext.agentContext, {
				associatedRecordId: credentialExchangeRecord.id,
				messageClass: DidCommProposeCredentialV2Message,
				role: DidCommMessageRole.Receiver
			});
			const offerMessage = await didCommMessageRepository.findAgentMessage(messageContext.agentContext, {
				associatedRecordId: credentialExchangeRecord.id,
				messageClass: DidCommOfferCredentialV2Message,
				role: DidCommMessageRole.Sender
			});
			credentialExchangeRecord.assertProtocolVersion("v2");
			credentialExchangeRecord.assertState(DidCommCredentialState.OfferSent);
			await connectionService.assertConnectionOrOutOfBandExchange(messageContext, {
				lastReceivedMessage: proposalMessage ?? void 0,
				lastSentMessage: offerMessage ?? void 0,
				expectedConnectionId: credentialExchangeRecord.connectionId
			});
			if (!credentialExchangeRecord.connectionId) {
				await connectionService.matchIncomingMessageToRequestMessageInOutOfBandExchange(messageContext, { expectedConnectionId: credentialExchangeRecord.connectionId });
				credentialExchangeRecord.connectionId = connection?.id;
			}
			await this.credentialFormatCoordinator.processRequest(messageContext.agentContext, {
				credentialExchangeRecord,
				formatServices,
				message: requestMessage
			});
			await this.updateState(messageContext.agentContext, credentialExchangeRecord, DidCommCredentialState.RequestReceived);
			return credentialExchangeRecord;
		}
		await connectionService.assertConnectionOrOutOfBandExchange(messageContext);
		agentContext.config.logger.debug("No credential record found for request, creating a new one");
		credentialExchangeRecord = new DidCommCredentialExchangeRecord({
			connectionId: connection?.id,
			threadId: requestMessage.threadId,
			parentThreadId: requestMessage.thread?.parentThreadId,
			state: DidCommCredentialState.RequestReceived,
			role: DidCommCredentialRole.Issuer,
			protocolVersion: "v2"
		});
		await this.credentialFormatCoordinator.processRequest(messageContext.agentContext, {
			credentialExchangeRecord,
			formatServices,
			message: requestMessage
		});
		agentContext.config.logger.debug("Saving credential record and emit request-received event");
		await credentialRepository.save(messageContext.agentContext, credentialExchangeRecord);
		this.emitStateChangedEvent(messageContext.agentContext, credentialExchangeRecord, null);
		return credentialExchangeRecord;
	}
	async acceptRequest(agentContext, { credentialExchangeRecord, autoAcceptCredential, comment, goal, goalCode, credentialFormats }) {
		const didCommMessageRepository = agentContext.dependencyManager.resolve(DidCommMessageRepository);
		credentialExchangeRecord.assertProtocolVersion("v2");
		credentialExchangeRecord.assertState(DidCommCredentialState.RequestReceived);
		let formatServices = this.getFormatServices(credentialFormats ?? {});
		if (formatServices.length === 0) {
			const requestMessage = await didCommMessageRepository.getAgentMessage(agentContext, {
				associatedRecordId: credentialExchangeRecord.id,
				messageClass: DidCommRequestCredentialV2Message,
				role: DidCommMessageRole.Receiver
			});
			formatServices = this.getFormatServicesFromMessage(requestMessage.formats);
		}
		if (formatServices.length === 0) throw new CredoError("Unable to accept request. No supported formats provided as input or in request message");
		const message = await this.credentialFormatCoordinator.acceptRequest(agentContext, {
			credentialExchangeRecord,
			formatServices,
			comment,
			goal,
			goalCode,
			credentialFormats
		});
		credentialExchangeRecord.autoAcceptCredential = autoAcceptCredential ?? credentialExchangeRecord.autoAcceptCredential;
		await this.updateState(agentContext, credentialExchangeRecord, DidCommCredentialState.CredentialIssued);
		return {
			credentialExchangeRecord,
			message
		};
	}
	/**
	* Process a received {@link DidCommIssueCredentialV2Message}. This will not accept the credential
	* or send a credential acknowledgement. It will only update the existing credential record with
	* the information from the issue credential message. Use {@link createAck}
	* after calling this method to create a credential acknowledgement.
	*
	* @param messageContext The message context containing an issue credential message
	*
	* @returns credential record associated with the issue credential message
	*
	*/
	async processCredential(messageContext) {
		const { message: credentialMessage, connection, agentContext } = messageContext;
		const didCommMessageRepository = agentContext.dependencyManager.resolve(DidCommMessageRepository);
		const connectionService = agentContext.dependencyManager.resolve(DidCommConnectionService);
		agentContext.config.logger.debug(`Processing credential with id ${credentialMessage.id}`);
		const credentialExchangeRecord = await this.getByProperties(messageContext.agentContext, {
			threadId: credentialMessage.threadId,
			role: DidCommCredentialRole.Holder,
			connectionId: connection?.id
		});
		const requestMessage = await didCommMessageRepository.getAgentMessage(messageContext.agentContext, {
			associatedRecordId: credentialExchangeRecord.id,
			messageClass: DidCommRequestCredentialV2Message,
			role: DidCommMessageRole.Sender
		});
		const offerMessage = await didCommMessageRepository.findAgentMessage(messageContext.agentContext, {
			associatedRecordId: credentialExchangeRecord.id,
			messageClass: DidCommOfferCredentialV2Message,
			role: DidCommMessageRole.Receiver
		});
		credentialExchangeRecord.assertProtocolVersion("v2");
		credentialExchangeRecord.assertState(DidCommCredentialState.RequestSent);
		await connectionService.assertConnectionOrOutOfBandExchange(messageContext, {
			lastReceivedMessage: offerMessage ?? void 0,
			lastSentMessage: requestMessage,
			expectedConnectionId: credentialExchangeRecord.connectionId
		});
		const formatServices = this.getFormatServicesFromMessage(credentialMessage.formats);
		if (formatServices.length === 0) throw new CredoError("Unable to process credential. No supported formats");
		await this.credentialFormatCoordinator.processCredential(messageContext.agentContext, {
			credentialExchangeRecord,
			formatServices,
			requestMessage,
			message: credentialMessage
		});
		await this.updateState(messageContext.agentContext, credentialExchangeRecord, DidCommCredentialState.CredentialReceived);
		return credentialExchangeRecord;
	}
	/**
	* Create a {@link DidCommCredentialV2AckMessage} as response to a received credential.
	*
	* @param credentialExchangeRecord The credential record for which to create the credential acknowledgement
	* @returns Object containing credential acknowledgement message and associated credential record
	*
	*/
	async acceptCredential(agentContext, { credentialExchangeRecord }) {
		credentialExchangeRecord.assertProtocolVersion("v2");
		credentialExchangeRecord.assertState(DidCommCredentialState.CredentialReceived);
		const ackMessage = new DidCommCredentialV2AckMessage({
			status: AckStatus.OK,
			threadId: credentialExchangeRecord.threadId
		});
		ackMessage.setThread({
			threadId: credentialExchangeRecord.threadId,
			parentThreadId: credentialExchangeRecord.parentThreadId
		});
		await this.updateState(agentContext, credentialExchangeRecord, DidCommCredentialState.Done);
		return {
			message: ackMessage,
			credentialExchangeRecord
		};
	}
	/**
	* Process a received {@link CredentialAckMessage}.
	*
	* @param messageContext The message context containing a credential acknowledgement message
	* @returns credential record associated with the credential acknowledgement message
	*
	*/
	async processAck(messageContext) {
		const { message: ackMessage, connection, agentContext } = messageContext;
		agentContext.config.logger.debug(`Processing credential ack with id ${ackMessage.id}`);
		const didCommMessageRepository = agentContext.dependencyManager.resolve(DidCommMessageRepository);
		const connectionService = agentContext.dependencyManager.resolve(DidCommConnectionService);
		const credentialExchangeRecord = await this.getByProperties(messageContext.agentContext, {
			threadId: ackMessage.threadId,
			role: DidCommCredentialRole.Issuer,
			connectionId: connection?.id
		});
		credentialExchangeRecord.connectionId = connection?.id;
		const requestMessage = await didCommMessageRepository.getAgentMessage(messageContext.agentContext, {
			associatedRecordId: credentialExchangeRecord.id,
			messageClass: DidCommRequestCredentialV2Message,
			role: DidCommMessageRole.Receiver
		});
		const credentialMessage = await didCommMessageRepository.getAgentMessage(messageContext.agentContext, {
			associatedRecordId: credentialExchangeRecord.id,
			messageClass: DidCommIssueCredentialV2Message,
			role: DidCommMessageRole.Sender
		});
		credentialExchangeRecord.assertProtocolVersion("v2");
		credentialExchangeRecord.assertState(DidCommCredentialState.CredentialIssued);
		await connectionService.assertConnectionOrOutOfBandExchange(messageContext, {
			lastReceivedMessage: requestMessage,
			lastSentMessage: credentialMessage,
			expectedConnectionId: credentialExchangeRecord.connectionId
		});
		await this.updateState(messageContext.agentContext, credentialExchangeRecord, DidCommCredentialState.Done);
		return credentialExchangeRecord;
	}
	/**
	* Create a {@link DidCommCredentialV2ProblemReportMessage} to be sent.
	*
	* @param message message to send
	* @returns a {@link DidCommCredentialV2ProblemReportMessage}
	*
	*/
	async createProblemReport(_agentContext, { credentialExchangeRecord, description }) {
		const message = new DidCommCredentialV2ProblemReportMessage({ description: {
			en: description,
			code: DidCommCredentialProblemReportReason.IssuanceAbandoned
		} });
		message.setThread({
			threadId: credentialExchangeRecord.threadId,
			parentThreadId: credentialExchangeRecord.parentThreadId
		});
		return {
			credentialExchangeRecord,
			message
		};
	}
	async shouldAutoRespondToProposal(agentContext, options) {
		const { credentialExchangeRecord, proposalMessage } = options;
		const credentialsModuleConfig = agentContext.dependencyManager.resolve(DidCommCredentialsModuleConfig);
		const autoAccept = composeAutoAccept(credentialExchangeRecord.autoAcceptCredential, credentialsModuleConfig.autoAcceptCredentials);
		if (autoAccept === DidCommAutoAcceptCredential.Always) return true;
		if (autoAccept === DidCommAutoAcceptCredential.Never) return false;
		const offerMessage = await this.findOfferMessage(agentContext, credentialExchangeRecord.id);
		if (!offerMessage) return false;
		const formatServices = this.getFormatServicesFromMessage(offerMessage.formats);
		for (const formatService of formatServices) {
			const offerAttachment = this.credentialFormatCoordinator.getAttachmentForService(formatService, offerMessage.formats, offerMessage.offerAttachments);
			const proposalAttachment = this.credentialFormatCoordinator.getAttachmentForService(formatService, proposalMessage.formats, proposalMessage.proposalAttachments);
			if (!await formatService.shouldAutoRespondToProposal(agentContext, {
				credentialExchangeRecord,
				offerAttachment,
				proposalAttachment
			})) return false;
		}
		if (proposalMessage.credentialPreview || offerMessage.credentialPreview) {
			if (!proposalMessage.credentialPreview || !offerMessage.credentialPreview) return false;
			return arePreviewAttributesEqual(proposalMessage.credentialPreview.attributes, offerMessage.credentialPreview.attributes);
		}
		return true;
	}
	async shouldAutoRespondToOffer(agentContext, options) {
		const { credentialExchangeRecord, offerMessage } = options;
		const credentialsModuleConfig = agentContext.dependencyManager.resolve(DidCommCredentialsModuleConfig);
		const autoAccept = composeAutoAccept(credentialExchangeRecord.autoAcceptCredential, credentialsModuleConfig.autoAcceptCredentials);
		if (autoAccept === DidCommAutoAcceptCredential.Always) return true;
		if (autoAccept === DidCommAutoAcceptCredential.Never) return false;
		const proposalMessage = await this.findProposalMessage(agentContext, credentialExchangeRecord.id);
		if (!proposalMessage) return false;
		const formatServices = this.getFormatServicesFromMessage(proposalMessage.formats);
		for (const formatService of formatServices) {
			const offerAttachment = this.credentialFormatCoordinator.getAttachmentForService(formatService, offerMessage.formats, offerMessage.offerAttachments);
			const proposalAttachment = this.credentialFormatCoordinator.getAttachmentForService(formatService, proposalMessage.formats, proposalMessage.proposalAttachments);
			if (!await formatService.shouldAutoRespondToOffer(agentContext, {
				credentialExchangeRecord,
				offerAttachment,
				proposalAttachment
			})) return false;
		}
		if (proposalMessage.credentialPreview || offerMessage.credentialPreview) return arePreviewAttributesEqual(proposalMessage.credentialPreview?.attributes ?? [], offerMessage.credentialPreview?.attributes ?? []);
		return true;
	}
	async shouldAutoRespondToRequest(agentContext, options) {
		const { credentialExchangeRecord, requestMessage } = options;
		const credentialsModuleConfig = agentContext.dependencyManager.resolve(DidCommCredentialsModuleConfig);
		const autoAccept = composeAutoAccept(credentialExchangeRecord.autoAcceptCredential, credentialsModuleConfig.autoAcceptCredentials);
		if (autoAccept === DidCommAutoAcceptCredential.Always) return true;
		if (autoAccept === DidCommAutoAcceptCredential.Never) return false;
		const proposalMessage = await this.findProposalMessage(agentContext, credentialExchangeRecord.id);
		const offerMessage = await this.findOfferMessage(agentContext, credentialExchangeRecord.id);
		if (!offerMessage) return false;
		const formatServices = this.getFormatServicesFromMessage(offerMessage.formats);
		for (const formatService of formatServices) {
			const offerAttachment = this.credentialFormatCoordinator.getAttachmentForService(formatService, offerMessage.formats, offerMessage.offerAttachments);
			const proposalAttachment = proposalMessage ? this.credentialFormatCoordinator.getAttachmentForService(formatService, proposalMessage.formats, proposalMessage.proposalAttachments) : void 0;
			const requestAttachment = this.credentialFormatCoordinator.getAttachmentForService(formatService, requestMessage.formats, requestMessage.requestAttachments);
			if (!await formatService.shouldAutoRespondToRequest(agentContext, {
				credentialExchangeRecord,
				offerAttachment,
				requestAttachment,
				proposalAttachment
			})) return false;
		}
		return true;
	}
	async shouldAutoRespondToCredential(agentContext, options) {
		const { credentialExchangeRecord, credentialMessage } = options;
		const credentialsModuleConfig = agentContext.dependencyManager.resolve(DidCommCredentialsModuleConfig);
		const autoAccept = composeAutoAccept(credentialExchangeRecord.autoAcceptCredential, credentialsModuleConfig.autoAcceptCredentials);
		if (autoAccept === DidCommAutoAcceptCredential.Always) return true;
		if (autoAccept === DidCommAutoAcceptCredential.Never) return false;
		const proposalMessage = await this.findProposalMessage(agentContext, credentialExchangeRecord.id);
		const offerMessage = await this.findOfferMessage(agentContext, credentialExchangeRecord.id);
		const requestMessage = await this.findRequestMessage(agentContext, credentialExchangeRecord.id);
		if (!requestMessage) return false;
		const formatServices = this.getFormatServicesFromMessage(requestMessage.formats);
		for (const formatService of formatServices) {
			const offerAttachment = offerMessage ? this.credentialFormatCoordinator.getAttachmentForService(formatService, offerMessage.formats, offerMessage.offerAttachments) : void 0;
			const proposalAttachment = proposalMessage ? this.credentialFormatCoordinator.getAttachmentForService(formatService, proposalMessage.formats, proposalMessage.proposalAttachments) : void 0;
			const requestAttachment = this.credentialFormatCoordinator.getAttachmentForService(formatService, requestMessage.formats, requestMessage.requestAttachments);
			const credentialAttachment = this.credentialFormatCoordinator.getAttachmentForService(formatService, credentialMessage.formats, credentialMessage.credentialAttachments);
			if (!await formatService.shouldAutoRespondToCredential(agentContext, {
				credentialExchangeRecord,
				offerAttachment,
				credentialAttachment,
				requestAttachment,
				proposalAttachment
			})) return false;
		}
		return true;
	}
	async findProposalMessage(agentContext, credentialExchangeId) {
		return agentContext.dependencyManager.resolve(DidCommMessageRepository).findAgentMessage(agentContext, {
			associatedRecordId: credentialExchangeId,
			messageClass: DidCommProposeCredentialV2Message
		});
	}
	async findOfferMessage(agentContext, credentialExchangeId) {
		return await agentContext.dependencyManager.resolve(DidCommMessageRepository).findAgentMessage(agentContext, {
			associatedRecordId: credentialExchangeId,
			messageClass: DidCommOfferCredentialV2Message
		});
	}
	async findRequestMessage(agentContext, credentialExchangeId) {
		return await agentContext.dependencyManager.resolve(DidCommMessageRepository).findAgentMessage(agentContext, {
			associatedRecordId: credentialExchangeId,
			messageClass: DidCommRequestCredentialV2Message
		});
	}
	async findCredentialMessage(agentContext, credentialExchangeId) {
		return await agentContext.dependencyManager.resolve(DidCommMessageRepository).findAgentMessage(agentContext, {
			associatedRecordId: credentialExchangeId,
			messageClass: DidCommIssueCredentialV2Message
		});
	}
	async getFormatData(agentContext, credentialExchangeId) {
		const [proposalMessage, offerMessage, requestMessage, credentialMessage] = await Promise.all([
			this.findProposalMessage(agentContext, credentialExchangeId),
			this.findOfferMessage(agentContext, credentialExchangeId),
			this.findRequestMessage(agentContext, credentialExchangeId),
			this.findCredentialMessage(agentContext, credentialExchangeId)
		]);
		const messages = {
			proposal: [proposalMessage?.formats, proposalMessage?.proposalAttachments],
			offer: [offerMessage?.formats, offerMessage?.offerAttachments],
			request: [requestMessage?.formats, requestMessage?.requestAttachments],
			credential: [credentialMessage?.formats, credentialMessage?.credentialAttachments]
		};
		const formatData = {
			proposalAttributes: proposalMessage?.credentialPreview?.attributes,
			offerAttributes: offerMessage?.credentialPreview?.attributes
		};
		for (const [messageKey, [formats, attachments]] of Object.entries(messages)) {
			if (!formats || !attachments) continue;
			const formatServices = this.getFormatServicesFromMessage(formats);
			const messageFormatData = {};
			for (const formatService of formatServices) {
				const attachment = this.credentialFormatCoordinator.getAttachmentForService(formatService, formats, attachments);
				messageFormatData[formatService.formatKey] = attachment.getDataAsJson();
			}
			formatData[messageKey] = messageFormatData;
		}
		return formatData;
	}
	/**
	* Get all the format service objects for a given credential format from an incoming message
	* @param messageFormats the format objects containing the format name (eg indy)
	* @return the credential format service objects in an array - derived from format object keys
	*/
	getFormatServicesFromMessage(messageFormats) {
		const formatServices = /* @__PURE__ */ new Set();
		for (const msg of messageFormats) {
			const service = this.getFormatServiceForFormat(msg.format);
			if (service) formatServices.add(service);
		}
		return Array.from(formatServices);
	}
	/**
	* Get all the format service objects for a given credential format
	* @param credentialFormats the format object containing various optional parameters
	* @return the credential format service objects in an array - derived from format object keys
	*/
	getFormatServices(credentialFormats) {
		const formats = /* @__PURE__ */ new Set();
		for (const formatKey of Object.keys(credentialFormats)) {
			const formatService = this.getFormatServiceForFormatKey(formatKey);
			if (formatService) formats.add(formatService);
		}
		return Array.from(formats);
	}
	getFormatServiceForFormatKey(formatKey) {
		return this.credentialFormats.find((credentialFormat) => credentialFormat.formatKey === formatKey) ?? null;
	}
	getFormatServiceForFormat(format) {
		return this.credentialFormats.find((credentialFormat) => credentialFormat.supportsFormat(format)) ?? null;
	}
	getFormatServiceForRecordType(credentialRecordType) {
		const formatService = this.credentialFormats.find((credentialFormat) => credentialFormat.credentialRecordType === credentialRecordType);
		if (!formatService) throw new CredoError(`No format service found for credential record type ${credentialRecordType} in v2 credential protocol`);
		return formatService;
	}
};

//#endregion
export { DidCommCredentialV2Protocol };
//# sourceMappingURL=DidCommCredentialV2Protocol.mjs.map