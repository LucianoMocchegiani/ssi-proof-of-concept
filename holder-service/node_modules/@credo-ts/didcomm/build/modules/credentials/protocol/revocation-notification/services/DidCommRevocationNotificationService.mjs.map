{"version":3,"file":"DidCommRevocationNotificationService.mjs","names":[],"sources":["../../../../../../src/modules/credentials/protocol/revocation-notification/services/DidCommRevocationNotificationService.ts"],"sourcesContent":["import type { AgentContext } from '@credo-ts/core'\nimport { CredoError, EventEmitter, InjectionSymbols, inject, injectable, type Logger } from '@credo-ts/core'\nimport type { DidCommInboundMessageContext } from '../../../../../models'\nimport { DidCommConnectionRecord } from '../../../../connections'\nimport type { DidCommRevocationNotificationReceivedEvent } from '../../../DidCommCredentialEvents'\nimport { DidCommCredentialEventTypes } from '../../../DidCommCredentialEvents'\nimport { DidCommRevocationNotification } from '../../../models/DidCommRevocationNotification'\nimport { DidCommCredentialExchangeRepository } from '../../../repository'\nimport type { DidCommRevocationNotificationV1Message } from '../messages/DidCommRevocationNotificationV1Message'\nimport { DidCommRevocationNotificationV2Message } from '../messages/DidCommRevocationNotificationV2Message'\nimport {\n  v1ThreadRegex,\n  v2AnonCredsRevocationFormat,\n  v2AnonCredsRevocationIdentifierRegex,\n  v2IndyRevocationFormat,\n  v2IndyRevocationIdentifierRegex,\n} from '../util/revocationIdentifier'\nimport type { V2DidCommCreateRevocationNotificationMessageOptions } from './DidCommRevocationNotificationServiceOptions'\n\n@injectable()\nexport class DidCommRevocationNotificationService {\n  private credentialRepository: DidCommCredentialExchangeRepository\n  private eventEmitter: EventEmitter\n  private logger: Logger\n\n  public constructor(\n    credentialRepository: DidCommCredentialExchangeRepository,\n    eventEmitter: EventEmitter,\n    @inject(InjectionSymbols.Logger) logger: Logger\n  ) {\n    this.credentialRepository = credentialRepository\n    this.eventEmitter = eventEmitter\n    this.logger = logger\n  }\n\n  private async processRevocationNotification(\n    agentContext: AgentContext,\n    anonCredsRevocationRegistryId: string,\n    anonCredsCredentialRevocationId: string,\n    connection: DidCommConnectionRecord,\n    comment?: string\n  ) {\n    // TODO: can we extract support for this revocation notification handler to the anoncreds module?\n    // Search for the revocation registry in both qualified and unqualified forms\n    const query = {\n      $or: [\n        {\n          anonCredsRevocationRegistryId,\n          anonCredsCredentialRevocationId,\n          connectionId: connection.id,\n        },\n        {\n          anonCredsUnqualifiedRevocationRegistryId: anonCredsRevocationRegistryId,\n          anonCredsCredentialRevocationId,\n          connectionId: connection.id,\n        },\n      ],\n    }\n\n    this.logger.trace('Getting record by query for revocation notification:', query)\n    const credentialExchangeRecord = await this.credentialRepository.getSingleByQuery(agentContext, query)\n\n    credentialExchangeRecord.revocationNotification = new DidCommRevocationNotification(comment)\n    await this.credentialRepository.update(agentContext, credentialExchangeRecord)\n\n    this.logger.trace('Emitting DidCommRevocationNotificationReceivedEvent')\n    this.eventEmitter.emit<DidCommRevocationNotificationReceivedEvent>(agentContext, {\n      type: DidCommCredentialEventTypes.DidCommRevocationNotificationReceived,\n      payload: {\n        // Clone record to prevent mutations after emitting event.\n        credentialExchangeRecord: credentialExchangeRecord.clone(),\n      },\n    })\n  }\n\n  /**\n   * Process a received {@link DidCommRevocationNotificationV1Message}. This will create a\n   * {@link DidCommRevocationNotification} and store it in the corresponding {@link CredentialRecord}\n   *\n   * @param messageContext message context of RevocationNotificationMessageV1\n   */\n  public async v1ProcessRevocationNotification(\n    messageContext: DidCommInboundMessageContext<DidCommRevocationNotificationV1Message>\n  ): Promise<void> {\n    this.logger.info('Processing revocation notification v1', { message: messageContext.message })\n\n    // ThreadID = indy::<revocation_registry_id>::<credential_revocation_id>\n    const threadId = messageContext.message.issueThread\n\n    try {\n      const threadIdGroups = threadId.match(v1ThreadRegex)\n      if (!threadIdGroups) {\n        throw new CredoError(\n          `Incorrect revocation notification threadId format: \\n${threadId}\\ndoes not match\\n\"indy::<revocation_registry_id>::<credential_revocation_id>\"`\n        )\n      }\n\n      const [, , anonCredsRevocationRegistryId, anonCredsCredentialRevocationId] = threadIdGroups\n      const comment = messageContext.message.comment\n      const connection = messageContext.assertReadyConnection()\n\n      await this.processRevocationNotification(\n        messageContext.agentContext,\n        anonCredsRevocationRegistryId,\n        anonCredsCredentialRevocationId,\n        connection,\n        comment\n      )\n    } catch (error) {\n      this.logger.warn('Failed to process revocation notification message', { error, threadId })\n    }\n  }\n\n  /**\n   * Create a V2 Revocation Notification message\n   */\n\n  public async v2CreateRevocationNotification(\n    options: V2DidCommCreateRevocationNotificationMessageOptions\n  ): Promise<{ message: DidCommRevocationNotificationV2Message }> {\n    const { credentialId, revocationFormat, comment, requestAck } = options\n    const message = new DidCommRevocationNotificationV2Message({\n      credentialId,\n      revocationFormat,\n      comment,\n    })\n    if (requestAck) {\n      message.setPleaseAck()\n    }\n\n    return { message }\n  }\n\n  /**\n   * Process a received {@link DidCommRevocationNotificationV2Message}. This will create a\n   * {@link DidCommRevocationNotification} and store it in the corresponding {@link CredentialRecord}\n   *\n   * @param messageContext message context of RevocationNotificationMessageV2\n   */\n  public async v2ProcessRevocationNotification(\n    messageContext: DidCommInboundMessageContext<DidCommRevocationNotificationV2Message>\n  ): Promise<void> {\n    this.logger.info('Processing revocation notification v2', { message: messageContext.message })\n\n    const credentialId = messageContext.message.credentialId\n\n    if (![v2IndyRevocationFormat, v2AnonCredsRevocationFormat].includes(messageContext.message.revocationFormat)) {\n      throw new CredoError(\n        `Unknown revocation format: ${messageContext.message.revocationFormat}. Supported formats are indy-anoncreds and anoncreds`\n      )\n    }\n\n    try {\n      const credentialIdGroups =\n        credentialId.match(v2IndyRevocationIdentifierRegex) ?? credentialId.match(v2AnonCredsRevocationIdentifierRegex)\n      if (!credentialIdGroups) {\n        throw new CredoError(\n          `Incorrect revocation notification credentialId format: \\n${credentialId}\\ndoes not match\\n\"<revocation_registry_id>::<credential_revocation_id>\"`\n        )\n      }\n\n      const [, anonCredsRevocationRegistryId, anonCredsCredentialRevocationId] = credentialIdGroups\n      const comment = messageContext.message.comment\n      const connection = messageContext.assertReadyConnection()\n      await this.processRevocationNotification(\n        messageContext.agentContext,\n        anonCredsRevocationRegistryId,\n        anonCredsCredentialRevocationId,\n        connection,\n        comment\n      )\n    } catch (error) {\n      this.logger.warn('Failed to process revocation notification message', { error, credentialId })\n    }\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;AAoBO,iDAAM,qCAAqC;CAKhD,AAAO,YACL,sBACA,cACA,AAAiC,QACjC;AACA,OAAK,uBAAuB;AAC5B,OAAK,eAAe;AACpB,OAAK,SAAS;;CAGhB,MAAc,8BACZ,cACA,+BACA,iCACA,YACA,SACA;EAGA,MAAM,QAAQ,EACZ,KAAK,CACH;GACE;GACA;GACA,cAAc,WAAW;GAC1B,EACD;GACE,0CAA0C;GAC1C;GACA,cAAc,WAAW;GAC1B,CACF,EACF;AAED,OAAK,OAAO,MAAM,wDAAwD,MAAM;EAChF,MAAM,2BAA2B,MAAM,KAAK,qBAAqB,iBAAiB,cAAc,MAAM;AAEtG,2BAAyB,yBAAyB,IAAI,8BAA8B,QAAQ;AAC5F,QAAM,KAAK,qBAAqB,OAAO,cAAc,yBAAyB;AAE9E,OAAK,OAAO,MAAM,sDAAsD;AACxE,OAAK,aAAa,KAAiD,cAAc;GAC/E,MAAM,4BAA4B;GAClC,SAAS,EAEP,0BAA0B,yBAAyB,OAAO,EAC3D;GACF,CAAC;;;;;;;;CASJ,MAAa,gCACX,gBACe;AACf,OAAK,OAAO,KAAK,yCAAyC,EAAE,SAAS,eAAe,SAAS,CAAC;EAG9F,MAAM,WAAW,eAAe,QAAQ;AAExC,MAAI;GACF,MAAM,iBAAiB,SAAS,MAAM,cAAc;AACpD,OAAI,CAAC,eACH,OAAM,IAAI,WACR,wDAAwD,SAAS,gFAClE;GAGH,MAAM,KAAK,+BAA+B,mCAAmC;GAC7E,MAAM,UAAU,eAAe,QAAQ;GACvC,MAAM,aAAa,eAAe,uBAAuB;AAEzD,SAAM,KAAK,8BACT,eAAe,cACf,+BACA,iCACA,YACA,QACD;WACM,OAAO;AACd,QAAK,OAAO,KAAK,qDAAqD;IAAE;IAAO;IAAU,CAAC;;;;;;CAQ9F,MAAa,+BACX,SAC8D;EAC9D,MAAM,EAAE,cAAc,kBAAkB,SAAS,eAAe;EAChE,MAAM,UAAU,IAAI,uCAAuC;GACzD;GACA;GACA;GACD,CAAC;AACF,MAAI,WACF,SAAQ,cAAc;AAGxB,SAAO,EAAE,SAAS;;;;;;;;CASpB,MAAa,gCACX,gBACe;AACf,OAAK,OAAO,KAAK,yCAAyC,EAAE,SAAS,eAAe,SAAS,CAAC;EAE9F,MAAM,eAAe,eAAe,QAAQ;AAE5C,MAAI,CAAC,CAAC,wBAAwB,4BAA4B,CAAC,SAAS,eAAe,QAAQ,iBAAiB,CAC1G,OAAM,IAAI,WACR,8BAA8B,eAAe,QAAQ,iBAAiB,sDACvE;AAGH,MAAI;GACF,MAAM,qBACJ,aAAa,MAAM,gCAAgC,IAAI,aAAa,MAAM,qCAAqC;AACjH,OAAI,CAAC,mBACH,OAAM,IAAI,WACR,4DAA4D,aAAa,0EAC1E;GAGH,MAAM,GAAG,+BAA+B,mCAAmC;GAC3E,MAAM,UAAU,eAAe,QAAQ;GACvC,MAAM,aAAa,eAAe,uBAAuB;AACzD,SAAM,KAAK,8BACT,eAAe,cACf,+BACA,iCACA,YACA,QACD;WACM,OAAO;AACd,QAAK,OAAO,KAAK,qDAAqD;IAAE;IAAO;IAAc,CAAC;;;;;CAzJnG,YAAY;oBASR,OAAO,iBAAiB,OAAO"}