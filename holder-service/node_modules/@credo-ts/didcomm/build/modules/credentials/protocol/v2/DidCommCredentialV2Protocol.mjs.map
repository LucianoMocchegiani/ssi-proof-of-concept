{"version":3,"file":"DidCommCredentialV2Protocol.mjs","names":[],"sources":["../../../../../src/modules/credentials/protocol/v2/DidCommCredentialV2Protocol.ts"],"sourcesContent":["import type { AgentContext } from '@credo-ts/core'\nimport { CredoError, utils } from '@credo-ts/core'\nimport type { DidCommFeatureRegistry } from '../../../../DidCommFeatureRegistry'\nimport type { DidCommMessage } from '../../../../DidCommMessage'\nimport type { DidCommMessageHandlerRegistry } from '../../../../DidCommMessageHandlerRegistry'\nimport type { DidCommMessageHandlerInboundMessage } from '../../../../handlers'\nimport type { DidCommProblemReportMessage } from '../../../../messages'\nimport { AckStatus } from '../../../../messages'\nimport type { DidCommInboundMessageContext } from '../../../../models'\nimport { DidCommProtocol } from '../../../../models'\nimport { DidCommMessageRepository, DidCommMessageRole } from '../../../../repository'\nimport { DidCommConnectionService } from '../../../connections'\nimport { DidCommCredentialsModuleConfig } from '../../DidCommCredentialsModuleConfig'\nimport type {\n  DidCommCredentialFormat,\n  DidCommCredentialFormatPayload,\n  DidCommCredentialFormatService,\n  ExtractCredentialFormats,\n} from '../../formats'\nimport {\n  DidCommAutoAcceptCredential,\n  DidCommCredentialProblemReportReason,\n  DidCommCredentialRole,\n  DidCommCredentialState,\n} from '../../models'\nimport type { DidCommCredentialFormatSpec } from '../../models/DidCommCredentialFormatSpec'\nimport { DidCommCredentialExchangeRecord, DidCommCredentialExchangeRepository } from '../../repository'\nimport { composeAutoAccept } from '../../util/composeAutoAccept'\nimport { arePreviewAttributesEqual } from '../../util/previewAttributes'\nimport { DidCommBaseCredentialProtocol } from '../DidCommBaseCredentialProtocol'\nimport type { DidCommCredentialProtocol } from '../DidCommCredentialProtocol'\nimport type {\n  AcceptCredentialOfferOptions,\n  AcceptCredentialOptions,\n  AcceptCredentialProposalOptions,\n  AcceptCredentialRequestOptions,\n  CreateCredentialOfferOptions,\n  CreateCredentialProblemReportOptions,\n  CreateCredentialProposalOptions,\n  CreateCredentialRequestOptions,\n  CredentialFormatDataMessagePayload,\n  CredentialProtocolMsgReturnType,\n  GetCredentialFormatDataReturn,\n  NegotiateCredentialOfferOptions,\n  NegotiateCredentialProposalOptions,\n} from '../DidCommCredentialProtocolOptions'\n\nimport { DidCommCredentialFormatCoordinator } from './DidCommCredentialFormatCoordinator'\nimport {\n  DidCommCredentialV2AckHandler,\n  DidCommIssueCredentialV2Handler,\n  DidCommOfferCredentialV2Handler,\n  DidCommProposeCredentialV2Handler,\n  DidCommRequestCredentialV2Handler,\n} from './handlers'\nimport { DidCommCredentialV2ProblemReportHandler } from './handlers/DidCommCredentialV2ProblemReportHandler'\nimport {\n  DidCommCredentialV2AckMessage,\n  DidCommCredentialV2ProblemReportMessage,\n  DidCommIssueCredentialV2Message,\n  DidCommOfferCredentialV2Message,\n  DidCommProposeCredentialV2Message,\n  DidCommRequestCredentialV2Message,\n} from './messages'\n\nexport interface DidCommCredentialV2ProtocolConfig<CredentialFormatServices extends DidCommCredentialFormatService[]> {\n  credentialFormats: CredentialFormatServices\n}\n\nexport class DidCommCredentialV2Protocol<\n    CFs extends DidCommCredentialFormatService[] = DidCommCredentialFormatService[],\n  >\n  extends DidCommBaseCredentialProtocol<CFs>\n  implements DidCommCredentialProtocol<CFs>\n{\n  private credentialFormatCoordinator = new DidCommCredentialFormatCoordinator<CFs>()\n  private credentialFormats: CFs\n\n  public constructor({ credentialFormats }: DidCommCredentialV2ProtocolConfig<CFs>) {\n    super()\n\n    this.credentialFormats = credentialFormats\n  }\n\n  /**\n   * The version of the issue credential protocol this service supports\n   */\n  public readonly version = 'v2' as const\n\n  /**\n   * Registers the protocol implementation (handlers, feature registry) on the agent.\n   */\n  public register(messageHandlerRegistry: DidCommMessageHandlerRegistry, featureRegistry: DidCommFeatureRegistry) {\n    // Register message handlers for the Issue Credential V2 Protocol\n    messageHandlerRegistry.registerMessageHandlers([\n      new DidCommProposeCredentialV2Handler(this),\n      new DidCommOfferCredentialV2Handler(this),\n      new DidCommRequestCredentialV2Handler(this),\n      new DidCommIssueCredentialV2Handler(this),\n      new DidCommCredentialV2AckHandler(this),\n      new DidCommCredentialV2ProblemReportHandler(this),\n    ])\n\n    // Register Issue Credential V2 in feature registry, with supported roles\n    featureRegistry.register(\n      new DidCommProtocol({\n        id: 'https://didcomm.org/issue-credential/2.0',\n        roles: ['holder', 'issuer'],\n      })\n    )\n  }\n\n  /**\n   * Create a {@link DidCommProposeCredentialV2Message} not bound to an existing credential exchange.\n   *\n   * @param proposal The ProposeCredentialOptions object containing the important fields for the credential message\n   * @returns Object containing proposal message and associated credential record\n   *\n   */\n  public async createProposal(\n    agentContext: AgentContext,\n    {\n      connectionRecord,\n      credentialFormats,\n      comment,\n      goal,\n      goalCode,\n      autoAcceptCredential,\n    }: CreateCredentialProposalOptions<CFs>\n  ): Promise<CredentialProtocolMsgReturnType<DidCommMessage>> {\n    agentContext.config.logger.debug('Get the Format Service and Create Proposal Message')\n\n    const credentialRepository = agentContext.dependencyManager.resolve(DidCommCredentialExchangeRepository)\n\n    const formatServices = this.getFormatServices(credentialFormats)\n    if (formatServices.length === 0) {\n      throw new CredoError('Unable to create proposal. No supported formats')\n    }\n\n    const credentialExchangeRecord = new DidCommCredentialExchangeRecord({\n      connectionId: connectionRecord.id,\n      threadId: utils.uuid(),\n      state: DidCommCredentialState.ProposalSent,\n      role: DidCommCredentialRole.Holder,\n      autoAcceptCredential,\n      protocolVersion: 'v2',\n    })\n\n    const proposalMessage = await this.credentialFormatCoordinator.createProposal(agentContext, {\n      credentialFormats,\n      credentialExchangeRecord,\n      formatServices,\n      comment,\n      goal,\n      goalCode,\n    })\n\n    agentContext.config.logger.debug('Save record and emit state change event')\n    await credentialRepository.save(agentContext, credentialExchangeRecord)\n    this.emitStateChangedEvent(agentContext, credentialExchangeRecord, null)\n\n    return { credentialExchangeRecord, message: proposalMessage }\n  }\n\n  /**\n   * Method called by {@link DidCommProposeCredentialV2Handler} on reception of a propose credential message\n   * We do the necessary processing here to accept the proposal and do the state change, emit event etc.\n   * @param messageContext the inbound propose credential message\n   * @returns credential record appropriate for this incoming message (once accepted)\n   */\n  public async processProposal(\n    messageContext: DidCommInboundMessageContext<DidCommProposeCredentialV2Message>\n  ): Promise<DidCommCredentialExchangeRecord> {\n    const { message: proposalMessage, connection, agentContext } = messageContext\n\n    agentContext.config.logger.debug(`Processing credential proposal with id ${proposalMessage.id}`)\n\n    const credentialRepository = agentContext.dependencyManager.resolve(DidCommCredentialExchangeRepository)\n    const didCommMessageRepository = agentContext.dependencyManager.resolve(DidCommMessageRepository)\n    const connectionService = agentContext.dependencyManager.resolve(DidCommConnectionService)\n\n    let credentialExchangeRecord = await this.findByProperties(messageContext.agentContext, {\n      threadId: proposalMessage.threadId,\n      role: DidCommCredentialRole.Issuer,\n    })\n\n    const formatServices = this.getFormatServicesFromMessage(proposalMessage.formats)\n    if (formatServices.length === 0) {\n      throw new CredoError('Unable to process proposal. No supported formats')\n    }\n\n    // credential record already exists\n    if (credentialExchangeRecord) {\n      const proposalCredentialMessage = await didCommMessageRepository.findAgentMessage(messageContext.agentContext, {\n        associatedRecordId: credentialExchangeRecord.id,\n        messageClass: DidCommProposeCredentialV2Message,\n        role: DidCommMessageRole.Receiver,\n      })\n      const offerCredentialMessage = await didCommMessageRepository.findAgentMessage(messageContext.agentContext, {\n        associatedRecordId: credentialExchangeRecord.id,\n        messageClass: DidCommOfferCredentialV2Message,\n        role: DidCommMessageRole.Sender,\n      })\n\n      // Assert\n      credentialExchangeRecord.assertProtocolVersion('v2')\n      credentialExchangeRecord.assertState(DidCommCredentialState.OfferSent)\n      await connectionService.assertConnectionOrOutOfBandExchange(messageContext, {\n        lastReceivedMessage: proposalCredentialMessage ?? undefined,\n        lastSentMessage: offerCredentialMessage ?? undefined,\n        expectedConnectionId: credentialExchangeRecord.connectionId,\n      })\n\n      // This makes sure that the sender of the incoming message is authorized to do so.\n      if (!credentialExchangeRecord?.connectionId) {\n        await connectionService.matchIncomingMessageToRequestMessageInOutOfBandExchange(messageContext, {\n          expectedConnectionId: credentialExchangeRecord?.connectionId,\n        })\n\n        credentialExchangeRecord.connectionId = connection?.id\n      }\n\n      await this.credentialFormatCoordinator.processProposal(messageContext.agentContext, {\n        credentialExchangeRecord,\n        formatServices,\n        message: proposalMessage,\n      })\n\n      await this.updateState(\n        messageContext.agentContext,\n        credentialExchangeRecord,\n        DidCommCredentialState.ProposalReceived\n      )\n\n      return credentialExchangeRecord\n    }\n    // Assert\n    await connectionService.assertConnectionOrOutOfBandExchange(messageContext)\n\n    // No credential record exists with thread id\n    credentialExchangeRecord = new DidCommCredentialExchangeRecord({\n      connectionId: connection?.id,\n      threadId: proposalMessage.threadId,\n      parentThreadId: proposalMessage.thread?.parentThreadId,\n      state: DidCommCredentialState.ProposalReceived,\n      role: DidCommCredentialRole.Issuer,\n      protocolVersion: 'v2',\n    })\n\n    await this.credentialFormatCoordinator.processProposal(messageContext.agentContext, {\n      credentialExchangeRecord,\n      formatServices,\n      message: proposalMessage,\n    })\n\n    // Save record and emit event\n    await credentialRepository.save(messageContext.agentContext, credentialExchangeRecord)\n    this.emitStateChangedEvent(messageContext.agentContext, credentialExchangeRecord, null)\n\n    return credentialExchangeRecord\n  }\n\n  public async acceptProposal(\n    agentContext: AgentContext,\n    {\n      credentialExchangeRecord,\n      credentialFormats,\n      autoAcceptCredential,\n      comment,\n      goal,\n      goalCode,\n    }: AcceptCredentialProposalOptions<CFs>\n  ): Promise<CredentialProtocolMsgReturnType<DidCommOfferCredentialV2Message>> {\n    // Assert\n    credentialExchangeRecord.assertProtocolVersion('v2')\n    credentialExchangeRecord.assertState(DidCommCredentialState.ProposalReceived)\n\n    const didCommMessageRepository = agentContext.dependencyManager.resolve(DidCommMessageRepository)\n\n    // Use empty credentialFormats if not provided to denote all formats should be accepted\n    let formatServices = this.getFormatServices(credentialFormats ?? {})\n\n    // if no format services could be extracted from the credentialFormats\n    // take all available format services from the proposal message\n    if (formatServices.length === 0) {\n      const proposalMessage = await didCommMessageRepository.getAgentMessage(agentContext, {\n        associatedRecordId: credentialExchangeRecord.id,\n        messageClass: DidCommProposeCredentialV2Message,\n        role: DidCommMessageRole.Receiver,\n      })\n\n      formatServices = this.getFormatServicesFromMessage(proposalMessage.formats)\n    }\n\n    // If the format services list is still empty, throw an error as we don't support any\n    // of the formats\n    if (formatServices.length === 0) {\n      throw new CredoError('Unable to accept proposal. No supported formats provided as input or in proposal message')\n    }\n\n    const offerMessage = await this.credentialFormatCoordinator.acceptProposal(agentContext, {\n      credentialExchangeRecord,\n      formatServices,\n      comment,\n      goal,\n      goalCode,\n      credentialFormats,\n    })\n\n    credentialExchangeRecord.autoAcceptCredential =\n      autoAcceptCredential ?? credentialExchangeRecord.autoAcceptCredential\n    await this.updateState(agentContext, credentialExchangeRecord, DidCommCredentialState.OfferSent)\n\n    return { credentialExchangeRecord, message: offerMessage }\n  }\n\n  /**\n   * Negotiate a credential proposal as issuer (by sending a credential offer message) to the connection\n   * associated with the credential record.\n   *\n   * @param options configuration for the offer see {@link NegotiateCredentialProposalOptions}\n   * @returns Credential exchange record associated with the credential offer\n   *\n   */\n  public async negotiateProposal(\n    agentContext: AgentContext,\n    {\n      credentialExchangeRecord,\n      credentialFormats,\n      autoAcceptCredential,\n      comment,\n      goal,\n      goalCode,\n    }: NegotiateCredentialProposalOptions<CFs>\n  ): Promise<CredentialProtocolMsgReturnType<DidCommOfferCredentialV2Message>> {\n    // Assert\n    credentialExchangeRecord.assertProtocolVersion('v2')\n    credentialExchangeRecord.assertState(DidCommCredentialState.ProposalReceived)\n\n    if (!credentialExchangeRecord.connectionId) {\n      throw new CredoError(\n        `No connectionId found for credential record '${credentialExchangeRecord.id}'. Connection-less issuance does not support negotiation.`\n      )\n    }\n\n    const formatServices = this.getFormatServices(credentialFormats)\n    if (formatServices.length === 0) {\n      throw new CredoError('Unable to create offer. No supported formats')\n    }\n\n    const offerMessage = await this.credentialFormatCoordinator.createOffer(agentContext, {\n      formatServices,\n      credentialFormats,\n      credentialExchangeRecord,\n      comment,\n      goal,\n      goalCode,\n    })\n\n    credentialExchangeRecord.autoAcceptCredential =\n      autoAcceptCredential ?? credentialExchangeRecord.autoAcceptCredential\n    await this.updateState(agentContext, credentialExchangeRecord, DidCommCredentialState.OfferSent)\n\n    return { credentialExchangeRecord, message: offerMessage }\n  }\n\n  /**\n   * Create a {@link DidCommOfferCredentialV2Message} as beginning of protocol process. If no connectionId is provided, the\n   * exchange will be created without a connection for usage in oob and connection-less issuance.\n   *\n   * @param formatService {@link DidCommCredentialFormatService} the format service object containing format-specific logic\n   * @param options attributes of the original offer\n   * @returns Object containing offer message and associated credential record\n   *\n   */\n  public async createOffer(\n    agentContext: AgentContext,\n    {\n      credentialFormats,\n      autoAcceptCredential,\n      comment,\n      goal,\n      goalCode,\n      connectionRecord,\n    }: CreateCredentialOfferOptions<CFs>\n  ): Promise<CredentialProtocolMsgReturnType<DidCommOfferCredentialV2Message>> {\n    const credentialRepository = agentContext.dependencyManager.resolve(DidCommCredentialExchangeRepository)\n\n    const formatServices = this.getFormatServices(credentialFormats)\n    if (formatServices.length === 0) {\n      throw new CredoError('Unable to create offer. No supported formats')\n    }\n\n    const credentialExchangeRecord = new DidCommCredentialExchangeRecord({\n      connectionId: connectionRecord?.id,\n      threadId: utils.uuid(),\n      state: DidCommCredentialState.OfferSent,\n      role: DidCommCredentialRole.Issuer,\n      autoAcceptCredential,\n      protocolVersion: 'v2',\n    })\n\n    const offerMessage = await this.credentialFormatCoordinator.createOffer(agentContext, {\n      formatServices,\n      credentialFormats,\n      credentialExchangeRecord,\n      comment,\n      goal,\n      goalCode,\n    })\n\n    agentContext.config.logger.debug(\n      `Saving record and emitting state changed for credential exchange record ${credentialExchangeRecord.id}`\n    )\n    await credentialRepository.save(agentContext, credentialExchangeRecord)\n    this.emitStateChangedEvent(agentContext, credentialExchangeRecord, null)\n\n    return { credentialExchangeRecord, message: offerMessage }\n  }\n\n  /**\n   * Method called by {@link DidCommOfferCredentialV2Handler} on reception of a offer credential message\n   * We do the necessary processing here to accept the offer and do the state change, emit event etc.\n   * @param messageContext the inbound offer credential message\n   * @returns credential record appropriate for this incoming message (once accepted)\n   */\n  public async processOffer(\n    messageContext: DidCommMessageHandlerInboundMessage<DidCommOfferCredentialV2Handler>\n  ): Promise<DidCommCredentialExchangeRecord> {\n    const { message: offerMessage, connection, agentContext } = messageContext\n\n    agentContext.config.logger.debug(`Processing credential offer with id ${offerMessage.id}`)\n\n    const credentialRepository = agentContext.dependencyManager.resolve(DidCommCredentialExchangeRepository)\n    const didCommMessageRepository = agentContext.dependencyManager.resolve(DidCommMessageRepository)\n    const connectionService = agentContext.dependencyManager.resolve(DidCommConnectionService)\n\n    let credentialExchangeRecord = await this.findByProperties(messageContext.agentContext, {\n      threadId: offerMessage.threadId,\n      role: DidCommCredentialRole.Holder,\n      connectionId: connection?.id,\n    })\n\n    const formatServices = this.getFormatServicesFromMessage(offerMessage.formats)\n    if (formatServices.length === 0) {\n      throw new CredoError('Unable to process offer. No supported formats')\n    }\n\n    // credential record already exists\n    if (credentialExchangeRecord) {\n      const proposeCredentialMessage = await didCommMessageRepository.findAgentMessage(messageContext.agentContext, {\n        associatedRecordId: credentialExchangeRecord.id,\n        messageClass: DidCommProposeCredentialV2Message,\n        role: DidCommMessageRole.Sender,\n      })\n      const offerCredentialMessage = await didCommMessageRepository.findAgentMessage(messageContext.agentContext, {\n        associatedRecordId: credentialExchangeRecord.id,\n        messageClass: DidCommOfferCredentialV2Message,\n        role: DidCommMessageRole.Receiver,\n      })\n\n      credentialExchangeRecord.assertProtocolVersion('v2')\n      credentialExchangeRecord.assertState(DidCommCredentialState.ProposalSent)\n      await connectionService.assertConnectionOrOutOfBandExchange(messageContext, {\n        lastReceivedMessage: offerCredentialMessage ?? undefined,\n        lastSentMessage: proposeCredentialMessage ?? undefined,\n        expectedConnectionId: credentialExchangeRecord.connectionId,\n      })\n\n      await this.credentialFormatCoordinator.processOffer(messageContext.agentContext, {\n        credentialExchangeRecord,\n        formatServices,\n        message: offerMessage,\n      })\n\n      await this.updateState(\n        messageContext.agentContext,\n        credentialExchangeRecord,\n        DidCommCredentialState.OfferReceived\n      )\n      return credentialExchangeRecord\n    }\n    // Assert\n    await connectionService.assertConnectionOrOutOfBandExchange(messageContext)\n\n    // No credential record exists with thread id\n    agentContext.config.logger.debug('No credential record found for offer, creating a new one')\n    credentialExchangeRecord = new DidCommCredentialExchangeRecord({\n      connectionId: connection?.id,\n      threadId: offerMessage.threadId,\n      parentThreadId: offerMessage.thread?.parentThreadId,\n      state: DidCommCredentialState.OfferReceived,\n      role: DidCommCredentialRole.Holder,\n      protocolVersion: 'v2',\n    })\n\n    await this.credentialFormatCoordinator.processOffer(messageContext.agentContext, {\n      credentialExchangeRecord,\n      formatServices,\n      message: offerMessage,\n    })\n\n    // Save in repository\n    agentContext.config.logger.debug('Saving credential record and emit offer-received event')\n    await credentialRepository.save(messageContext.agentContext, credentialExchangeRecord)\n\n    this.emitStateChangedEvent(messageContext.agentContext, credentialExchangeRecord, null)\n    return credentialExchangeRecord\n  }\n\n  public async acceptOffer(\n    agentContext: AgentContext,\n    {\n      credentialExchangeRecord,\n      autoAcceptCredential,\n      comment,\n      goal,\n      goalCode,\n      credentialFormats,\n    }: AcceptCredentialOfferOptions<CFs>\n  ) {\n    const didCommMessageRepository = agentContext.dependencyManager.resolve(DidCommMessageRepository)\n\n    // Assert\n    credentialExchangeRecord.assertProtocolVersion('v2')\n    credentialExchangeRecord.assertState(DidCommCredentialState.OfferReceived)\n\n    // Use empty credentialFormats if not provided to denote all formats should be accepted\n    let formatServices = this.getFormatServices(credentialFormats ?? {})\n\n    // if no format services could be extracted from the credentialFormats\n    // take all available format services from the offer message\n    if (formatServices.length === 0) {\n      const offerMessage = await didCommMessageRepository.getAgentMessage(agentContext, {\n        associatedRecordId: credentialExchangeRecord.id,\n        messageClass: DidCommOfferCredentialV2Message,\n        role: DidCommMessageRole.Receiver,\n      })\n\n      formatServices = this.getFormatServicesFromMessage(offerMessage.formats)\n    }\n\n    // If the format services list is still empty, throw an error as we don't support any\n    // of the formats\n    if (formatServices.length === 0) {\n      throw new CredoError('Unable to accept offer. No supported formats provided as input or in offer message')\n    }\n\n    const message = await this.credentialFormatCoordinator.acceptOffer(agentContext, {\n      credentialExchangeRecord,\n      formatServices,\n      comment,\n      goal,\n      goalCode,\n      credentialFormats,\n    })\n\n    credentialExchangeRecord.autoAcceptCredential =\n      autoAcceptCredential ?? credentialExchangeRecord.autoAcceptCredential\n    await this.updateState(agentContext, credentialExchangeRecord, DidCommCredentialState.RequestSent)\n\n    return { credentialExchangeRecord, message }\n  }\n\n  /**\n   * Create a {@link ProposePresentationMessage} as response to a received credential offer.\n   * To create a proposal not bound to an existing credential exchange, use {@link createProposal}.\n   *\n   * @param options configuration to use for the proposal\n   * @returns Object containing proposal message and associated credential record\n   *\n   */\n  public async negotiateOffer(\n    agentContext: AgentContext,\n    {\n      credentialExchangeRecord,\n      credentialFormats,\n      autoAcceptCredential,\n      comment,\n      goal,\n      goalCode,\n    }: NegotiateCredentialOfferOptions<CFs>\n  ): Promise<CredentialProtocolMsgReturnType<DidCommProposeCredentialV2Message>> {\n    // Assert\n    credentialExchangeRecord.assertProtocolVersion('v2')\n    credentialExchangeRecord.assertState(DidCommCredentialState.OfferReceived)\n\n    if (!credentialExchangeRecord.connectionId) {\n      throw new CredoError(\n        `No connectionId found for credential record '${credentialExchangeRecord.id}'. Connection-less issuance does not support negotiation.`\n      )\n    }\n\n    const formatServices = this.getFormatServices(credentialFormats)\n    if (formatServices.length === 0) {\n      throw new CredoError('Unable to create proposal. No supported formats')\n    }\n\n    const proposalMessage = await this.credentialFormatCoordinator.createProposal(agentContext, {\n      formatServices,\n      credentialFormats,\n      credentialExchangeRecord,\n      comment,\n      goal,\n      goalCode,\n    })\n\n    credentialExchangeRecord.autoAcceptCredential =\n      autoAcceptCredential ?? credentialExchangeRecord.autoAcceptCredential\n    await this.updateState(agentContext, credentialExchangeRecord, DidCommCredentialState.ProposalSent)\n\n    return { credentialExchangeRecord, message: proposalMessage }\n  }\n\n  /**\n   * Create a {@link DidCommRequestCredentialV2Message} as beginning of protocol process.\n   * @returns Object containing offer message and associated credential record\n   *\n   */\n  public async createRequest(\n    agentContext: AgentContext,\n    {\n      credentialFormats,\n      autoAcceptCredential,\n      comment,\n      goal,\n      goalCode,\n      connectionRecord,\n    }: CreateCredentialRequestOptions<CFs>\n  ): Promise<CredentialProtocolMsgReturnType<DidCommRequestCredentialV2Message>> {\n    const credentialRepository = agentContext.dependencyManager.resolve(DidCommCredentialExchangeRepository)\n\n    const formatServices = this.getFormatServices(credentialFormats)\n    if (formatServices.length === 0) {\n      throw new CredoError('Unable to create request. No supported formats')\n    }\n\n    const credentialExchangeRecord = new DidCommCredentialExchangeRecord({\n      connectionId: connectionRecord.id,\n      threadId: utils.uuid(),\n      state: DidCommCredentialState.RequestSent,\n      role: DidCommCredentialRole.Holder,\n      autoAcceptCredential,\n      protocolVersion: 'v2',\n    })\n\n    const requestMessage = await this.credentialFormatCoordinator.createRequest(agentContext, {\n      formatServices,\n      credentialFormats,\n      credentialExchangeRecord,\n      comment,\n      goal,\n      goalCode,\n    })\n\n    agentContext.config.logger.debug(\n      `Saving record and emitting state changed for credential exchange record ${credentialExchangeRecord.id}`\n    )\n    await credentialRepository.save(agentContext, credentialExchangeRecord)\n    this.emitStateChangedEvent(agentContext, credentialExchangeRecord, null)\n\n    return { credentialExchangeRecord, message: requestMessage }\n  }\n\n  /**\n   * Process a received {@link RequestCredentialMessage}. This will not accept the credential request\n   * or send a credential. It will only update the existing credential record with\n   * the information from the credential request message. Use {@link createCredential}\n   * after calling this method to create a credential.\n   *z\n   * @param messageContext The message context containing a v2 credential request message\n   * @returns credential record associated with the credential request message\n   *\n   */\n  public async processRequest(\n    messageContext: DidCommInboundMessageContext<DidCommRequestCredentialV2Message>\n  ): Promise<DidCommCredentialExchangeRecord> {\n    const { message: requestMessage, connection, agentContext } = messageContext\n\n    const credentialRepository = agentContext.dependencyManager.resolve(DidCommCredentialExchangeRepository)\n    const didCommMessageRepository = agentContext.dependencyManager.resolve(DidCommMessageRepository)\n    const connectionService = agentContext.dependencyManager.resolve(DidCommConnectionService)\n\n    agentContext.config.logger.debug(`Processing credential request with id ${requestMessage.id}`)\n\n    let credentialExchangeRecord = await this.findByProperties(messageContext.agentContext, {\n      threadId: requestMessage.threadId,\n      role: DidCommCredentialRole.Issuer,\n    })\n\n    const formatServices = this.getFormatServicesFromMessage(requestMessage.formats)\n    if (formatServices.length === 0) {\n      throw new CredoError('Unable to process request. No supported formats')\n    }\n\n    // credential record already exists\n    if (credentialExchangeRecord) {\n      const proposalMessage = await didCommMessageRepository.findAgentMessage(messageContext.agentContext, {\n        associatedRecordId: credentialExchangeRecord.id,\n        messageClass: DidCommProposeCredentialV2Message,\n        role: DidCommMessageRole.Receiver,\n      })\n\n      const offerMessage = await didCommMessageRepository.findAgentMessage(messageContext.agentContext, {\n        associatedRecordId: credentialExchangeRecord.id,\n        messageClass: DidCommOfferCredentialV2Message,\n        role: DidCommMessageRole.Sender,\n      })\n\n      // Assert\n      credentialExchangeRecord.assertProtocolVersion('v2')\n      credentialExchangeRecord.assertState(DidCommCredentialState.OfferSent)\n      await connectionService.assertConnectionOrOutOfBandExchange(messageContext, {\n        lastReceivedMessage: proposalMessage ?? undefined,\n        lastSentMessage: offerMessage ?? undefined,\n        expectedConnectionId: credentialExchangeRecord.connectionId,\n      })\n\n      // This makes sure that the sender of the incoming message is authorized to do so.\n      if (!credentialExchangeRecord.connectionId) {\n        await connectionService.matchIncomingMessageToRequestMessageInOutOfBandExchange(messageContext, {\n          expectedConnectionId: credentialExchangeRecord.connectionId,\n        })\n\n        credentialExchangeRecord.connectionId = connection?.id\n      }\n\n      await this.credentialFormatCoordinator.processRequest(messageContext.agentContext, {\n        credentialExchangeRecord,\n        formatServices,\n        message: requestMessage,\n      })\n\n      await this.updateState(\n        messageContext.agentContext,\n        credentialExchangeRecord,\n        DidCommCredentialState.RequestReceived\n      )\n      return credentialExchangeRecord\n    }\n    // Assert\n    await connectionService.assertConnectionOrOutOfBandExchange(messageContext)\n\n    // No credential record exists with thread id\n    agentContext.config.logger.debug('No credential record found for request, creating a new one')\n    credentialExchangeRecord = new DidCommCredentialExchangeRecord({\n      connectionId: connection?.id,\n      threadId: requestMessage.threadId,\n      parentThreadId: requestMessage.thread?.parentThreadId,\n      state: DidCommCredentialState.RequestReceived,\n      role: DidCommCredentialRole.Issuer,\n      protocolVersion: 'v2',\n    })\n\n    await this.credentialFormatCoordinator.processRequest(messageContext.agentContext, {\n      credentialExchangeRecord,\n      formatServices,\n      message: requestMessage,\n    })\n\n    // Save in repository\n    agentContext.config.logger.debug('Saving credential record and emit request-received event')\n    await credentialRepository.save(messageContext.agentContext, credentialExchangeRecord)\n\n    this.emitStateChangedEvent(messageContext.agentContext, credentialExchangeRecord, null)\n    return credentialExchangeRecord\n  }\n\n  public async acceptRequest(\n    agentContext: AgentContext,\n    {\n      credentialExchangeRecord,\n      autoAcceptCredential,\n      comment,\n      goal,\n      goalCode,\n      credentialFormats,\n    }: AcceptCredentialRequestOptions<CFs>\n  ) {\n    const didCommMessageRepository = agentContext.dependencyManager.resolve(DidCommMessageRepository)\n\n    // Assert\n    credentialExchangeRecord.assertProtocolVersion('v2')\n    credentialExchangeRecord.assertState(DidCommCredentialState.RequestReceived)\n\n    // Use empty credentialFormats if not provided to denote all formats should be accepted\n    let formatServices = this.getFormatServices(credentialFormats ?? {})\n\n    // if no format services could be extracted from the credentialFormats\n    // take all available format services from the request message\n    if (formatServices.length === 0) {\n      const requestMessage = await didCommMessageRepository.getAgentMessage(agentContext, {\n        associatedRecordId: credentialExchangeRecord.id,\n        messageClass: DidCommRequestCredentialV2Message,\n        role: DidCommMessageRole.Receiver,\n      })\n\n      formatServices = this.getFormatServicesFromMessage(requestMessage.formats)\n    }\n\n    // If the format services list is still empty, throw an error as we don't support any\n    // of the formats\n    if (formatServices.length === 0) {\n      throw new CredoError('Unable to accept request. No supported formats provided as input or in request message')\n    }\n    const message = await this.credentialFormatCoordinator.acceptRequest(agentContext, {\n      credentialExchangeRecord,\n      formatServices,\n      comment,\n      goal,\n      goalCode,\n      credentialFormats,\n    })\n\n    credentialExchangeRecord.autoAcceptCredential =\n      autoAcceptCredential ?? credentialExchangeRecord.autoAcceptCredential\n    await this.updateState(agentContext, credentialExchangeRecord, DidCommCredentialState.CredentialIssued)\n\n    return { credentialExchangeRecord, message }\n  }\n\n  /**\n   * Process a received {@link DidCommIssueCredentialV2Message}. This will not accept the credential\n   * or send a credential acknowledgement. It will only update the existing credential record with\n   * the information from the issue credential message. Use {@link createAck}\n   * after calling this method to create a credential acknowledgement.\n   *\n   * @param messageContext The message context containing an issue credential message\n   *\n   * @returns credential record associated with the issue credential message\n   *\n   */\n  public async processCredential(\n    messageContext: DidCommInboundMessageContext<DidCommIssueCredentialV2Message>\n  ): Promise<DidCommCredentialExchangeRecord> {\n    const { message: credentialMessage, connection, agentContext } = messageContext\n\n    const didCommMessageRepository = agentContext.dependencyManager.resolve(DidCommMessageRepository)\n    const connectionService = agentContext.dependencyManager.resolve(DidCommConnectionService)\n\n    agentContext.config.logger.debug(`Processing credential with id ${credentialMessage.id}`)\n\n    const credentialExchangeRecord = await this.getByProperties(messageContext.agentContext, {\n      threadId: credentialMessage.threadId,\n      role: DidCommCredentialRole.Holder,\n      connectionId: connection?.id,\n    })\n\n    const requestMessage = await didCommMessageRepository.getAgentMessage(messageContext.agentContext, {\n      associatedRecordId: credentialExchangeRecord.id,\n      messageClass: DidCommRequestCredentialV2Message,\n      role: DidCommMessageRole.Sender,\n    })\n    const offerMessage = await didCommMessageRepository.findAgentMessage(messageContext.agentContext, {\n      associatedRecordId: credentialExchangeRecord.id,\n      messageClass: DidCommOfferCredentialV2Message,\n      role: DidCommMessageRole.Receiver,\n    })\n\n    // Assert\n    credentialExchangeRecord.assertProtocolVersion('v2')\n    credentialExchangeRecord.assertState(DidCommCredentialState.RequestSent)\n    await connectionService.assertConnectionOrOutOfBandExchange(messageContext, {\n      lastReceivedMessage: offerMessage ?? undefined,\n      lastSentMessage: requestMessage,\n      expectedConnectionId: credentialExchangeRecord.connectionId,\n    })\n\n    const formatServices = this.getFormatServicesFromMessage(credentialMessage.formats)\n    if (formatServices.length === 0) {\n      throw new CredoError('Unable to process credential. No supported formats')\n    }\n\n    await this.credentialFormatCoordinator.processCredential(messageContext.agentContext, {\n      credentialExchangeRecord,\n      formatServices,\n      requestMessage: requestMessage,\n      message: credentialMessage,\n    })\n\n    await this.updateState(\n      messageContext.agentContext,\n      credentialExchangeRecord,\n      DidCommCredentialState.CredentialReceived\n    )\n\n    return credentialExchangeRecord\n  }\n\n  /**\n   * Create a {@link DidCommCredentialV2AckMessage} as response to a received credential.\n   *\n   * @param credentialExchangeRecord The credential record for which to create the credential acknowledgement\n   * @returns Object containing credential acknowledgement message and associated credential record\n   *\n   */\n  public async acceptCredential(\n    agentContext: AgentContext,\n    { credentialExchangeRecord }: AcceptCredentialOptions\n  ): Promise<CredentialProtocolMsgReturnType<DidCommCredentialV2AckMessage>> {\n    credentialExchangeRecord.assertProtocolVersion('v2')\n    credentialExchangeRecord.assertState(DidCommCredentialState.CredentialReceived)\n\n    // Create message\n    const ackMessage = new DidCommCredentialV2AckMessage({\n      status: AckStatus.OK,\n      threadId: credentialExchangeRecord.threadId,\n    })\n\n    ackMessage.setThread({\n      threadId: credentialExchangeRecord.threadId,\n      parentThreadId: credentialExchangeRecord.parentThreadId,\n    })\n\n    await this.updateState(agentContext, credentialExchangeRecord, DidCommCredentialState.Done)\n\n    return { message: ackMessage, credentialExchangeRecord }\n  }\n\n  /**\n   * Process a received {@link CredentialAckMessage}.\n   *\n   * @param messageContext The message context containing a credential acknowledgement message\n   * @returns credential record associated with the credential acknowledgement message\n   *\n   */\n  public async processAck(\n    messageContext: DidCommInboundMessageContext<DidCommCredentialV2AckMessage>\n  ): Promise<DidCommCredentialExchangeRecord> {\n    const { message: ackMessage, connection, agentContext } = messageContext\n\n    agentContext.config.logger.debug(`Processing credential ack with id ${ackMessage.id}`)\n\n    const didCommMessageRepository = agentContext.dependencyManager.resolve(DidCommMessageRepository)\n    const connectionService = agentContext.dependencyManager.resolve(DidCommConnectionService)\n\n    const credentialExchangeRecord = await this.getByProperties(messageContext.agentContext, {\n      threadId: ackMessage.threadId,\n      role: DidCommCredentialRole.Issuer,\n      connectionId: connection?.id,\n    })\n    credentialExchangeRecord.connectionId = connection?.id\n\n    const requestMessage = await didCommMessageRepository.getAgentMessage(messageContext.agentContext, {\n      associatedRecordId: credentialExchangeRecord.id,\n      messageClass: DidCommRequestCredentialV2Message,\n      role: DidCommMessageRole.Receiver,\n    })\n\n    const credentialMessage = await didCommMessageRepository.getAgentMessage(messageContext.agentContext, {\n      associatedRecordId: credentialExchangeRecord.id,\n      messageClass: DidCommIssueCredentialV2Message,\n      role: DidCommMessageRole.Sender,\n    })\n\n    // Assert\n    credentialExchangeRecord.assertProtocolVersion('v2')\n    credentialExchangeRecord.assertState(DidCommCredentialState.CredentialIssued)\n    await connectionService.assertConnectionOrOutOfBandExchange(messageContext, {\n      lastReceivedMessage: requestMessage,\n      lastSentMessage: credentialMessage,\n      expectedConnectionId: credentialExchangeRecord.connectionId,\n    })\n\n    // Update record\n    await this.updateState(messageContext.agentContext, credentialExchangeRecord, DidCommCredentialState.Done)\n\n    return credentialExchangeRecord\n  }\n\n  /**\n   * Create a {@link DidCommCredentialV2ProblemReportMessage} to be sent.\n   *\n   * @param message message to send\n   * @returns a {@link DidCommCredentialV2ProblemReportMessage}\n   *\n   */\n  public async createProblemReport(\n    _agentContext: AgentContext,\n    { credentialExchangeRecord, description }: CreateCredentialProblemReportOptions\n  ): Promise<CredentialProtocolMsgReturnType<DidCommProblemReportMessage>> {\n    const message = new DidCommCredentialV2ProblemReportMessage({\n      description: {\n        en: description,\n        code: DidCommCredentialProblemReportReason.IssuanceAbandoned,\n      },\n    })\n\n    message.setThread({\n      threadId: credentialExchangeRecord.threadId,\n      parentThreadId: credentialExchangeRecord.parentThreadId,\n    })\n\n    return { credentialExchangeRecord, message }\n  }\n\n  // AUTO ACCEPT METHODS\n  public async shouldAutoRespondToProposal(\n    agentContext: AgentContext,\n    options: {\n      credentialExchangeRecord: DidCommCredentialExchangeRecord\n      proposalMessage: DidCommProposeCredentialV2Message\n    }\n  ): Promise<boolean> {\n    const { credentialExchangeRecord, proposalMessage } = options\n    const credentialsModuleConfig = agentContext.dependencyManager.resolve(DidCommCredentialsModuleConfig)\n\n    const autoAccept = composeAutoAccept(\n      credentialExchangeRecord.autoAcceptCredential,\n      credentialsModuleConfig.autoAcceptCredentials\n    )\n\n    // Handle always / never cases\n    if (autoAccept === DidCommAutoAcceptCredential.Always) return true\n    if (autoAccept === DidCommAutoAcceptCredential.Never) return false\n\n    const offerMessage = await this.findOfferMessage(agentContext, credentialExchangeRecord.id)\n    if (!offerMessage) return false\n\n    // NOTE: we take the formats from the offerMessage so we always check all services that we last sent\n    // Otherwise we'll only check the formats from the proposal, which could be different from the formats\n    // we use.\n    const formatServices = this.getFormatServicesFromMessage(offerMessage.formats)\n\n    for (const formatService of formatServices) {\n      const offerAttachment = this.credentialFormatCoordinator.getAttachmentForService(\n        formatService,\n        offerMessage.formats,\n        offerMessage.offerAttachments\n      )\n\n      const proposalAttachment = this.credentialFormatCoordinator.getAttachmentForService(\n        formatService,\n        proposalMessage.formats,\n        proposalMessage.proposalAttachments\n      )\n\n      const shouldAutoRespondToFormat = await formatService.shouldAutoRespondToProposal(agentContext, {\n        credentialExchangeRecord,\n        offerAttachment,\n        proposalAttachment,\n      })\n      // If any of the formats return false, we should not auto accept\n      if (!shouldAutoRespondToFormat) return false\n    }\n\n    // not all formats use the proposal and preview, we only check if they're present on\n    // either or both of the messages\n    if (proposalMessage.credentialPreview || offerMessage.credentialPreview) {\n      // if one of the message doesn't have a preview, we should not auto accept\n      if (!proposalMessage.credentialPreview || !offerMessage.credentialPreview) return false\n\n      // Check if preview values match\n      return arePreviewAttributesEqual(\n        proposalMessage.credentialPreview.attributes,\n        offerMessage.credentialPreview.attributes\n      )\n    }\n\n    return true\n  }\n\n  public async shouldAutoRespondToOffer(\n    agentContext: AgentContext,\n    options: {\n      credentialExchangeRecord: DidCommCredentialExchangeRecord\n      offerMessage: DidCommOfferCredentialV2Message\n    }\n  ): Promise<boolean> {\n    const { credentialExchangeRecord, offerMessage } = options\n    const credentialsModuleConfig = agentContext.dependencyManager.resolve(DidCommCredentialsModuleConfig)\n\n    const autoAccept = composeAutoAccept(\n      credentialExchangeRecord.autoAcceptCredential,\n      credentialsModuleConfig.autoAcceptCredentials\n    )\n    // Handle always / never cases\n    if (autoAccept === DidCommAutoAcceptCredential.Always) return true\n    if (autoAccept === DidCommAutoAcceptCredential.Never) return false\n\n    const proposalMessage = await this.findProposalMessage(agentContext, credentialExchangeRecord.id)\n    if (!proposalMessage) return false\n\n    // NOTE: we take the formats from the proposalMessage so we always check all services that we last sent\n    // Otherwise we'll only check the formats from the offer, which could be different from the formats\n    // we use.\n    const formatServices = this.getFormatServicesFromMessage(proposalMessage.formats)\n\n    for (const formatService of formatServices) {\n      const offerAttachment = this.credentialFormatCoordinator.getAttachmentForService(\n        formatService,\n        offerMessage.formats,\n        offerMessage.offerAttachments\n      )\n\n      const proposalAttachment = this.credentialFormatCoordinator.getAttachmentForService(\n        formatService,\n        proposalMessage.formats,\n        proposalMessage.proposalAttachments\n      )\n\n      const shouldAutoRespondToFormat = await formatService.shouldAutoRespondToOffer(agentContext, {\n        credentialExchangeRecord,\n        offerAttachment,\n        proposalAttachment,\n      })\n\n      // If any of the formats return false, we should not auto accept\n\n      if (!shouldAutoRespondToFormat) return false\n    }\n\n    // if one of the message doesn't have a preview, we should not auto accept\n    if (proposalMessage.credentialPreview || offerMessage.credentialPreview) {\n      // Check if preview values match\n      return arePreviewAttributesEqual(\n        proposalMessage.credentialPreview?.attributes ?? [],\n        offerMessage.credentialPreview?.attributes ?? []\n      )\n    }\n    return true\n  }\n\n  public async shouldAutoRespondToRequest(\n    agentContext: AgentContext,\n    options: {\n      credentialExchangeRecord: DidCommCredentialExchangeRecord\n      requestMessage: DidCommRequestCredentialV2Message\n    }\n  ): Promise<boolean> {\n    const { credentialExchangeRecord, requestMessage } = options\n    const credentialsModuleConfig = agentContext.dependencyManager.resolve(DidCommCredentialsModuleConfig)\n\n    const autoAccept = composeAutoAccept(\n      credentialExchangeRecord.autoAcceptCredential,\n      credentialsModuleConfig.autoAcceptCredentials\n    )\n\n    // Handle always / never cases\n    if (autoAccept === DidCommAutoAcceptCredential.Always) return true\n    if (autoAccept === DidCommAutoAcceptCredential.Never) return false\n\n    const proposalMessage = await this.findProposalMessage(agentContext, credentialExchangeRecord.id)\n\n    const offerMessage = await this.findOfferMessage(agentContext, credentialExchangeRecord.id)\n    if (!offerMessage) return false\n\n    // NOTE: we take the formats from the offerMessage so we always check all services that we last sent\n    // Otherwise we'll only check the formats from the request, which could be different from the formats\n    // we use.\n    const formatServices = this.getFormatServicesFromMessage(offerMessage.formats)\n\n    for (const formatService of formatServices) {\n      const offerAttachment = this.credentialFormatCoordinator.getAttachmentForService(\n        formatService,\n        offerMessage.formats,\n        offerMessage.offerAttachments\n      )\n\n      const proposalAttachment = proposalMessage\n        ? this.credentialFormatCoordinator.getAttachmentForService(\n            formatService,\n            proposalMessage.formats,\n            proposalMessage.proposalAttachments\n          )\n        : undefined\n\n      const requestAttachment = this.credentialFormatCoordinator.getAttachmentForService(\n        formatService,\n        requestMessage.formats,\n        requestMessage.requestAttachments\n      )\n\n      const shouldAutoRespondToFormat = await formatService.shouldAutoRespondToRequest(agentContext, {\n        credentialExchangeRecord,\n        offerAttachment,\n        requestAttachment,\n        proposalAttachment,\n      })\n\n      // If any of the formats return false, we should not auto accept\n      if (!shouldAutoRespondToFormat) return false\n    }\n\n    return true\n  }\n\n  public async shouldAutoRespondToCredential(\n    agentContext: AgentContext,\n    options: {\n      credentialExchangeRecord: DidCommCredentialExchangeRecord\n      credentialMessage: DidCommIssueCredentialV2Message\n    }\n  ): Promise<boolean> {\n    const { credentialExchangeRecord, credentialMessage } = options\n    const credentialsModuleConfig = agentContext.dependencyManager.resolve(DidCommCredentialsModuleConfig)\n\n    const autoAccept = composeAutoAccept(\n      credentialExchangeRecord.autoAcceptCredential,\n      credentialsModuleConfig.autoAcceptCredentials\n    )\n\n    // Handle always / never cases\n    if (autoAccept === DidCommAutoAcceptCredential.Always) return true\n    if (autoAccept === DidCommAutoAcceptCredential.Never) return false\n\n    const proposalMessage = await this.findProposalMessage(agentContext, credentialExchangeRecord.id)\n    const offerMessage = await this.findOfferMessage(agentContext, credentialExchangeRecord.id)\n\n    const requestMessage = await this.findRequestMessage(agentContext, credentialExchangeRecord.id)\n    if (!requestMessage) return false\n\n    // NOTE: we take the formats from the requestMessage so we always check all services that we last sent\n    // Otherwise we'll only check the formats from the credential, which could be different from the formats\n    // we use.\n    const formatServices = this.getFormatServicesFromMessage(requestMessage.formats)\n\n    for (const formatService of formatServices) {\n      const offerAttachment = offerMessage\n        ? this.credentialFormatCoordinator.getAttachmentForService(\n            formatService,\n            offerMessage.formats,\n            offerMessage.offerAttachments\n          )\n        : undefined\n\n      const proposalAttachment = proposalMessage\n        ? this.credentialFormatCoordinator.getAttachmentForService(\n            formatService,\n            proposalMessage.formats,\n            proposalMessage.proposalAttachments\n          )\n        : undefined\n\n      const requestAttachment = this.credentialFormatCoordinator.getAttachmentForService(\n        formatService,\n        requestMessage.formats,\n        requestMessage.requestAttachments\n      )\n\n      const credentialAttachment = this.credentialFormatCoordinator.getAttachmentForService(\n        formatService,\n        credentialMessage.formats,\n        credentialMessage.credentialAttachments\n      )\n\n      const shouldAutoRespondToFormat = await formatService.shouldAutoRespondToCredential(agentContext, {\n        credentialExchangeRecord,\n        offerAttachment,\n        credentialAttachment,\n        requestAttachment,\n        proposalAttachment,\n      })\n\n      // If any of the formats return false, we should not auto accept\n      if (!shouldAutoRespondToFormat) return false\n    }\n    return true\n  }\n\n  public async findProposalMessage(agentContext: AgentContext, credentialExchangeId: string) {\n    const didCommMessageRepository = agentContext.dependencyManager.resolve(DidCommMessageRepository)\n\n    return didCommMessageRepository.findAgentMessage(agentContext, {\n      associatedRecordId: credentialExchangeId,\n      messageClass: DidCommProposeCredentialV2Message,\n    })\n  }\n\n  public async findOfferMessage(agentContext: AgentContext, credentialExchangeId: string) {\n    const didCommMessageRepository = agentContext.dependencyManager.resolve(DidCommMessageRepository)\n\n    return await didCommMessageRepository.findAgentMessage(agentContext, {\n      associatedRecordId: credentialExchangeId,\n      messageClass: DidCommOfferCredentialV2Message,\n    })\n  }\n\n  public async findRequestMessage(agentContext: AgentContext, credentialExchangeId: string) {\n    const didCommMessageRepository = agentContext.dependencyManager.resolve(DidCommMessageRepository)\n\n    return await didCommMessageRepository.findAgentMessage(agentContext, {\n      associatedRecordId: credentialExchangeId,\n      messageClass: DidCommRequestCredentialV2Message,\n    })\n  }\n\n  public async findCredentialMessage(agentContext: AgentContext, credentialExchangeId: string) {\n    const didCommMessageRepository = agentContext.dependencyManager.resolve(DidCommMessageRepository)\n\n    return await didCommMessageRepository.findAgentMessage(agentContext, {\n      associatedRecordId: credentialExchangeId,\n      messageClass: DidCommIssueCredentialV2Message,\n    })\n  }\n\n  public async getFormatData(\n    agentContext: AgentContext,\n    credentialExchangeId: string\n  ): Promise<GetCredentialFormatDataReturn<ExtractCredentialFormats<CFs>>> {\n    // TODO: we could looking at fetching all record using a single query and then filtering based on the type of the message.\n    const [proposalMessage, offerMessage, requestMessage, credentialMessage] = await Promise.all([\n      this.findProposalMessage(agentContext, credentialExchangeId),\n      this.findOfferMessage(agentContext, credentialExchangeId),\n      this.findRequestMessage(agentContext, credentialExchangeId),\n      this.findCredentialMessage(agentContext, credentialExchangeId),\n    ])\n\n    // Create object with the keys and the message formats/attachments. We can then loop over this in a generic\n    // way so we don't have to add the same operation code four times\n    const messages = {\n      proposal: [proposalMessage?.formats, proposalMessage?.proposalAttachments],\n      offer: [offerMessage?.formats, offerMessage?.offerAttachments],\n      request: [requestMessage?.formats, requestMessage?.requestAttachments],\n      credential: [credentialMessage?.formats, credentialMessage?.credentialAttachments],\n    } as const\n\n    const formatData: GetCredentialFormatDataReturn = {\n      proposalAttributes: proposalMessage?.credentialPreview?.attributes,\n      offerAttributes: offerMessage?.credentialPreview?.attributes,\n    }\n\n    // We loop through all of the message keys as defined above\n    for (const [messageKey, [formats, attachments]] of Object.entries(messages)) {\n      // Message can be undefined, so we continue if it is not defined\n      if (!formats || !attachments) continue\n\n      // Find all format services associated with the message\n      const formatServices = this.getFormatServicesFromMessage(formats)\n      const messageFormatData: CredentialFormatDataMessagePayload = {}\n\n      // Loop through all of the format services, for each we will extract the attachment data and assign this to the object\n      // using the unique format key (e.g. indy)\n      for (const formatService of formatServices) {\n        const attachment = this.credentialFormatCoordinator.getAttachmentForService(formatService, formats, attachments)\n\n        messageFormatData[formatService.formatKey] = attachment.getDataAsJson()\n      }\n\n      formatData[messageKey as Exclude<keyof GetCredentialFormatDataReturn, 'proposalAttributes' | 'offerAttributes'>] =\n        messageFormatData\n    }\n\n    return formatData\n  }\n\n  /**\n   * Get all the format service objects for a given credential format from an incoming message\n   * @param messageFormats the format objects containing the format name (eg indy)\n   * @return the credential format service objects in an array - derived from format object keys\n   */\n  private getFormatServicesFromMessage(\n    messageFormats: DidCommCredentialFormatSpec[]\n  ): DidCommCredentialFormatService[] {\n    const formatServices = new Set<DidCommCredentialFormatService>()\n\n    for (const msg of messageFormats) {\n      const service = this.getFormatServiceForFormat(msg.format)\n      if (service) formatServices.add(service)\n    }\n\n    return Array.from(formatServices)\n  }\n\n  /**\n   * Get all the format service objects for a given credential format\n   * @param credentialFormats the format object containing various optional parameters\n   * @return the credential format service objects in an array - derived from format object keys\n   */\n  private getFormatServices<M extends keyof DidCommCredentialFormat['credentialFormats']>(\n    credentialFormats: DidCommCredentialFormatPayload<ExtractCredentialFormats<CFs>, M>\n  ): DidCommCredentialFormatService[] {\n    const formats = new Set<DidCommCredentialFormatService>()\n\n    for (const formatKey of Object.keys(credentialFormats)) {\n      const formatService = this.getFormatServiceForFormatKey(formatKey)\n\n      if (formatService) formats.add(formatService)\n    }\n\n    return Array.from(formats)\n  }\n\n  private getFormatServiceForFormatKey(formatKey: string): DidCommCredentialFormatService | null {\n    const formatService = this.credentialFormats.find((credentialFormat) => credentialFormat.formatKey === formatKey)\n\n    return formatService ?? null\n  }\n\n  private getFormatServiceForFormat(format: string): DidCommCredentialFormatService | null {\n    const formatService = this.credentialFormats.find((credentialFormat) => credentialFormat.supportsFormat(format))\n\n    return formatService ?? null\n  }\n\n  protected getFormatServiceForRecordType(credentialRecordType: string) {\n    const formatService = this.credentialFormats.find(\n      (credentialFormat) => credentialFormat.credentialRecordType === credentialRecordType\n    )\n\n    if (!formatService) {\n      throw new CredoError(\n        `No format service found for credential record type ${credentialRecordType} in v2 credential protocol`\n      )\n    }\n\n    return formatService\n  }\n}\n"],"mappings":"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"}