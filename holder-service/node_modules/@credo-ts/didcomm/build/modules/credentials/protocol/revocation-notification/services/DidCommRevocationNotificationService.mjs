import { __decorate } from "../../../../../_virtual/_@oxc-project_runtime@0.110.0/helpers/decorate.mjs";
import { __decorateMetadata } from "../../../../../_virtual/_@oxc-project_runtime@0.110.0/helpers/decorateMetadata.mjs";
import { __decorateParam } from "../../../../../_virtual/_@oxc-project_runtime@0.110.0/helpers/decorateParam.mjs";
import "../../../../connections/index.mjs";
import { DidCommCredentialEventTypes } from "../../../DidCommCredentialEvents.mjs";
import { DidCommRevocationNotification } from "../../../models/DidCommRevocationNotification.mjs";
import { DidCommCredentialExchangeRepository } from "../../../repository/DidCommCredentialExchangeRepository.mjs";
import "../../../repository/index.mjs";
import { DidCommRevocationNotificationV2Message } from "../messages/DidCommRevocationNotificationV2Message.mjs";
import { v1ThreadRegex, v2AnonCredsRevocationFormat, v2AnonCredsRevocationIdentifierRegex, v2IndyRevocationFormat, v2IndyRevocationIdentifierRegex } from "../util/revocationIdentifier.mjs";
import { CredoError, EventEmitter, InjectionSymbols, inject, injectable } from "@credo-ts/core";

//#region src/modules/credentials/protocol/revocation-notification/services/DidCommRevocationNotificationService.ts
var _ref, _ref2;
let DidCommRevocationNotificationService = class DidCommRevocationNotificationService {
	constructor(credentialRepository, eventEmitter, logger) {
		this.credentialRepository = credentialRepository;
		this.eventEmitter = eventEmitter;
		this.logger = logger;
	}
	async processRevocationNotification(agentContext, anonCredsRevocationRegistryId, anonCredsCredentialRevocationId, connection, comment) {
		const query = { $or: [{
			anonCredsRevocationRegistryId,
			anonCredsCredentialRevocationId,
			connectionId: connection.id
		}, {
			anonCredsUnqualifiedRevocationRegistryId: anonCredsRevocationRegistryId,
			anonCredsCredentialRevocationId,
			connectionId: connection.id
		}] };
		this.logger.trace("Getting record by query for revocation notification:", query);
		const credentialExchangeRecord = await this.credentialRepository.getSingleByQuery(agentContext, query);
		credentialExchangeRecord.revocationNotification = new DidCommRevocationNotification(comment);
		await this.credentialRepository.update(agentContext, credentialExchangeRecord);
		this.logger.trace("Emitting DidCommRevocationNotificationReceivedEvent");
		this.eventEmitter.emit(agentContext, {
			type: DidCommCredentialEventTypes.DidCommRevocationNotificationReceived,
			payload: { credentialExchangeRecord: credentialExchangeRecord.clone() }
		});
	}
	/**
	* Process a received {@link DidCommRevocationNotificationV1Message}. This will create a
	* {@link DidCommRevocationNotification} and store it in the corresponding {@link CredentialRecord}
	*
	* @param messageContext message context of RevocationNotificationMessageV1
	*/
	async v1ProcessRevocationNotification(messageContext) {
		this.logger.info("Processing revocation notification v1", { message: messageContext.message });
		const threadId = messageContext.message.issueThread;
		try {
			const threadIdGroups = threadId.match(v1ThreadRegex);
			if (!threadIdGroups) throw new CredoError(`Incorrect revocation notification threadId format: \n${threadId}\ndoes not match\n"indy::<revocation_registry_id>::<credential_revocation_id>"`);
			const [, , anonCredsRevocationRegistryId, anonCredsCredentialRevocationId] = threadIdGroups;
			const comment = messageContext.message.comment;
			const connection = messageContext.assertReadyConnection();
			await this.processRevocationNotification(messageContext.agentContext, anonCredsRevocationRegistryId, anonCredsCredentialRevocationId, connection, comment);
		} catch (error) {
			this.logger.warn("Failed to process revocation notification message", {
				error,
				threadId
			});
		}
	}
	/**
	* Create a V2 Revocation Notification message
	*/
	async v2CreateRevocationNotification(options) {
		const { credentialId, revocationFormat, comment, requestAck } = options;
		const message = new DidCommRevocationNotificationV2Message({
			credentialId,
			revocationFormat,
			comment
		});
		if (requestAck) message.setPleaseAck();
		return { message };
	}
	/**
	* Process a received {@link DidCommRevocationNotificationV2Message}. This will create a
	* {@link DidCommRevocationNotification} and store it in the corresponding {@link CredentialRecord}
	*
	* @param messageContext message context of RevocationNotificationMessageV2
	*/
	async v2ProcessRevocationNotification(messageContext) {
		this.logger.info("Processing revocation notification v2", { message: messageContext.message });
		const credentialId = messageContext.message.credentialId;
		if (![v2IndyRevocationFormat, v2AnonCredsRevocationFormat].includes(messageContext.message.revocationFormat)) throw new CredoError(`Unknown revocation format: ${messageContext.message.revocationFormat}. Supported formats are indy-anoncreds and anoncreds`);
		try {
			const credentialIdGroups = credentialId.match(v2IndyRevocationIdentifierRegex) ?? credentialId.match(v2AnonCredsRevocationIdentifierRegex);
			if (!credentialIdGroups) throw new CredoError(`Incorrect revocation notification credentialId format: \n${credentialId}\ndoes not match\n"<revocation_registry_id>::<credential_revocation_id>"`);
			const [, anonCredsRevocationRegistryId, anonCredsCredentialRevocationId] = credentialIdGroups;
			const comment = messageContext.message.comment;
			const connection = messageContext.assertReadyConnection();
			await this.processRevocationNotification(messageContext.agentContext, anonCredsRevocationRegistryId, anonCredsCredentialRevocationId, connection, comment);
		} catch (error) {
			this.logger.warn("Failed to process revocation notification message", {
				error,
				credentialId
			});
		}
	}
};
DidCommRevocationNotificationService = __decorate([
	injectable(),
	__decorateParam(2, inject(InjectionSymbols.Logger)),
	__decorateMetadata("design:paramtypes", [
		typeof (_ref = typeof DidCommCredentialExchangeRepository !== "undefined" && DidCommCredentialExchangeRepository) === "function" ? _ref : Object,
		typeof (_ref2 = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _ref2 : Object,
		Object
	])
], DidCommRevocationNotificationService);

//#endregion
export { DidCommRevocationNotificationService };
//# sourceMappingURL=DidCommRevocationNotificationService.mjs.map