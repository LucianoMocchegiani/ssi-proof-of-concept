import { DidCommConnectionService } from "../../connections/services/DidCommConnectionService.mjs";
import "../../connections/index.mjs";
import { DidCommCredentialEventTypes } from "../DidCommCredentialEvents.mjs";
import { DidCommMessageRepository } from "../../../repository/DidCommMessageRepository.mjs";
import "../../../repository/index.mjs";
import { DidCommCredentialState } from "../models/DidCommCredentialState.mjs";
import { DidCommCredentialExchangeRepository } from "../repository/DidCommCredentialExchangeRepository.mjs";
import "../repository/index.mjs";
import { EventEmitter } from "@credo-ts/core";

//#region src/modules/credentials/protocol/DidCommBaseCredentialProtocol.ts
/**
* Base implementation of the DidCommCredentialProtocol that can be used as a foundation for implementing
* the DidCommCredentialProtocol interface.
*/
var DidCommBaseCredentialProtocol = class {
	/**
	* Process a received credential {@link DidCommProblemReportMessage}.
	*
	* @param messageContext The message context containing a credential problem report message
	* @returns credential record associated with the credential problem report message
	*/
	async processProblemReport(messageContext) {
		const { message: credentialProblemReportMessage, agentContext, connection } = messageContext;
		const connectionService = agentContext.dependencyManager.resolve(DidCommConnectionService);
		agentContext.config.logger.debug(`Processing problem report with message id ${credentialProblemReportMessage.id}`);
		const credentialExchangeRecord = await this.getByProperties(agentContext, { threadId: credentialProblemReportMessage.threadId });
		await connectionService.assertConnectionOrOutOfBandExchange(messageContext, { expectedConnectionId: credentialExchangeRecord.connectionId });
		if (!credentialExchangeRecord?.connectionId) {
			await connectionService.matchIncomingMessageToRequestMessageInOutOfBandExchange(messageContext, { expectedConnectionId: credentialExchangeRecord?.connectionId });
			credentialExchangeRecord.connectionId = connection?.id;
		}
		credentialExchangeRecord.errorMessage = `${credentialProblemReportMessage.description.code}: ${credentialProblemReportMessage.description.en}`;
		await this.updateState(agentContext, credentialExchangeRecord, DidCommCredentialState.Abandoned);
		return credentialExchangeRecord;
	}
	/**
	* Update the record to a new state and emit an state changed event. Also updates the record
	* in storage.
	*
	* @param credentialExchangeRecord The credential record to update the state for
	* @param newState The state to update to
	*
	*/
	async updateState(agentContext, credentialExchangeRecord, newState) {
		const credentialRepository = agentContext.dependencyManager.resolve(DidCommCredentialExchangeRepository);
		agentContext.config.logger.debug(`Updating credential record ${credentialExchangeRecord.id} to state ${newState} (previous=${credentialExchangeRecord.state})`);
		const previousState = credentialExchangeRecord.state;
		credentialExchangeRecord.state = newState;
		await credentialRepository.update(agentContext, credentialExchangeRecord);
		this.emitStateChangedEvent(agentContext, credentialExchangeRecord, previousState);
	}
	emitStateChangedEvent(agentContext, credentialExchangeRecord, previousState) {
		agentContext.dependencyManager.resolve(EventEmitter).emit(agentContext, {
			type: DidCommCredentialEventTypes.DidCommCredentialStateChanged,
			payload: {
				credentialExchangeRecord: credentialExchangeRecord.clone(),
				previousState
			}
		});
	}
	/**
	* Retrieve a credential record by id
	*
	* @param credentialRecordId The credential record id
	* @throws {RecordNotFoundError} If no record is found
	* @return The credential record
	*
	*/
	getById(agentContext, credentialRecordId) {
		return agentContext.dependencyManager.resolve(DidCommCredentialExchangeRepository).getById(agentContext, credentialRecordId);
	}
	/**
	* Retrieve all credential records
	*
	* @returns List containing all credential records
	*/
	getAll(agentContext) {
		return agentContext.dependencyManager.resolve(DidCommCredentialExchangeRepository).getAll(agentContext);
	}
	async findAllByQuery(agentContext, query, queryOptions) {
		return agentContext.dependencyManager.resolve(DidCommCredentialExchangeRepository).findByQuery(agentContext, query, queryOptions);
	}
	/**
	* Find a credential record by id
	*
	* @param credentialRecordId the credential record id
	* @returns The credential record or null if not found
	*/
	findById(agentContext, proofExchangeRecordId) {
		return agentContext.dependencyManager.resolve(DidCommCredentialExchangeRepository).findById(agentContext, proofExchangeRecordId);
	}
	async delete(agentContext, credentialExchangeRecord, options) {
		const credentialRepository = agentContext.dependencyManager.resolve(DidCommCredentialExchangeRepository);
		const didCommMessageRepository = agentContext.dependencyManager.resolve(DidCommMessageRepository);
		await credentialRepository.delete(agentContext, credentialExchangeRecord);
		const deleteAssociatedCredentials = options?.deleteAssociatedCredentials ?? true;
		const deleteAssociatedDidCommMessages = options?.deleteAssociatedDidCommMessages ?? true;
		if (deleteAssociatedCredentials) for (const credential of credentialExchangeRecord.credentials) await this.getFormatServiceForRecordType(credential.credentialRecordType).deleteCredentialById(agentContext, credential.credentialRecordId);
		if (deleteAssociatedDidCommMessages) {
			const didCommMessages = await didCommMessageRepository.findByQuery(agentContext, { associatedRecordId: credentialExchangeRecord.id });
			for (const didCommMessage of didCommMessages) await didCommMessageRepository.delete(agentContext, didCommMessage);
		}
	}
	/**
	* Retrieve a credential record by connection id and thread id
	*
	* @param properties Properties to query by
	*
	* @throws {RecordNotFoundError} If no record is found
	* @throws {RecordDuplicateError} If multiple records are found
	* @returns The credential record
	*/
	getByProperties(agentContext, properties) {
		const { role, connectionId, threadId } = properties;
		return agentContext.dependencyManager.resolve(DidCommCredentialExchangeRepository).getSingleByQuery(agentContext, {
			connectionId,
			threadId,
			role
		});
	}
	/**
	* Find a credential record by connection id and thread id, returns null if not found
	*
	* @param threadId The thread id
	* @param role The role of the record, i.e. holder or issuer
	* @param connectionId The connection id
	*
	* @returns The credential record
	*/
	findByProperties(agentContext, properties) {
		const { role, connectionId, threadId } = properties;
		return agentContext.dependencyManager.resolve(DidCommCredentialExchangeRepository).findSingleByQuery(agentContext, {
			connectionId,
			threadId,
			role
		});
	}
	async update(agentContext, credentialExchangeRecord) {
		return await agentContext.dependencyManager.resolve(DidCommCredentialExchangeRepository).update(agentContext, credentialExchangeRecord);
	}
};

//#endregion
export { DidCommBaseCredentialProtocol };
//# sourceMappingURL=DidCommBaseCredentialProtocol.mjs.map