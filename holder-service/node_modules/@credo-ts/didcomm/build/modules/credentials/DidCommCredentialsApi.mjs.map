{"version":3,"file":"DidCommCredentialsApi.mjs","names":[],"sources":["../../../src/modules/credentials/DidCommCredentialsApi.ts"],"sourcesContent":["import type { Query, QueryOptions } from '@credo-ts/core'\nimport { AgentContext, CredoError, InjectionSymbols, inject, injectable, type Logger } from '@credo-ts/core'\nimport { DidCommMessage } from '../../DidCommMessage'\nimport { DidCommMessageSender } from '../../DidCommMessageSender'\nimport { getOutboundDidCommMessageContext } from '../../getDidCommOutboundMessageContext'\nimport { DidCommConnectionRecord, DidCommConnectionService } from '../connections'\nimport type {\n  AcceptCredentialOfferOptions,\n  AcceptCredentialOptions,\n  AcceptCredentialProposalOptions,\n  AcceptCredentialRequestOptions,\n  CreateCredentialOfferOptions,\n  DeclineCredentialOfferOptions,\n  DeleteCredentialOptions,\n  FindCredentialMessageReturn,\n  FindCredentialOfferMessageReturn,\n  FindCredentialProposalMessageReturn,\n  FindCredentialRequestMessageReturn,\n  GetCredentialFormatDataReturn,\n  NegotiateCredentialOfferOptions,\n  NegotiateCredentialProposalOptions,\n  OfferCredentialOptions,\n  ProposeCredentialOptions,\n  SendCredentialProblemReportOptions,\n  SendRevocationNotificationOptions,\n} from './DidCommCredentialsApiOptions'\nimport { DidCommCredentialsModuleConfig } from './DidCommCredentialsModuleConfig'\nimport { DidCommCredentialState } from './models/DidCommCredentialState'\nimport type { DidCommCredentialProtocol } from './protocol/DidCommCredentialProtocol'\nimport type { CredentialFormatsFromProtocols } from './protocol/DidCommCredentialProtocolOptions'\nimport { DidCommRevocationNotificationService } from './protocol/revocation-notification/services'\nimport type { DidCommCredentialExchangeRecord } from './repository/DidCommCredentialExchangeRecord'\nimport { DidCommCredentialExchangeRepository } from './repository/DidCommCredentialExchangeRepository'\n\nexport interface DidCommCredentialsApi<CPs extends DidCommCredentialProtocol[]> {\n  // Propose Credential methods\n  proposeCredential(options: ProposeCredentialOptions<CPs>): Promise<DidCommCredentialExchangeRecord>\n  acceptProposal(options: AcceptCredentialProposalOptions<CPs>): Promise<DidCommCredentialExchangeRecord>\n  negotiateProposal(options: NegotiateCredentialProposalOptions<CPs>): Promise<DidCommCredentialExchangeRecord>\n\n  // Offer Credential Methods\n  offerCredential(options: OfferCredentialOptions<CPs>): Promise<DidCommCredentialExchangeRecord>\n  acceptOffer(options: AcceptCredentialOfferOptions<CPs>): Promise<DidCommCredentialExchangeRecord>\n  declineOffer(options: DeclineCredentialOfferOptions): Promise<DidCommCredentialExchangeRecord>\n  negotiateOffer(options: NegotiateCredentialOfferOptions<CPs>): Promise<DidCommCredentialExchangeRecord>\n\n  // Request Credential Methods\n  // This is for beginning the exchange with a request (no proposal or offer). Only possible\n  // (currently) with W3C. We will not implement this in phase I\n\n  // when the issuer accepts the request he issues the credential to the holder\n  acceptRequest(options: AcceptCredentialRequestOptions<CPs>): Promise<DidCommCredentialExchangeRecord>\n\n  // Issue Credential Methods\n  acceptCredential(options: AcceptCredentialOptions): Promise<DidCommCredentialExchangeRecord>\n\n  // Revoke Credential Methods\n  sendRevocationNotification(options: SendRevocationNotificationOptions): Promise<void>\n\n  // out of band\n  createOffer(options: CreateCredentialOfferOptions<CPs>): Promise<{\n    message: DidCommMessage\n    credentialExchangeRecord: DidCommCredentialExchangeRecord\n  }>\n\n  sendProblemReport(options: SendCredentialProblemReportOptions): Promise<DidCommCredentialExchangeRecord>\n\n  // Record Methods\n  getAll(): Promise<DidCommCredentialExchangeRecord[]>\n  findAllByQuery(\n    query: Query<DidCommCredentialExchangeRecord>,\n    queryOptions?: QueryOptions\n  ): Promise<DidCommCredentialExchangeRecord[]>\n  getById(credentialExchangeRecordId: string): Promise<DidCommCredentialExchangeRecord>\n  findById(credentialExchangeRecordId: string): Promise<DidCommCredentialExchangeRecord | null>\n  deleteById(credentialExchangeRecordId: string, options?: DeleteCredentialOptions): Promise<void>\n  update(credentialExchangeRecordId: DidCommCredentialExchangeRecord): Promise<void>\n  getFormatData(\n    credentialExchangeRecordId: string\n  ): Promise<GetCredentialFormatDataReturn<CredentialFormatsFromProtocols<CPs>>>\n\n  // DidComm Message Records\n  findProposalMessage(credentialExchangeRecordId: string): Promise<FindCredentialProposalMessageReturn<CPs>>\n  findOfferMessage(credentialExchangeRecordId: string): Promise<FindCredentialOfferMessageReturn<CPs>>\n  findRequestMessage(credentialExchangeRecordId: string): Promise<FindCredentialRequestMessageReturn<CPs>>\n  findCredentialMessage(credentialExchangeRecordId: string): Promise<FindCredentialMessageReturn<CPs>>\n}\n\n@injectable()\n// biome-ignore lint/suspicious/noUnsafeDeclarationMerging: no explanation\nexport class DidCommCredentialsApi<CPs extends DidCommCredentialProtocol[]> implements DidCommCredentialsApi<CPs> {\n  /**\n   * Configuration for the credentials module\n   */\n  public readonly config: DidCommCredentialsModuleConfig<CPs>\n\n  private connectionService: DidCommConnectionService\n  private messageSender: DidCommMessageSender\n  private credentialExchangeRepository: DidCommCredentialExchangeRepository\n  private agentContext: AgentContext\n  private revocationNotificationService: DidCommRevocationNotificationService\n  private logger: Logger\n\n  public constructor(\n    messageSender: DidCommMessageSender,\n    connectionService: DidCommConnectionService,\n    agentContext: AgentContext,\n    @inject(InjectionSymbols.Logger) logger: Logger,\n    credentialExchangeRepository: DidCommCredentialExchangeRepository,\n    revocationNotificationService: DidCommRevocationNotificationService,\n    config: DidCommCredentialsModuleConfig<CPs>\n  ) {\n    this.messageSender = messageSender\n    this.connectionService = connectionService\n    this.credentialExchangeRepository = credentialExchangeRepository\n    this.agentContext = agentContext\n    this.revocationNotificationService = revocationNotificationService\n    this.logger = logger\n    this.config = config\n  }\n\n  private getProtocol<PVT extends CPs[number]['version']>(protocolVersion: PVT): DidCommCredentialProtocol {\n    const credentialProtocol = this.config.credentialProtocols.find((protocol) => protocol.version === protocolVersion)\n\n    if (!credentialProtocol) {\n      throw new CredoError(`No credential protocol registered for protocol version ${protocolVersion}`)\n    }\n\n    return credentialProtocol\n  }\n\n  /**\n   * Initiate a new credential exchange as holder by sending a credential proposal message\n   * to the connection with the specified connection id.\n   *\n   * @param options configuration to use for the proposal\n   * @returns Credential exchange record associated with the sent proposal message\n   */\n\n  public async proposeCredential(options: ProposeCredentialOptions<CPs>): Promise<DidCommCredentialExchangeRecord> {\n    const protocol = this.getProtocol(options.protocolVersion)\n\n    const connectionRecord = await this.connectionService.getById(this.agentContext, options.connectionId)\n\n    // Assert\n    connectionRecord.assertReady()\n\n    // will get back a credential record -> map to Credential Exchange Record\n    const { credentialExchangeRecord, message } = await protocol.createProposal(this.agentContext, {\n      connectionRecord,\n      credentialFormats: options.credentialFormats,\n      comment: options.comment,\n      autoAcceptCredential: options.autoAcceptCredential,\n      goalCode: options.goalCode,\n      goal: options.goal,\n    })\n\n    const outboundMessageContext = await getOutboundDidCommMessageContext(this.agentContext, {\n      message,\n      associatedRecord: credentialExchangeRecord,\n      connectionRecord,\n    })\n\n    await this.messageSender.sendMessage(outboundMessageContext)\n    return credentialExchangeRecord\n  }\n\n  /**\n   * Accept a credential proposal as issuer (by sending a credential offer message) to the connection\n   * associated with the credential record.\n   *\n   * @param options config object for accepting the proposal\n   * @returns Credential exchange record associated with the credential offer\n   *\n   */\n  public async acceptProposal(options: AcceptCredentialProposalOptions<CPs>): Promise<DidCommCredentialExchangeRecord> {\n    const credentialExchangeRecord = await this.getById(options.credentialExchangeRecordId)\n\n    if (!credentialExchangeRecord.connectionId) {\n      throw new CredoError(\n        `No connectionId found for credential exchange record '${credentialExchangeRecord.id}'. Connection-less issuance does not support credential proposal or negotiation.`\n      )\n    }\n\n    // with version we can get the protocol\n    const protocol = this.getProtocol(credentialExchangeRecord.protocolVersion)\n    const connectionRecord = await this.connectionService.getById(\n      this.agentContext,\n      credentialExchangeRecord.connectionId\n    )\n\n    // Assert\n    connectionRecord.assertReady()\n\n    // will get back a credential record -> map to Credential Exchange Record\n    const { message } = await protocol.acceptProposal(this.agentContext, {\n      credentialExchangeRecord,\n      credentialFormats: options.credentialFormats,\n      comment: options.comment,\n      autoAcceptCredential: options.autoAcceptCredential,\n      goalCode: options.goalCode,\n      goal: options.goal,\n    })\n\n    // send the message\n    const outboundMessageContext = await getOutboundDidCommMessageContext(this.agentContext, {\n      message,\n      associatedRecord: credentialExchangeRecord,\n      connectionRecord,\n    })\n    await this.messageSender.sendMessage(outboundMessageContext)\n\n    return credentialExchangeRecord\n  }\n\n  /**\n   * Negotiate a credential proposal as issuer (by sending a credential offer message) to the connection\n   * associated with the credential record.\n   *\n   * @param options configuration for the offer see {@link NegotiateCredentialProposalOptions}\n   * @returns Credential exchange record associated with the credential offer\n   *\n   */\n  public async negotiateProposal(\n    options: NegotiateCredentialProposalOptions<CPs>\n  ): Promise<DidCommCredentialExchangeRecord> {\n    const credentialExchangeRecord = await this.getById(options.credentialExchangeRecordId)\n\n    if (!credentialExchangeRecord.connectionId) {\n      throw new CredoError(\n        `No connection id for credential record ${credentialExchangeRecord.id} not found. Connection-less issuance does not support negotiation`\n      )\n    }\n\n    // with version we can get the Service\n    const protocol = this.getProtocol(credentialExchangeRecord.protocolVersion)\n\n    const { message } = await protocol.negotiateProposal(this.agentContext, {\n      credentialExchangeRecord,\n      credentialFormats: options.credentialFormats,\n      comment: options.comment,\n      autoAcceptCredential: options.autoAcceptCredential,\n      goalCode: options.goalCode,\n      goal: options.goal,\n    })\n\n    const connectionRecord = await this.connectionService.getById(\n      this.agentContext,\n      credentialExchangeRecord.connectionId\n    )\n    const outboundMessageContext = await getOutboundDidCommMessageContext(this.agentContext, {\n      message,\n      associatedRecord: credentialExchangeRecord,\n      connectionRecord,\n    })\n    await this.messageSender.sendMessage(outboundMessageContext)\n\n    return credentialExchangeRecord\n  }\n\n  /**\n   * Initiate a new credential exchange as issuer by sending a credential offer message\n   * to the connection with the specified connection id.\n   *\n   * @param options config options for the credential offer\n   * @returns Credential exchange record associated with the sent credential offer message\n   */\n  public async offerCredential(options: OfferCredentialOptions<CPs>): Promise<DidCommCredentialExchangeRecord> {\n    const connectionRecord = await this.connectionService.getById(this.agentContext, options.connectionId)\n    const protocol = this.getProtocol(options.protocolVersion)\n\n    this.logger.debug(`Got a credentialProtocol object for version ${options.protocolVersion}`)\n\n    const { message, credentialExchangeRecord } = await protocol.createOffer(this.agentContext, {\n      credentialFormats: options.credentialFormats,\n      autoAcceptCredential: options.autoAcceptCredential,\n      comment: options.comment,\n      connectionRecord,\n      goalCode: options.goalCode,\n      goal: options.goal,\n    })\n\n    this.logger.debug('Offer Message successfully created; message= ', message)\n    const outboundMessageContext = await getOutboundDidCommMessageContext(this.agentContext, {\n      message,\n      associatedRecord: credentialExchangeRecord,\n      connectionRecord,\n    })\n    await this.messageSender.sendMessage(outboundMessageContext)\n\n    return credentialExchangeRecord\n  }\n\n  /**\n   * Accept a credential offer as holder (by sending a credential request message) to the connection\n   * associated with the credential record.\n   *\n   * @param options The object containing config options of the offer to be accepted\n   * @returns Object containing offer associated credential record\n   */\n  public async acceptOffer(options: AcceptCredentialOfferOptions<CPs>): Promise<DidCommCredentialExchangeRecord> {\n    const credentialExchangeRecord = await this.getById(options.credentialExchangeRecordId)\n\n    const protocol = this.getProtocol(credentialExchangeRecord.protocolVersion)\n\n    this.logger.debug(`Got a credentialProtocol object for this version; version = ${protocol.version}`)\n    const offerMessage = await protocol.findOfferMessage(this.agentContext, credentialExchangeRecord.id)\n    if (!offerMessage) {\n      throw new CredoError(`No offer message found for credential record with id '${credentialExchangeRecord.id}'`)\n    }\n\n    // Use connection if present\n    const connectionRecord = credentialExchangeRecord.connectionId\n      ? await this.connectionService.getById(this.agentContext, credentialExchangeRecord.connectionId)\n      : undefined\n    connectionRecord?.assertReady()\n\n    const { message } = await protocol.acceptOffer(this.agentContext, {\n      credentialExchangeRecord,\n      credentialFormats: options.credentialFormats,\n      comment: options.comment,\n      autoAcceptCredential: options.autoAcceptCredential,\n      goalCode: options.goalCode,\n      goal: options.goal,\n    })\n\n    const outboundMessageContext = await getOutboundDidCommMessageContext(this.agentContext, {\n      message,\n      connectionRecord,\n      associatedRecord: credentialExchangeRecord,\n      lastReceivedMessage: offerMessage,\n    })\n    await this.messageSender.sendMessage(outboundMessageContext)\n\n    return credentialExchangeRecord\n  }\n\n  public async declineOffer(options: DeclineCredentialOfferOptions): Promise<DidCommCredentialExchangeRecord> {\n    const credentialExchangeRecord = await this.getById(options.credentialExchangeRecordId)\n    credentialExchangeRecord.assertState(DidCommCredentialState.OfferReceived)\n\n    // with version we can get the Service\n    const protocol = this.getProtocol(credentialExchangeRecord.protocolVersion)\n    if (options.sendProblemReport) {\n      await this.sendProblemReport({\n        credentialExchangeRecordId: options.credentialExchangeRecordId,\n        description: options.problemReportDescription ?? 'Offer declined',\n      })\n    }\n\n    await protocol.updateState(this.agentContext, credentialExchangeRecord, DidCommCredentialState.Declined)\n\n    return credentialExchangeRecord\n  }\n\n  public async negotiateOffer(options: NegotiateCredentialOfferOptions<CPs>): Promise<DidCommCredentialExchangeRecord> {\n    const credentialExchangeRecord = await this.getById(options.credentialExchangeRecordId)\n\n    if (!credentialExchangeRecord.connectionId) {\n      throw new CredoError(\n        `No connection id for credential record ${credentialExchangeRecord.id} not found. Connection-less issuance does not support negotiation`\n      )\n    }\n\n    const connectionRecord = await this.connectionService.getById(\n      this.agentContext,\n      credentialExchangeRecord.connectionId\n    )\n\n    // Assert\n    connectionRecord.assertReady()\n\n    const protocol = this.getProtocol(credentialExchangeRecord.protocolVersion)\n    const { message } = await protocol.negotiateOffer(this.agentContext, {\n      credentialFormats: options.credentialFormats,\n      credentialExchangeRecord,\n      comment: options.comment,\n      autoAcceptCredential: options.autoAcceptCredential,\n      goalCode: options.goalCode,\n      goal: options.goal,\n    })\n\n    const outboundMessageContext = await getOutboundDidCommMessageContext(this.agentContext, {\n      message,\n      associatedRecord: credentialExchangeRecord,\n      connectionRecord,\n    })\n    await this.messageSender.sendMessage(outboundMessageContext)\n\n    return credentialExchangeRecord\n  }\n\n  /**\n   * Initiate a new credential exchange as issuer by creating a credential offer\n   * not bound to any connection. The offer must be delivered out-of-band to the holder\n   * @param options The credential options to use for the offer\n   * @returns The credential record and credential offer message\n   */\n  public async createOffer(options: CreateCredentialOfferOptions<CPs>): Promise<{\n    message: DidCommMessage\n    credentialExchangeRecord: DidCommCredentialExchangeRecord\n  }> {\n    const protocol = this.getProtocol(options.protocolVersion)\n\n    this.logger.debug(`Got a credentialProtocol object for version ${options.protocolVersion}`)\n    const { message, credentialExchangeRecord } = await protocol.createOffer(this.agentContext, {\n      credentialFormats: options.credentialFormats,\n      comment: options.comment,\n      autoAcceptCredential: options.autoAcceptCredential,\n      goalCode: options.goalCode,\n      goal: options.goal,\n    })\n\n    this.logger.debug('Offer Message successfully created', { message })\n\n    return { message, credentialExchangeRecord }\n  }\n\n  /**\n   * Accept a credential request as holder (by sending a credential request message) to the connection\n   * associated with the credential record.\n   *\n   * @param options The object containing config options of the request\n   * @returns DidCommCredentialExchangeRecord updated with information pertaining to this request\n   */\n  public async acceptRequest(options: AcceptCredentialRequestOptions<CPs>): Promise<DidCommCredentialExchangeRecord> {\n    const credentialExchangeRecord = await this.getById(options.credentialExchangeRecordId)\n\n    // with version we can get the Service\n    const protocol = this.getProtocol(credentialExchangeRecord.protocolVersion)\n\n    this.logger.debug(`Got a credentialProtocol object for version ${credentialExchangeRecord.protocolVersion}`)\n\n    // Use connection if present\n    const connectionRecord = credentialExchangeRecord.connectionId\n      ? await this.connectionService.getById(this.agentContext, credentialExchangeRecord.connectionId)\n      : undefined\n    connectionRecord?.assertReady()\n\n    const requestMessage = await protocol.findRequestMessage(this.agentContext, credentialExchangeRecord.id)\n    if (!requestMessage) {\n      throw new CredoError(`No request message found for credential record with id '${credentialExchangeRecord.id}'`)\n    }\n    const offerMessage = await protocol.findOfferMessage(this.agentContext, credentialExchangeRecord.id)\n    if (!offerMessage) {\n      throw new CredoError(`No offer message found for credential record with id '${credentialExchangeRecord.id}'`)\n    }\n\n    const { message } = await protocol.acceptRequest(this.agentContext, {\n      credentialExchangeRecord,\n      credentialFormats: options.credentialFormats,\n      comment: options.comment,\n      autoAcceptCredential: options.autoAcceptCredential,\n    })\n    this.logger.debug('We have a credential message (sending outbound): ', message)\n\n    const outboundMessageContext = await getOutboundDidCommMessageContext(this.agentContext, {\n      message,\n      connectionRecord,\n      associatedRecord: credentialExchangeRecord,\n      lastReceivedMessage: requestMessage,\n      lastSentMessage: offerMessage,\n    })\n    await this.messageSender.sendMessage(outboundMessageContext)\n\n    return credentialExchangeRecord\n  }\n\n  /**\n   * Accept a credential as holder (by sending a credential acknowledgement message) to the connection\n   * associated with the credential record.\n   *\n   * @param credentialExchangeRecordId The id of the credential exchange record for which to accept the credential\n   * @returns credential exchange record associated with the sent credential acknowledgement message\n   *\n   */\n  public async acceptCredential(options: AcceptCredentialOptions): Promise<DidCommCredentialExchangeRecord> {\n    const credentialExchangeRecord = await this.getById(options.credentialExchangeRecordId)\n\n    // with version we can get the Service\n    const protocol = this.getProtocol(credentialExchangeRecord.protocolVersion)\n\n    this.logger.debug(`Got a credentialProtocol object for version ${credentialExchangeRecord.protocolVersion}`)\n\n    // Use connection if present\n    const connectionRecord = credentialExchangeRecord.connectionId\n      ? await this.connectionService.getById(this.agentContext, credentialExchangeRecord.connectionId)\n      : undefined\n    connectionRecord?.assertReady()\n\n    const requestMessage = await protocol.findRequestMessage(this.agentContext, credentialExchangeRecord.id)\n    if (!requestMessage) {\n      throw new CredoError(`No request message found for credential record with id '${credentialExchangeRecord.id}'`)\n    }\n    const credentialMessage = await protocol.findCredentialMessage(this.agentContext, credentialExchangeRecord.id)\n    if (!credentialMessage) {\n      throw new CredoError(`No credential message found for credential record with id '${credentialExchangeRecord.id}'`)\n    }\n\n    const { message } = await protocol.acceptCredential(this.agentContext, {\n      credentialExchangeRecord,\n    })\n\n    const outboundMessageContext = await getOutboundDidCommMessageContext(this.agentContext, {\n      message,\n      connectionRecord,\n      associatedRecord: credentialExchangeRecord,\n      lastReceivedMessage: credentialMessage,\n    })\n    await this.messageSender.sendMessage(outboundMessageContext)\n\n    return credentialExchangeRecord\n  }\n\n  /**\n   * Send a revocation notification to a connectionId related to a given revocationId and format.\n   * Currently, Revocation Notification V2 protocol is supported.\n   *\n   * @param credentialExchangeId credential exchange record. If not present, connectionId must be present\n   * @param connectionId The id of the connection to send the revocation notification. If not present, credentialExchangeId will be used to\n   * determine connection/service endpoints details\n   * @param revocationFormat Revocation credential identification format, as specified in Aries RFC 0721 (e.g. anoncreds)\n   * @param revocationId Format specific revocation id, as specified in Aries RFC 0721 (e.g. did:indy:entity:revregsdef123::credentialIndex)\n   */\n  public async sendRevocationNotification(options: SendRevocationNotificationOptions): Promise<void> {\n    const { connectionId, credentialExchangeRecordId, revocationId, revocationFormat, comment, requestAck } = options\n\n    let credentialExchangeRecord: DidCommCredentialExchangeRecord | undefined\n    let connectionRecord: DidCommConnectionRecord | undefined\n    let credentialMessage: DidCommMessage | undefined\n    let requestMessage: DidCommMessage | undefined\n\n    if (credentialExchangeRecordId) {\n      credentialExchangeRecord = await this.getById(credentialExchangeRecordId)\n      if (credentialExchangeRecord.connectionId) {\n        connectionRecord = await this.connectionService.getById(\n          this.agentContext,\n          credentialExchangeRecord.connectionId\n        )\n        connectionRecord.assertReady()\n      }\n\n      const protocol = this.getProtocol(credentialExchangeRecord.protocolVersion)\n      credentialMessage =\n        (await protocol.findCredentialMessage(this.agentContext, credentialExchangeRecordId)) ?? undefined\n      requestMessage = (await protocol.findRequestMessage(this.agentContext, credentialExchangeRecordId)) ?? undefined\n    } else if (connectionId) {\n      connectionRecord = await this.connectionService.getById(this.agentContext, connectionId)\n      connectionRecord.assertReady()\n    } else {\n      throw new CredoError('Either credentialExchangeId or connectionId must be defined')\n    }\n\n    if (!connectionId && !credentialMessage) {\n      throw new CredoError('No associated DIDComm connection was found for the revocation notification')\n    }\n\n    const { message } = await this.revocationNotificationService.v2CreateRevocationNotification({\n      credentialId: revocationId,\n      revocationFormat,\n      comment,\n      requestAck,\n    })\n\n    const outboundMessageContext = await getOutboundDidCommMessageContext(this.agentContext, {\n      message,\n      connectionRecord,\n      associatedRecord: credentialExchangeRecord,\n      lastSentMessage: credentialMessage,\n      lastReceivedMessage: requestMessage,\n    })\n    await this.messageSender.sendMessage(outboundMessageContext)\n  }\n\n  /**\n   * Send problem report message for a credential record\n   * @param credentialExchangeRecordId The id of the credential exchange record for which to send problem report\n   * @returns credential record associated with the credential problem report message\n   */\n  public async sendProblemReport(options: SendCredentialProblemReportOptions) {\n    const credentialExchangeRecord = await this.getById(options.credentialExchangeRecordId)\n\n    const protocol = this.getProtocol(credentialExchangeRecord.protocolVersion)\n\n    const offerMessage = await protocol.findOfferMessage(this.agentContext, credentialExchangeRecord.id)\n\n    const { message: problemReport } = await protocol.createProblemReport(this.agentContext, {\n      description: options.description,\n      credentialExchangeRecord,\n    })\n\n    // Use connection if present\n    const connectionRecord = credentialExchangeRecord.connectionId\n      ? await this.connectionService.getById(this.agentContext, credentialExchangeRecord.connectionId)\n      : undefined\n    connectionRecord?.assertReady()\n\n    // If there's no connection (so connection-less, we require the state to be offer received)\n    if (!connectionRecord) {\n      credentialExchangeRecord.assertState(DidCommCredentialState.OfferReceived)\n\n      if (!offerMessage) {\n        throw new CredoError(`No offer message found for credential record with id '${credentialExchangeRecord.id}'`)\n      }\n    }\n\n    const outboundMessageContext = await getOutboundDidCommMessageContext(this.agentContext, {\n      message: problemReport,\n      connectionRecord,\n      associatedRecord: credentialExchangeRecord,\n      lastReceivedMessage: offerMessage ?? undefined,\n    })\n    await this.messageSender.sendMessage(outboundMessageContext)\n\n    return credentialExchangeRecord\n  }\n\n  public async getFormatData(\n    credentialRecordId: string\n  ): Promise<GetCredentialFormatDataReturn<CredentialFormatsFromProtocols<CPs>>> {\n    const credentialExchangeRecord = await this.getById(credentialRecordId)\n    const protocol = this.getProtocol(credentialExchangeRecord.protocolVersion)\n\n    return protocol.getFormatData(this.agentContext, credentialRecordId)\n  }\n\n  /**\n   * Retrieve a credential record by id\n   *\n   * @param credentialRecordId The credential record id\n   * @throws {RecordNotFoundError} If no record is found\n   * @return The credential record\n   *\n   */\n  public getById(credentialRecordId: string): Promise<DidCommCredentialExchangeRecord> {\n    return this.credentialExchangeRepository.getById(this.agentContext, credentialRecordId)\n  }\n\n  /**\n   * Retrieve all credential records\n   *\n   * @returns List containing all credential records\n   */\n  public getAll(): Promise<DidCommCredentialExchangeRecord[]> {\n    return this.credentialExchangeRepository.getAll(this.agentContext)\n  }\n\n  /**\n   * Retrieve all credential records by specified query params\n   *\n   * @returns List containing all credential records matching specified query paramaters\n   */\n  public findAllByQuery(query: Query<DidCommCredentialExchangeRecord>, queryOptions?: QueryOptions) {\n    return this.credentialExchangeRepository.findByQuery(this.agentContext, query, queryOptions)\n  }\n\n  /**\n   * Find a credential record by id\n   *\n   * @param credentialRecordId the credential record id\n   * @returns The credential record or null if not found\n   */\n  public findById(credentialRecordId: string): Promise<DidCommCredentialExchangeRecord | null> {\n    return this.credentialExchangeRepository.findById(this.agentContext, credentialRecordId)\n  }\n\n  /**\n   * Delete a credential record by id, also calls service to delete from wallet\n   *\n   * @param credentialId the credential record id\n   * @param options the delete credential options for the delete operation\n   */\n  public async deleteById(credentialId: string, options?: DeleteCredentialOptions) {\n    const credentialExchangeRecord = await this.getById(credentialId)\n    const protocol = this.getProtocol(credentialExchangeRecord.protocolVersion)\n    return protocol.delete(this.agentContext, credentialExchangeRecord, options)\n  }\n\n  /**\n   * Update a credential exchange record\n   *\n   * @param credentialExchangeRecord the credential exchange record\n   */\n  public async update(credentialExchangeRecord: DidCommCredentialExchangeRecord): Promise<void> {\n    await this.credentialExchangeRepository.update(this.agentContext, credentialExchangeRecord)\n  }\n\n  public async findProposalMessage(credentialExchangeId: string): Promise<FindCredentialProposalMessageReturn<CPs>> {\n    const protocol = await this.getServiceForCredentialExchangeId(credentialExchangeId)\n\n    return protocol.findProposalMessage(\n      this.agentContext,\n      credentialExchangeId\n    ) as FindCredentialProposalMessageReturn<CPs>\n  }\n\n  public async findOfferMessage(credentialExchangeId: string): Promise<FindCredentialOfferMessageReturn<CPs>> {\n    const protocol = await this.getServiceForCredentialExchangeId(credentialExchangeId)\n\n    return protocol.findOfferMessage(this.agentContext, credentialExchangeId) as FindCredentialOfferMessageReturn<CPs>\n  }\n\n  public async findRequestMessage(credentialExchangeId: string): Promise<FindCredentialRequestMessageReturn<CPs>> {\n    const protocol = await this.getServiceForCredentialExchangeId(credentialExchangeId)\n\n    return protocol.findRequestMessage(\n      this.agentContext,\n      credentialExchangeId\n    ) as FindCredentialRequestMessageReturn<CPs>\n  }\n\n  public async findCredentialMessage(credentialExchangeId: string): Promise<FindCredentialMessageReturn<CPs>> {\n    const protocol = await this.getServiceForCredentialExchangeId(credentialExchangeId)\n\n    return protocol.findCredentialMessage(this.agentContext, credentialExchangeId) as FindCredentialMessageReturn<CPs>\n  }\n\n  private async getServiceForCredentialExchangeId(credentialExchangeId: string) {\n    const credentialExchangeRecord = await this.getById(credentialExchangeId)\n\n    return this.getProtocol(credentialExchangeRecord.protocolVersion)\n  }\n}\n"],"mappings":"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"}