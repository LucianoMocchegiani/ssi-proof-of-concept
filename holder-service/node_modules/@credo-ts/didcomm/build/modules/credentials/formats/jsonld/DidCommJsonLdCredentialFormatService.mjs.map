{"version":3,"file":"DidCommJsonLdCredentialFormatService.mjs","names":[],"sources":["../../../../../src/modules/credentials/formats/jsonld/DidCommJsonLdCredentialFormatService.ts"],"sourcesContent":["import type { AgentContext } from '@credo-ts/core'\nimport {\n  ClaimFormat,\n  CredoError,\n  DidResolverService,\n  findVerificationMethodByKeyType,\n  JsonEncoder,\n  JsonTransformer,\n  utils,\n  W3cCredential,\n  W3cCredentialRecord,\n  W3cCredentialService,\n  W3cJsonLdCredentialService,\n  W3cJsonLdVerifiableCredential,\n} from '@credo-ts/core'\nimport { DidCommAttachment, DidCommAttachmentData } from '../../../../decorators/attachment/DidCommAttachment'\nimport { DidCommCredentialFormatSpec } from '../../models/DidCommCredentialFormatSpec'\nimport type { DidCommCredentialFormatService } from '../DidCommCredentialFormatService'\nimport type {\n  DidCommCredentialFormatAcceptOfferOptions,\n  DidCommCredentialFormatAcceptProposalOptions,\n  DidCommCredentialFormatAcceptRequestOptions,\n  DidCommCredentialFormatAutoRespondCredentialOptions,\n  DidCommCredentialFormatAutoRespondOfferOptions,\n  DidCommCredentialFormatAutoRespondProposalOptions,\n  DidCommCredentialFormatAutoRespondRequestOptions,\n  DidCommCredentialFormatCreateOfferOptions,\n  DidCommCredentialFormatCreateOfferReturn,\n  DidCommCredentialFormatCreateProposalOptions,\n  DidCommCredentialFormatCreateProposalReturn,\n  DidCommCredentialFormatCreateRequestOptions,\n  DidCommCredentialFormatCreateReturn,\n  DidCommCredentialFormatProcessCredentialOptions,\n  DidCommCredentialFormatProcessOptions,\n} from '../DidCommCredentialFormatServiceOptions'\nimport { DidCommJsonLdCredentialDetail } from './DidCommJsonLdCredentialDetail'\nimport type {\n  DidCommJsonLdCredentialFormat,\n  JsonCredential,\n  JsonLdFormatDataCredentialDetail,\n  JsonLdFormatDataVerifiableCredential,\n} from './DidCommJsonLdCredentialFormat'\n\nconst JSONLD_VC_DETAIL = 'aries/ld-proof-vc-detail@v1.0'\nconst JSONLD_VC = 'aries/ld-proof-vc@v1.0'\n\nexport class DidCommJsonLdCredentialFormatService\n  implements DidCommCredentialFormatService<DidCommJsonLdCredentialFormat>\n{\n  public readonly formatKey = 'jsonld' as const\n  public readonly credentialRecordType = 'w3c' as const\n\n  /**\n   * Create a {@link AttachmentFormats} object dependent on the message type.\n   *\n   * @param options The object containing all the options for the proposed credential\n   * @returns object containing associated attachment, formats and filtersAttach elements\n   *\n   */\n  public async createProposal(\n    _agentContext: AgentContext,\n    { credentialFormats }: DidCommCredentialFormatCreateProposalOptions<DidCommJsonLdCredentialFormat>\n  ): Promise<DidCommCredentialFormatCreateProposalReturn> {\n    const format = new DidCommCredentialFormatSpec({\n      format: JSONLD_VC_DETAIL,\n    })\n\n    const jsonLdFormat = credentialFormats.jsonld\n    if (!jsonLdFormat) {\n      throw new CredoError('Missing jsonld payload in createProposal')\n    }\n\n    // this does the validation\n    JsonTransformer.fromJSON(jsonLdFormat.credential, DidCommJsonLdCredentialDetail)\n\n    // jsonLdFormat is now of type JsonLdFormatDataCredentialDetail\n    const attachment = this.getFormatData(jsonLdFormat, format.attachmentId)\n    return { format, attachment }\n  }\n\n  /**\n   * Method called on reception of a propose credential message\n   * @param options the options needed to accept the proposal\n   */\n  public async processProposal(\n    _agentContext: AgentContext,\n    { attachment }: DidCommCredentialFormatProcessOptions\n  ): Promise<void> {\n    const credProposalJson = attachment.getDataAsJson<JsonLdFormatDataCredentialDetail>()\n\n    if (!credProposalJson) {\n      throw new CredoError('Missing jsonld credential proposal data payload')\n    }\n\n    // validation is done in here\n    JsonTransformer.fromJSON(credProposalJson, DidCommJsonLdCredentialDetail)\n  }\n\n  public async acceptProposal(\n    _agentContext: AgentContext,\n    { attachmentId, proposalAttachment }: DidCommCredentialFormatAcceptProposalOptions<DidCommJsonLdCredentialFormat>\n  ): Promise<DidCommCredentialFormatCreateOfferReturn> {\n    // if the offer has an attachment Id use that, otherwise the generated id of the formats object\n    const format = new DidCommCredentialFormatSpec({\n      attachmentId,\n      format: JSONLD_VC_DETAIL,\n    })\n\n    const credentialProposal = proposalAttachment.getDataAsJson<JsonLdFormatDataCredentialDetail>()\n    JsonTransformer.fromJSON(credentialProposal, DidCommJsonLdCredentialDetail)\n\n    const offerData = credentialProposal\n\n    const attachment = this.getFormatData(offerData, format.attachmentId)\n\n    return { format, attachment }\n  }\n\n  /**\n   * Create a {@link AttachmentFormats} object dependent on the message type.\n   *\n   * @param options The object containing all the options for the credential offer\n   * @returns object containing associated attachment, formats and offersAttach elements\n   *\n   */\n  public async createOffer(\n    _agentContext: AgentContext,\n    { credentialFormats, attachmentId }: DidCommCredentialFormatCreateOfferOptions<DidCommJsonLdCredentialFormat>\n  ): Promise<DidCommCredentialFormatCreateOfferReturn> {\n    // if the offer has an attachment Id use that, otherwise the generated id of the formats object\n    const format = new DidCommCredentialFormatSpec({\n      attachmentId,\n      format: JSONLD_VC_DETAIL,\n    })\n\n    const jsonLdFormat = credentialFormats?.jsonld\n    if (!jsonLdFormat) {\n      throw new CredoError('Missing jsonld payload in createOffer')\n    }\n\n    // validate\n    JsonTransformer.fromJSON(jsonLdFormat.credential, DidCommJsonLdCredentialDetail)\n\n    const attachment = this.getFormatData(jsonLdFormat, format.attachmentId)\n\n    return { format, attachment }\n  }\n\n  public async processOffer(_agentContext: AgentContext, { attachment }: DidCommCredentialFormatProcessOptions) {\n    const credentialOfferJson = attachment.getDataAsJson<JsonLdFormatDataCredentialDetail>()\n\n    if (!credentialOfferJson) {\n      throw new CredoError('Missing jsonld credential offer data payload')\n    }\n\n    JsonTransformer.fromJSON(credentialOfferJson, DidCommJsonLdCredentialDetail)\n  }\n\n  public async acceptOffer(\n    _agentContext: AgentContext,\n    { attachmentId, offerAttachment }: DidCommCredentialFormatAcceptOfferOptions<DidCommJsonLdCredentialFormat>\n  ): Promise<DidCommCredentialFormatCreateReturn> {\n    const credentialOffer = offerAttachment.getDataAsJson<JsonLdFormatDataCredentialDetail>()\n\n    // validate\n    JsonTransformer.fromJSON(credentialOffer, DidCommJsonLdCredentialDetail)\n\n    const format = new DidCommCredentialFormatSpec({\n      attachmentId,\n      format: JSONLD_VC_DETAIL,\n    })\n\n    const attachment = this.getFormatData(credentialOffer, format.attachmentId)\n    return { format, attachment }\n  }\n\n  /**\n   * Create a credential attachment format for a credential request.\n   *\n   * @param options The object containing all the options for the credential request is derived\n   * @returns object containing associated attachment, formats and requestAttach elements\n   *\n   */\n  public async createRequest(\n    _agentContext: AgentContext,\n    { credentialFormats }: DidCommCredentialFormatCreateRequestOptions<DidCommJsonLdCredentialFormat>\n  ): Promise<DidCommCredentialFormatCreateReturn> {\n    const jsonLdFormat = credentialFormats?.jsonld\n\n    const format = new DidCommCredentialFormatSpec({\n      format: JSONLD_VC_DETAIL,\n    })\n\n    if (!jsonLdFormat) {\n      throw new CredoError('Missing jsonld payload in createRequest')\n    }\n\n    // this does the validation\n    JsonTransformer.fromJSON(jsonLdFormat.credential, DidCommJsonLdCredentialDetail)\n\n    const attachment = this.getFormatData(jsonLdFormat, format.attachmentId)\n\n    return { format, attachment }\n  }\n\n  public async processRequest(\n    _agentContext: AgentContext,\n    { attachment }: DidCommCredentialFormatProcessOptions\n  ): Promise<void> {\n    const requestJson = attachment.getDataAsJson<JsonLdFormatDataCredentialDetail>()\n\n    if (!requestJson) {\n      throw new CredoError('Missing jsonld credential request data payload')\n    }\n\n    // validate\n    JsonTransformer.fromJSON(requestJson, DidCommJsonLdCredentialDetail)\n  }\n\n  public async acceptRequest(\n    agentContext: AgentContext,\n    {\n      credentialFormats,\n      attachmentId,\n      requestAttachment,\n    }: DidCommCredentialFormatAcceptRequestOptions<DidCommJsonLdCredentialFormat>\n  ): Promise<DidCommCredentialFormatCreateReturn> {\n    const w3cJsonLdCredentialService = agentContext.dependencyManager.resolve(W3cJsonLdCredentialService)\n\n    // sign credential here. credential to be signed is received as the request attachment\n    // (attachment in the request message from holder to issuer)\n    const credentialRequest = requestAttachment.getDataAsJson<JsonLdFormatDataCredentialDetail>()\n\n    const verificationMethod =\n      credentialFormats?.jsonld?.verificationMethod ??\n      (await this.deriveVerificationMethod(agentContext, credentialRequest.credential, credentialRequest))\n\n    if (!verificationMethod) {\n      throw new CredoError('Missing verification method in credential data')\n    }\n    const format = new DidCommCredentialFormatSpec({\n      attachmentId,\n      format: JSONLD_VC,\n    })\n\n    const options = credentialRequest.options\n\n    // Get a list of fields found in the options that are not supported at the moment\n    const unsupportedFields = ['challenge', 'domain', 'credentialStatus', 'created'] as const\n    const foundFields = unsupportedFields.filter((field) => options[field] !== undefined)\n\n    if (foundFields.length > 0) {\n      throw new CredoError(`Some fields are not currently supported in credential options: ${foundFields.join(', ')}`)\n    }\n\n    const credential = JsonTransformer.fromJSON(credentialRequest.credential, W3cCredential)\n\n    const verifiableCredential = await w3cJsonLdCredentialService.signCredential(agentContext, {\n      format: ClaimFormat.LdpVc,\n      credential,\n      proofType: credentialRequest.options.proofType,\n      verificationMethod: verificationMethod,\n    })\n\n    const attachment = this.getFormatData(JsonTransformer.toJSON(verifiableCredential), format.attachmentId)\n    return { format, attachment }\n  }\n\n  /**\n   * Derive a verification method using the issuer from the given verifiable credential\n   * @param credentialAsJson the verifiable credential we want to sign\n   * @return the verification method derived from this credential and its associated issuer did, keys etc.\n   */\n  private async deriveVerificationMethod(\n    agentContext: AgentContext,\n    credentialAsJson: JsonCredential,\n    credentialRequest: JsonLdFormatDataCredentialDetail\n  ): Promise<string> {\n    const didResolver = agentContext.dependencyManager.resolve(DidResolverService)\n    const w3cJsonLdCredentialService = agentContext.dependencyManager.resolve(W3cJsonLdCredentialService)\n\n    const credential = JsonTransformer.fromJSON(credentialAsJson, W3cCredential)\n\n    // extract issuer from vc (can be string or Issuer)\n    let issuerDid = credential.issuer\n\n    if (typeof issuerDid !== 'string') {\n      issuerDid = issuerDid.id\n    }\n    // this will throw an error if the issuer did is invalid\n    const issuerDidDocument = await didResolver.resolveDidDocument(agentContext, issuerDid)\n\n    // find first key which matches proof type\n    const proofType = credentialRequest.options.proofType\n\n    // actually gets the key type(s)\n    const keyType = w3cJsonLdCredentialService.getVerificationMethodTypesByProofType(proofType)\n\n    if (!keyType || keyType.length === 0) {\n      throw new CredoError(`No Key Type found for proofType ${proofType}`)\n    }\n\n    const verificationMethod = await findVerificationMethodByKeyType(keyType[0], issuerDidDocument)\n    if (!verificationMethod) {\n      throw new CredoError(`Missing verification method for key type ${keyType}`)\n    }\n\n    return verificationMethod.id\n  }\n  /**\n   * Processes an incoming credential - retrieve metadata, retrieve payload and store it in the Indy wallet\n   * @param options the issue credential message wrapped inside this object\n   * @param credentialExchangeRecord the credential exchange record for this credential\n   */\n  public async processCredential(\n    agentContext: AgentContext,\n    { credentialExchangeRecord, attachment, requestAttachment }: DidCommCredentialFormatProcessCredentialOptions\n  ): Promise<void> {\n    const w3cCredentialService = agentContext.dependencyManager.resolve(W3cCredentialService)\n\n    const credentialAsJson = attachment.getDataAsJson()\n    const credential = JsonTransformer.fromJSON(credentialAsJson, W3cJsonLdVerifiableCredential)\n    const requestAsJson = requestAttachment.getDataAsJson<JsonLdFormatDataCredentialDetail>()\n\n    // Verify the credential request matches the credential\n    this.verifyReceivedCredentialMatchesRequest(credential, requestAsJson)\n\n    // verify signatures of the credential\n    const result = await w3cCredentialService.verifyCredential(agentContext, { credential })\n    if (result && !result.isValid) {\n      throw new CredoError(`Failed to validate credential, error = ${result.error}`)\n    }\n\n    const verifiableCredential = await w3cCredentialService.storeCredential(agentContext, {\n      record: W3cCredentialRecord.fromCredential(credential),\n    })\n\n    credentialExchangeRecord.credentials.push({\n      credentialRecordType: this.credentialRecordType,\n      credentialRecordId: verifiableCredential.id,\n    })\n  }\n\n  private verifyReceivedCredentialMatchesRequest(\n    credential: W3cJsonLdVerifiableCredential,\n    request: JsonLdFormatDataCredentialDetail\n  ): void {\n    const jsonCredential = JsonTransformer.toJSON(credential)\n    jsonCredential.proof = undefined\n\n    if (Array.isArray(credential.proof)) {\n      throw new CredoError('Credential proof arrays are not supported')\n    }\n\n    if (request.options.created && credential.proof.created !== request.options.created) {\n      throw new CredoError('Received credential proof created does not match created from credential request')\n    }\n\n    if (credential.proof.domain !== request.options.domain) {\n      throw new CredoError('Received credential proof domain does not match domain from credential request')\n    }\n\n    if (credential.proof.challenge !== request.options.challenge) {\n      throw new CredoError('Received credential proof challenge does not match challenge from credential request')\n    }\n\n    if (credential.proof.type !== request.options.proofType) {\n      throw new CredoError('Received credential proof type does not match proof type from credential request')\n    }\n\n    if (credential.proof.proofPurpose !== request.options.proofPurpose) {\n      throw new CredoError('Received credential proof purpose does not match proof purpose from credential request')\n    }\n\n    // Check whether the received credential (minus the proof) matches the credential request\n    if (!utils.areObjectsEqual(jsonCredential, request.credential)) {\n      throw new CredoError('Received credential does not match credential request')\n    }\n\n    // TODO: add check for the credentialStatus once this is supported in Credo\n  }\n\n  public supportsFormat(format: string): boolean {\n    const supportedFormats = [JSONLD_VC_DETAIL, JSONLD_VC]\n\n    return supportedFormats.includes(format)\n  }\n\n  public async deleteCredentialById(): Promise<void> {\n    throw new Error('Not implemented.')\n  }\n\n  public areCredentialsEqual = (message1: DidCommAttachment, message2: DidCommAttachment): boolean => {\n    const obj1 = message1.getDataAsJson()\n    const obj2 = message2.getDataAsJson()\n\n    return utils.areObjectsEqual(obj1, obj2)\n  }\n\n  public async shouldAutoRespondToProposal(\n    _agentContext: AgentContext,\n    { offerAttachment, proposalAttachment }: DidCommCredentialFormatAutoRespondProposalOptions\n  ) {\n    return this.areCredentialsEqual(proposalAttachment, offerAttachment)\n  }\n\n  public async shouldAutoRespondToOffer(\n    _agentContext: AgentContext,\n    { offerAttachment, proposalAttachment }: DidCommCredentialFormatAutoRespondOfferOptions\n  ) {\n    return this.areCredentialsEqual(proposalAttachment, offerAttachment)\n  }\n\n  public async shouldAutoRespondToRequest(\n    _agentContext: AgentContext,\n    { offerAttachment, requestAttachment }: DidCommCredentialFormatAutoRespondRequestOptions\n  ) {\n    return this.areCredentialsEqual(offerAttachment, requestAttachment)\n  }\n\n  public async shouldAutoRespondToCredential(\n    _agentContext: AgentContext,\n    { requestAttachment, credentialAttachment }: DidCommCredentialFormatAutoRespondCredentialOptions\n  ) {\n    const credentialJson = credentialAttachment.getDataAsJson<JsonLdFormatDataVerifiableCredential>()\n    const w3cCredential = JsonTransformer.fromJSON(credentialJson, W3cJsonLdVerifiableCredential)\n    const request = requestAttachment.getDataAsJson<JsonLdFormatDataCredentialDetail>()\n\n    try {\n      // This check is also done in the processCredential method, but we do it here as well\n      // to be certain we don't skip the check\n      this.verifyReceivedCredentialMatchesRequest(w3cCredential, request)\n\n      return true\n    } catch (_error) {\n      return false\n    }\n  }\n\n  /**\n   * Returns an object of type {@link DidCommAttachment} for use in credential exchange messages.\n   * It looks up the correct format identifier and encodes the data as a base64 attachment.\n   *\n   * @param data The data to include in the attach object\n   * @param id the attach id from the formats component of the message\n   */\n  private getFormatData(data: unknown, id: string): DidCommAttachment {\n    const attachment = new DidCommAttachment({\n      id,\n      mimeType: 'application/json',\n      data: new DidCommAttachmentData({\n        base64: JsonEncoder.toBase64(data),\n      }),\n    })\n\n    return attachment\n  }\n}\n"],"mappings":"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"}