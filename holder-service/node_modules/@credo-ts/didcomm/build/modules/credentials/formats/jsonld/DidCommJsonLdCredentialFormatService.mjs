import { DidCommAttachment, DidCommAttachmentData } from "../../../../decorators/attachment/DidCommAttachment.mjs";
import { DidCommCredentialFormatSpec } from "../../models/DidCommCredentialFormatSpec.mjs";
import { DidCommJsonLdCredentialDetail } from "./DidCommJsonLdCredentialDetail.mjs";
import { ClaimFormat, CredoError, DidResolverService, JsonEncoder, JsonTransformer, W3cCredential, W3cCredentialRecord, W3cCredentialService, W3cJsonLdCredentialService, W3cJsonLdVerifiableCredential, findVerificationMethodByKeyType, utils } from "@credo-ts/core";

//#region src/modules/credentials/formats/jsonld/DidCommJsonLdCredentialFormatService.ts
const JSONLD_VC_DETAIL = "aries/ld-proof-vc-detail@v1.0";
const JSONLD_VC = "aries/ld-proof-vc@v1.0";
var DidCommJsonLdCredentialFormatService = class {
	constructor() {
		this.formatKey = "jsonld";
		this.credentialRecordType = "w3c";
		this.areCredentialsEqual = (message1, message2) => {
			const obj1 = message1.getDataAsJson();
			const obj2 = message2.getDataAsJson();
			return utils.areObjectsEqual(obj1, obj2);
		};
	}
	/**
	* Create a {@link AttachmentFormats} object dependent on the message type.
	*
	* @param options The object containing all the options for the proposed credential
	* @returns object containing associated attachment, formats and filtersAttach elements
	*
	*/
	async createProposal(_agentContext, { credentialFormats }) {
		const format = new DidCommCredentialFormatSpec({ format: JSONLD_VC_DETAIL });
		const jsonLdFormat = credentialFormats.jsonld;
		if (!jsonLdFormat) throw new CredoError("Missing jsonld payload in createProposal");
		JsonTransformer.fromJSON(jsonLdFormat.credential, DidCommJsonLdCredentialDetail);
		return {
			format,
			attachment: this.getFormatData(jsonLdFormat, format.attachmentId)
		};
	}
	/**
	* Method called on reception of a propose credential message
	* @param options the options needed to accept the proposal
	*/
	async processProposal(_agentContext, { attachment }) {
		const credProposalJson = attachment.getDataAsJson();
		if (!credProposalJson) throw new CredoError("Missing jsonld credential proposal data payload");
		JsonTransformer.fromJSON(credProposalJson, DidCommJsonLdCredentialDetail);
	}
	async acceptProposal(_agentContext, { attachmentId, proposalAttachment }) {
		const format = new DidCommCredentialFormatSpec({
			attachmentId,
			format: JSONLD_VC_DETAIL
		});
		const credentialProposal = proposalAttachment.getDataAsJson();
		JsonTransformer.fromJSON(credentialProposal, DidCommJsonLdCredentialDetail);
		const offerData = credentialProposal;
		return {
			format,
			attachment: this.getFormatData(offerData, format.attachmentId)
		};
	}
	/**
	* Create a {@link AttachmentFormats} object dependent on the message type.
	*
	* @param options The object containing all the options for the credential offer
	* @returns object containing associated attachment, formats and offersAttach elements
	*
	*/
	async createOffer(_agentContext, { credentialFormats, attachmentId }) {
		const format = new DidCommCredentialFormatSpec({
			attachmentId,
			format: JSONLD_VC_DETAIL
		});
		const jsonLdFormat = credentialFormats?.jsonld;
		if (!jsonLdFormat) throw new CredoError("Missing jsonld payload in createOffer");
		JsonTransformer.fromJSON(jsonLdFormat.credential, DidCommJsonLdCredentialDetail);
		return {
			format,
			attachment: this.getFormatData(jsonLdFormat, format.attachmentId)
		};
	}
	async processOffer(_agentContext, { attachment }) {
		const credentialOfferJson = attachment.getDataAsJson();
		if (!credentialOfferJson) throw new CredoError("Missing jsonld credential offer data payload");
		JsonTransformer.fromJSON(credentialOfferJson, DidCommJsonLdCredentialDetail);
	}
	async acceptOffer(_agentContext, { attachmentId, offerAttachment }) {
		const credentialOffer = offerAttachment.getDataAsJson();
		JsonTransformer.fromJSON(credentialOffer, DidCommJsonLdCredentialDetail);
		const format = new DidCommCredentialFormatSpec({
			attachmentId,
			format: JSONLD_VC_DETAIL
		});
		return {
			format,
			attachment: this.getFormatData(credentialOffer, format.attachmentId)
		};
	}
	/**
	* Create a credential attachment format for a credential request.
	*
	* @param options The object containing all the options for the credential request is derived
	* @returns object containing associated attachment, formats and requestAttach elements
	*
	*/
	async createRequest(_agentContext, { credentialFormats }) {
		const jsonLdFormat = credentialFormats?.jsonld;
		const format = new DidCommCredentialFormatSpec({ format: JSONLD_VC_DETAIL });
		if (!jsonLdFormat) throw new CredoError("Missing jsonld payload in createRequest");
		JsonTransformer.fromJSON(jsonLdFormat.credential, DidCommJsonLdCredentialDetail);
		return {
			format,
			attachment: this.getFormatData(jsonLdFormat, format.attachmentId)
		};
	}
	async processRequest(_agentContext, { attachment }) {
		const requestJson = attachment.getDataAsJson();
		if (!requestJson) throw new CredoError("Missing jsonld credential request data payload");
		JsonTransformer.fromJSON(requestJson, DidCommJsonLdCredentialDetail);
	}
	async acceptRequest(agentContext, { credentialFormats, attachmentId, requestAttachment }) {
		const w3cJsonLdCredentialService = agentContext.dependencyManager.resolve(W3cJsonLdCredentialService);
		const credentialRequest = requestAttachment.getDataAsJson();
		const verificationMethod = credentialFormats?.jsonld?.verificationMethod ?? await this.deriveVerificationMethod(agentContext, credentialRequest.credential, credentialRequest);
		if (!verificationMethod) throw new CredoError("Missing verification method in credential data");
		const format = new DidCommCredentialFormatSpec({
			attachmentId,
			format: JSONLD_VC
		});
		const options = credentialRequest.options;
		const foundFields = [
			"challenge",
			"domain",
			"credentialStatus",
			"created"
		].filter((field) => options[field] !== void 0);
		if (foundFields.length > 0) throw new CredoError(`Some fields are not currently supported in credential options: ${foundFields.join(", ")}`);
		const credential = JsonTransformer.fromJSON(credentialRequest.credential, W3cCredential);
		const verifiableCredential = await w3cJsonLdCredentialService.signCredential(agentContext, {
			format: ClaimFormat.LdpVc,
			credential,
			proofType: credentialRequest.options.proofType,
			verificationMethod
		});
		return {
			format,
			attachment: this.getFormatData(JsonTransformer.toJSON(verifiableCredential), format.attachmentId)
		};
	}
	/**
	* Derive a verification method using the issuer from the given verifiable credential
	* @param credentialAsJson the verifiable credential we want to sign
	* @return the verification method derived from this credential and its associated issuer did, keys etc.
	*/
	async deriveVerificationMethod(agentContext, credentialAsJson, credentialRequest) {
		const didResolver = agentContext.dependencyManager.resolve(DidResolverService);
		const w3cJsonLdCredentialService = agentContext.dependencyManager.resolve(W3cJsonLdCredentialService);
		let issuerDid = JsonTransformer.fromJSON(credentialAsJson, W3cCredential).issuer;
		if (typeof issuerDid !== "string") issuerDid = issuerDid.id;
		const issuerDidDocument = await didResolver.resolveDidDocument(agentContext, issuerDid);
		const proofType = credentialRequest.options.proofType;
		const keyType = w3cJsonLdCredentialService.getVerificationMethodTypesByProofType(proofType);
		if (!keyType || keyType.length === 0) throw new CredoError(`No Key Type found for proofType ${proofType}`);
		const verificationMethod = await findVerificationMethodByKeyType(keyType[0], issuerDidDocument);
		if (!verificationMethod) throw new CredoError(`Missing verification method for key type ${keyType}`);
		return verificationMethod.id;
	}
	/**
	* Processes an incoming credential - retrieve metadata, retrieve payload and store it in the Indy wallet
	* @param options the issue credential message wrapped inside this object
	* @param credentialExchangeRecord the credential exchange record for this credential
	*/
	async processCredential(agentContext, { credentialExchangeRecord, attachment, requestAttachment }) {
		const w3cCredentialService = agentContext.dependencyManager.resolve(W3cCredentialService);
		const credentialAsJson = attachment.getDataAsJson();
		const credential = JsonTransformer.fromJSON(credentialAsJson, W3cJsonLdVerifiableCredential);
		const requestAsJson = requestAttachment.getDataAsJson();
		this.verifyReceivedCredentialMatchesRequest(credential, requestAsJson);
		const result = await w3cCredentialService.verifyCredential(agentContext, { credential });
		if (result && !result.isValid) throw new CredoError(`Failed to validate credential, error = ${result.error}`);
		const verifiableCredential = await w3cCredentialService.storeCredential(agentContext, { record: W3cCredentialRecord.fromCredential(credential) });
		credentialExchangeRecord.credentials.push({
			credentialRecordType: this.credentialRecordType,
			credentialRecordId: verifiableCredential.id
		});
	}
	verifyReceivedCredentialMatchesRequest(credential, request) {
		const jsonCredential = JsonTransformer.toJSON(credential);
		jsonCredential.proof = void 0;
		if (Array.isArray(credential.proof)) throw new CredoError("Credential proof arrays are not supported");
		if (request.options.created && credential.proof.created !== request.options.created) throw new CredoError("Received credential proof created does not match created from credential request");
		if (credential.proof.domain !== request.options.domain) throw new CredoError("Received credential proof domain does not match domain from credential request");
		if (credential.proof.challenge !== request.options.challenge) throw new CredoError("Received credential proof challenge does not match challenge from credential request");
		if (credential.proof.type !== request.options.proofType) throw new CredoError("Received credential proof type does not match proof type from credential request");
		if (credential.proof.proofPurpose !== request.options.proofPurpose) throw new CredoError("Received credential proof purpose does not match proof purpose from credential request");
		if (!utils.areObjectsEqual(jsonCredential, request.credential)) throw new CredoError("Received credential does not match credential request");
	}
	supportsFormat(format) {
		return [JSONLD_VC_DETAIL, JSONLD_VC].includes(format);
	}
	async deleteCredentialById() {
		throw new Error("Not implemented.");
	}
	async shouldAutoRespondToProposal(_agentContext, { offerAttachment, proposalAttachment }) {
		return this.areCredentialsEqual(proposalAttachment, offerAttachment);
	}
	async shouldAutoRespondToOffer(_agentContext, { offerAttachment, proposalAttachment }) {
		return this.areCredentialsEqual(proposalAttachment, offerAttachment);
	}
	async shouldAutoRespondToRequest(_agentContext, { offerAttachment, requestAttachment }) {
		return this.areCredentialsEqual(offerAttachment, requestAttachment);
	}
	async shouldAutoRespondToCredential(_agentContext, { requestAttachment, credentialAttachment }) {
		const credentialJson = credentialAttachment.getDataAsJson();
		const w3cCredential = JsonTransformer.fromJSON(credentialJson, W3cJsonLdVerifiableCredential);
		const request = requestAttachment.getDataAsJson();
		try {
			this.verifyReceivedCredentialMatchesRequest(w3cCredential, request);
			return true;
		} catch (_error) {
			return false;
		}
	}
	/**
	* Returns an object of type {@link DidCommAttachment} for use in credential exchange messages.
	* It looks up the correct format identifier and encodes the data as a base64 attachment.
	*
	* @param data The data to include in the attach object
	* @param id the attach id from the formats component of the message
	*/
	getFormatData(data, id) {
		return new DidCommAttachment({
			id,
			mimeType: "application/json",
			data: new DidCommAttachmentData({ base64: JsonEncoder.toBase64(data) })
		});
	}
};

//#endregion
export { DidCommJsonLdCredentialFormatService };
//# sourceMappingURL=DidCommJsonLdCredentialFormatService.mjs.map