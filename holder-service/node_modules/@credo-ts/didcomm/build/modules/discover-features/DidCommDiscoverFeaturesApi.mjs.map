{"version":3,"file":"DidCommDiscoverFeaturesApi.mjs","names":["takeUntil","filter","map","first","timeout","catchError"],"sources":["../../../src/modules/discover-features/DidCommDiscoverFeaturesApi.ts"],"sourcesContent":["import { AgentContext, CredoError, EventEmitter, InjectionSymbols, inject, injectable } from '@credo-ts/core'\nimport { firstValueFrom, of, ReplaySubject, Subject } from 'rxjs'\nimport { catchError, filter, first, map, takeUntil, timeout } from 'rxjs/operators'\nimport { DidCommMessageSender } from '../../DidCommMessageSender'\nimport type { DidCommFeature } from '../../models'\nimport { DidCommOutboundMessageContext } from '../../models'\nimport { DidCommConnectionService } from '../connections'\nimport type {\n  DiscloseFeaturesOptions,\n  DiscoverFeaturesServiceMap,\n  QueryFeaturesOptions,\n} from './DidCommDiscoverFeaturesApiOptions'\nimport type { DidCommDiscoverFeaturesDisclosureReceivedEvent } from './DidCommDiscoverFeaturesEvents'\nimport { DidCommDiscoverFeaturesEventTypes } from './DidCommDiscoverFeaturesEvents'\nimport { DidCommDiscoverFeaturesModuleConfig } from './DidCommDiscoverFeaturesModuleConfig'\nimport { DidCommDiscoverFeaturesV1Service, DidCommDiscoverFeaturesV2Service } from './protocol'\nimport type { DidCommDiscoverFeaturesService } from './services'\n\nexport interface QueryFeaturesReturnType {\n  features?: DidCommFeature[]\n}\n\nexport interface DidCommDiscoverFeaturesApi<DFSs extends DidCommDiscoverFeaturesService[]> {\n  queryFeatures(options: QueryFeaturesOptions<DFSs>): Promise<QueryFeaturesReturnType>\n  discloseFeatures(options: DiscloseFeaturesOptions<DFSs>): Promise<void>\n}\n@injectable()\n// biome-ignore lint/suspicious/noUnsafeDeclarationMerging: no explanation\nexport class DidCommDiscoverFeaturesApi<\n  DFSs extends DidCommDiscoverFeaturesService[] = [DidCommDiscoverFeaturesV1Service, DidCommDiscoverFeaturesV2Service],\n> implements DidCommDiscoverFeaturesApi<DFSs>\n{\n  /**\n   * Configuration for Discover Features module\n   */\n  public readonly config: DidCommDiscoverFeaturesModuleConfig\n\n  private connectionService: DidCommConnectionService\n  private messageSender: DidCommMessageSender\n  private eventEmitter: EventEmitter\n  private stop$: Subject<boolean>\n  private agentContext: AgentContext\n  private serviceMap: DiscoverFeaturesServiceMap<DFSs>\n\n  public constructor(\n    connectionService: DidCommConnectionService,\n    messageSender: DidCommMessageSender,\n    v1Service: DidCommDiscoverFeaturesV1Service,\n    v2Service: DidCommDiscoverFeaturesV2Service,\n    eventEmitter: EventEmitter,\n    @inject(InjectionSymbols.Stop$) stop$: Subject<boolean>,\n    agentContext: AgentContext,\n    config: DidCommDiscoverFeaturesModuleConfig\n  ) {\n    this.connectionService = connectionService\n    this.messageSender = messageSender\n    this.eventEmitter = eventEmitter\n    this.stop$ = stop$\n    this.agentContext = agentContext\n    this.config = config\n\n    // Dynamically build service map. This will be extracted once services are registered dynamically\n    this.serviceMap = [v1Service, v2Service].reduce(\n      (serviceMap, service) => ({\n        // biome-ignore lint/performance/noAccumulatingSpread: no explanation\n        ...serviceMap,\n        [service.version]: service,\n      }),\n      {}\n    ) as DiscoverFeaturesServiceMap<DFSs>\n  }\n\n  public getService<PVT extends DidCommDiscoverFeaturesService['version']>(\n    protocolVersion: PVT\n  ): DidCommDiscoverFeaturesService {\n    if (!this.serviceMap[protocolVersion]) {\n      throw new CredoError(`No discover features service registered for protocol version ${protocolVersion}`)\n    }\n\n    return this.serviceMap[protocolVersion] as unknown as DidCommDiscoverFeaturesService\n  }\n\n  /**\n   * Send a query to an existing connection for discovering supported features of any kind. If desired, do the query synchronously,\n   * meaning that it will await the response (or timeout) before resolving. Otherwise, response can be hooked by subscribing to\n   * {DiscoverFeaturesDisclosureReceivedEvent}.\n   *\n   * Note: V1 protocol only supports a single query and is limited to protocols\n   *\n   * @param options feature queries to perform, protocol version and optional comment string (only used\n   * in V1 protocol). If awaitDisclosures is set, perform the query synchronously with awaitDisclosuresTimeoutMs timeout.\n   */\n  public async queryFeatures(options: QueryFeaturesOptions<DFSs>) {\n    const service = this.getService(options.protocolVersion)\n\n    const connection = await this.connectionService.getById(this.agentContext, options.connectionId)\n\n    const { message: queryMessage } = await service.createQuery({\n      queries: options.queries,\n      comment: options.comment,\n    })\n\n    const outboundMessageContext = new DidCommOutboundMessageContext(queryMessage, {\n      agentContext: this.agentContext,\n      connection,\n    })\n\n    const replaySubject = new ReplaySubject<DidCommFeature[]>(1)\n    if (options.awaitDisclosures) {\n      // Listen for response to our feature query\n      this.eventEmitter\n        .observable<DidCommDiscoverFeaturesDisclosureReceivedEvent>(\n          DidCommDiscoverFeaturesEventTypes.DisclosureReceived\n        )\n        .pipe(\n          // Stop when the agent shuts down\n          takeUntil(this.stop$),\n          // filter by connection id\n          filter((e) => e.payload.connection?.id === connection.id),\n          // Return disclosures\n          map((e) => e.payload.disclosures),\n          // Only wait for first event that matches the criteria\n          first(),\n          // If we don't have an answer in timeoutMs miliseconds (no response, not supported, etc...) error\n          timeout({\n            first: options.awaitDisclosuresTimeoutMs ?? 7000,\n            meta: 'DiscoverFeaturesApi.queryFeatures',\n          }), // TODO: Harmonize default timeouts across the framework\n          // We want to return false if an error occurred\n          catchError(() => of([]))\n        )\n        .subscribe(replaySubject)\n    }\n\n    await this.messageSender.sendMessage(outboundMessageContext)\n\n    return { features: options.awaitDisclosures ? await firstValueFrom(replaySubject) : undefined }\n  }\n\n  /**\n   * Disclose features to a connection, either proactively or as a response to a query.\n   *\n   * Features are disclosed based on queries that will be performed to Agent's Feature Registry,\n   * meaning that they should be registered prior to disclosure. When sending disclosure as response,\n   * these queries will usually match those from the corresponding Query or Queries message.\n   *\n   * Note: V1 protocol only supports sending disclosures as a response to a query.\n   *\n   * @param options multiple properties like protocol version to use, disclosure queries and thread id\n   * (in case of disclosure as response to query)\n   */\n  public async discloseFeatures(options: DiscloseFeaturesOptions) {\n    const service = this.getService(options.protocolVersion)\n\n    const connection = await this.connectionService.getById(this.agentContext, options.connectionId)\n    const { message: disclosuresMessage } = await service.createDisclosure({\n      disclosureQueries: options.disclosureQueries,\n      threadId: options.threadId,\n    })\n\n    const outboundMessageContext = new DidCommOutboundMessageContext(disclosuresMessage, {\n      agentContext: this.agentContext,\n      connection,\n    })\n    await this.messageSender.sendMessage(outboundMessageContext)\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;AA4BO,uCAAM,2BAGb;CAaE,AAAO,YACL,mBACA,eACA,WACA,WACA,cACA,AAAgC,OAChC,cACA,QACA;AACA,OAAK,oBAAoB;AACzB,OAAK,gBAAgB;AACrB,OAAK,eAAe;AACpB,OAAK,QAAQ;AACb,OAAK,eAAe;AACpB,OAAK,SAAS;AAGd,OAAK,aAAa,CAAC,WAAW,UAAU,CAAC,QACtC,YAAY,aAAa;GAExB,GAAG;IACF,QAAQ,UAAU;GACpB,GACD,EAAE,CACH;;CAGH,AAAO,WACL,iBACgC;AAChC,MAAI,CAAC,KAAK,WAAW,iBACnB,OAAM,IAAI,WAAW,gEAAgE,kBAAkB;AAGzG,SAAO,KAAK,WAAW;;;;;;;;;;;;CAazB,MAAa,cAAc,SAAqC;EAC9D,MAAM,UAAU,KAAK,WAAW,QAAQ,gBAAgB;EAExD,MAAM,aAAa,MAAM,KAAK,kBAAkB,QAAQ,KAAK,cAAc,QAAQ,aAAa;EAEhG,MAAM,EAAE,SAAS,iBAAiB,MAAM,QAAQ,YAAY;GAC1D,SAAS,QAAQ;GACjB,SAAS,QAAQ;GAClB,CAAC;EAEF,MAAM,yBAAyB,IAAI,8BAA8B,cAAc;GAC7E,cAAc,KAAK;GACnB;GACD,CAAC;EAEF,MAAM,gBAAgB,IAAI,cAAgC,EAAE;AAC5D,MAAI,QAAQ,iBAEV,MAAK,aACF,WACC,kCAAkC,mBACnC,CACA,KAECA,YAAU,KAAK,MAAM,EAErBC,UAAQ,MAAM,EAAE,QAAQ,YAAY,OAAO,WAAW,GAAG,EAEzDC,OAAK,MAAM,EAAE,QAAQ,YAAY,EAEjCC,SAAO,EAEPC,UAAQ;GACN,OAAO,QAAQ,6BAA6B;GAC5C,MAAM;GACP,CAAC,EAEFC,mBAAiB,GAAG,EAAE,CAAC,CAAC,CACzB,CACA,UAAU,cAAc;AAG7B,QAAM,KAAK,cAAc,YAAY,uBAAuB;AAE5D,SAAO,EAAE,UAAU,QAAQ,mBAAmB,MAAM,eAAe,cAAc,GAAG,QAAW;;;;;;;;;;;;;;CAejG,MAAa,iBAAiB,SAAkC;EAC9D,MAAM,UAAU,KAAK,WAAW,QAAQ,gBAAgB;EAExD,MAAM,aAAa,MAAM,KAAK,kBAAkB,QAAQ,KAAK,cAAc,QAAQ,aAAa;EAChG,MAAM,EAAE,SAAS,uBAAuB,MAAM,QAAQ,iBAAiB;GACrE,mBAAmB,QAAQ;GAC3B,UAAU,QAAQ;GACnB,CAAC;EAEF,MAAM,yBAAyB,IAAI,8BAA8B,oBAAoB;GACnF,cAAc,KAAK;GACnB;GACD,CAAC;AACF,QAAM,KAAK,cAAc,YAAY,uBAAuB;;;;CA1I/D,YAAY;oBAwBR,OAAO,iBAAiB,MAAM"}