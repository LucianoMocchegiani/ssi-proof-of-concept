import { __decorate } from "../../_virtual/_@oxc-project_runtime@0.110.0/helpers/decorate.mjs";
import { __decorateMetadata } from "../../_virtual/_@oxc-project_runtime@0.110.0/helpers/decorateMetadata.mjs";
import { __decorateParam } from "../../_virtual/_@oxc-project_runtime@0.110.0/helpers/decorateParam.mjs";
import { DidCommOutboundMessageContext } from "../../models/DidCommOutboundMessageContext.mjs";
import "../../models/index.mjs";
import { DidCommMessageSender } from "../../DidCommMessageSender.mjs";
import { DidCommConnectionService } from "../connections/services/DidCommConnectionService.mjs";
import "../connections/index.mjs";
import { DidCommDiscoverFeaturesEventTypes } from "./DidCommDiscoverFeaturesEvents.mjs";
import { DidCommDiscoverFeaturesModuleConfig } from "./DidCommDiscoverFeaturesModuleConfig.mjs";
import { DidCommDiscoverFeaturesV1Service } from "./protocol/v1/DidCommDiscoverFeaturesV1Service.mjs";
import { DidCommDiscoverFeaturesV2Service } from "./protocol/v2/DidCommDiscoverFeaturesV2Service.mjs";
import "./protocol/index.mjs";
import { AgentContext, CredoError, EventEmitter, InjectionSymbols, inject, injectable } from "@credo-ts/core";
import { ReplaySubject, Subject, firstValueFrom, of } from "rxjs";
import { catchError as catchError$1, filter as filter$1, first as first$1, map as map$1, takeUntil as takeUntil$1, timeout as timeout$1 } from "rxjs/operators";

//#region src/modules/discover-features/DidCommDiscoverFeaturesApi.ts
var _ref, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8;
let DidCommDiscoverFeaturesApi = class DidCommDiscoverFeaturesApi {
	constructor(connectionService, messageSender, v1Service, v2Service, eventEmitter, stop$, agentContext, config) {
		this.connectionService = connectionService;
		this.messageSender = messageSender;
		this.eventEmitter = eventEmitter;
		this.stop$ = stop$;
		this.agentContext = agentContext;
		this.config = config;
		this.serviceMap = [v1Service, v2Service].reduce((serviceMap, service) => ({
			...serviceMap,
			[service.version]: service
		}), {});
	}
	getService(protocolVersion) {
		if (!this.serviceMap[protocolVersion]) throw new CredoError(`No discover features service registered for protocol version ${protocolVersion}`);
		return this.serviceMap[protocolVersion];
	}
	/**
	* Send a query to an existing connection for discovering supported features of any kind. If desired, do the query synchronously,
	* meaning that it will await the response (or timeout) before resolving. Otherwise, response can be hooked by subscribing to
	* {DiscoverFeaturesDisclosureReceivedEvent}.
	*
	* Note: V1 protocol only supports a single query and is limited to protocols
	*
	* @param options feature queries to perform, protocol version and optional comment string (only used
	* in V1 protocol). If awaitDisclosures is set, perform the query synchronously with awaitDisclosuresTimeoutMs timeout.
	*/
	async queryFeatures(options) {
		const service = this.getService(options.protocolVersion);
		const connection = await this.connectionService.getById(this.agentContext, options.connectionId);
		const { message: queryMessage } = await service.createQuery({
			queries: options.queries,
			comment: options.comment
		});
		const outboundMessageContext = new DidCommOutboundMessageContext(queryMessage, {
			agentContext: this.agentContext,
			connection
		});
		const replaySubject = new ReplaySubject(1);
		if (options.awaitDisclosures) this.eventEmitter.observable(DidCommDiscoverFeaturesEventTypes.DisclosureReceived).pipe(takeUntil$1(this.stop$), filter$1((e) => e.payload.connection?.id === connection.id), map$1((e) => e.payload.disclosures), first$1(), timeout$1({
			first: options.awaitDisclosuresTimeoutMs ?? 7e3,
			meta: "DiscoverFeaturesApi.queryFeatures"
		}), catchError$1(() => of([]))).subscribe(replaySubject);
		await this.messageSender.sendMessage(outboundMessageContext);
		return { features: options.awaitDisclosures ? await firstValueFrom(replaySubject) : void 0 };
	}
	/**
	* Disclose features to a connection, either proactively or as a response to a query.
	*
	* Features are disclosed based on queries that will be performed to Agent's Feature Registry,
	* meaning that they should be registered prior to disclosure. When sending disclosure as response,
	* these queries will usually match those from the corresponding Query or Queries message.
	*
	* Note: V1 protocol only supports sending disclosures as a response to a query.
	*
	* @param options multiple properties like protocol version to use, disclosure queries and thread id
	* (in case of disclosure as response to query)
	*/
	async discloseFeatures(options) {
		const service = this.getService(options.protocolVersion);
		const connection = await this.connectionService.getById(this.agentContext, options.connectionId);
		const { message: disclosuresMessage } = await service.createDisclosure({
			disclosureQueries: options.disclosureQueries,
			threadId: options.threadId
		});
		const outboundMessageContext = new DidCommOutboundMessageContext(disclosuresMessage, {
			agentContext: this.agentContext,
			connection
		});
		await this.messageSender.sendMessage(outboundMessageContext);
	}
};
DidCommDiscoverFeaturesApi = __decorate([
	injectable(),
	__decorateParam(5, inject(InjectionSymbols.Stop$)),
	__decorateMetadata("design:paramtypes", [
		typeof (_ref = typeof DidCommConnectionService !== "undefined" && DidCommConnectionService) === "function" ? _ref : Object,
		typeof (_ref2 = typeof DidCommMessageSender !== "undefined" && DidCommMessageSender) === "function" ? _ref2 : Object,
		typeof (_ref3 = typeof DidCommDiscoverFeaturesV1Service !== "undefined" && DidCommDiscoverFeaturesV1Service) === "function" ? _ref3 : Object,
		typeof (_ref4 = typeof DidCommDiscoverFeaturesV2Service !== "undefined" && DidCommDiscoverFeaturesV2Service) === "function" ? _ref4 : Object,
		typeof (_ref5 = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _ref5 : Object,
		typeof (_ref6 = typeof Subject !== "undefined" && Subject) === "function" ? _ref6 : Object,
		typeof (_ref7 = typeof AgentContext !== "undefined" && AgentContext) === "function" ? _ref7 : Object,
		typeof (_ref8 = typeof DidCommDiscoverFeaturesModuleConfig !== "undefined" && DidCommDiscoverFeaturesModuleConfig) === "function" ? _ref8 : Object
	])
], DidCommDiscoverFeaturesApi);

//#endregion
export { DidCommDiscoverFeaturesApi };
//# sourceMappingURL=DidCommDiscoverFeaturesApi.mjs.map