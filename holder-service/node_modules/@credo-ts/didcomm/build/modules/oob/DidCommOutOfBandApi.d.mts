import { DidCommMessage } from "../../DidCommMessage.mjs";
import { DidCommHandshakeProtocol } from "../connections/models/DidCommHandshakeProtocol.mjs";
import { DidCommAttachment } from "../../decorators/attachment/DidCommAttachment.mjs";
import { DidCommConnectionInvitationMessage } from "../connections/messages/DidCommConnectionInvitationMessage.mjs";
import { DidCommDocumentService } from "../../services/DidCommDocumentService.mjs";
import { DidCommOutOfBandInvitation } from "./messages/DidCommOutOfBandInvitation.mjs";
import "./messages/index.mjs";
import { DidCommOutOfBandRecord } from "./repository/DidCommOutOfBandRecord.mjs";
import { DidCommMessageHandlerRegistry } from "../../DidCommMessageHandlerRegistry.mjs";
import "../../services/index.mjs";
import { DidCommRoutingService } from "../routing/services/DidCommRoutingService.mjs";
import { DidCommOutOfBandService } from "./DidCommOutOfBandService.mjs";
import { DidCommMessageSender } from "../../DidCommMessageSender.mjs";
import { DidCommConnectionsApi } from "../connections/DidCommConnectionsApi.mjs";
import "../connections/index.mjs";
import { DidCommConnectionRecord } from "../connections/repository/DidCommConnectionRecord.mjs";
import { DidCommRouting } from "../../models/DidCommRouting.mjs";
import "../../models/index.mjs";
import { AgentContext, EventEmitter, Logger, Query, QueryOptions } from "@credo-ts/core";

//#region src/modules/oob/DidCommOutOfBandApi.d.ts
interface CreateOutOfBandInvitationConfig {
  label?: string;
  alias?: string;
  imageUrl?: string;
  goalCode?: string;
  goal?: string;
  handshake?: boolean;
  handshakeProtocols?: DidCommHandshakeProtocol[];
  messages?: DidCommMessage[];
  multiUseInvitation?: boolean;
  autoAcceptConnection?: boolean;
  routing?: DidCommRouting;
  appendedAttachments?: DidCommAttachment[];
  /**
   * Did to use in the invitation. Cannot be used in combination with `routing`.
   */
  invitationDid?: string;
}
interface CreateLegacyInvitationConfig {
  label?: string;
  alias?: string;
  imageUrl?: string;
  multiUseInvitation?: boolean;
  autoAcceptConnection?: boolean;
  routing?: DidCommRouting;
}
interface BaseReceiveOutOfBandInvitationConfig {
  label: string;
  alias?: string;
  imageUrl?: string;
  autoAcceptInvitation?: boolean;
  autoAcceptConnection?: boolean;
  reuseConnection?: boolean;
  routing?: DidCommRouting;
  acceptInvitationTimeoutMs?: number;
  isImplicit?: boolean;
  ourDid?: string;
}
type ReceiveOutOfBandInvitationConfig = Omit<BaseReceiveOutOfBandInvitationConfig, 'isImplicit'>;
interface ReceiveOutOfBandImplicitInvitationConfig extends Omit<BaseReceiveOutOfBandInvitationConfig, 'isImplicit' | 'reuseConnection'> {
  did: string;
  handshakeProtocols?: DidCommHandshakeProtocol[];
}
declare class DidCommOutOfBandApi {
  private outOfBandService;
  private routingService;
  private connectionsApi;
  private messageHandlerRegistry;
  private didCommDocumentService;
  private messageSender;
  private eventEmitter;
  private agentContext;
  private logger;
  constructor(messageHandlerRegistry: DidCommMessageHandlerRegistry, didCommDocumentService: DidCommDocumentService, outOfBandService: DidCommOutOfBandService, routingService: DidCommRoutingService, connectionsApi: DidCommConnectionsApi, messageSender: DidCommMessageSender, eventEmitter: EventEmitter, logger: Logger, agentContext: AgentContext);
  /**
   * Creates an outbound out-of-band record containing out-of-band invitation message defined in
   * Aries RFC 0434: Out-of-Band Protocol 1.1.
   *
   * It automatically adds all supported handshake protocols by agent to `handshake_protocols`. You
   * can modify this by setting `handshakeProtocols` in `config` parameter. If you want to create
   * invitation without handshake, you can set `handshake` to `false`.
   *
   * If `config` parameter contains `messages` it adds them to `requests~attach` attribute.
   *
   * Agent role: sender (inviter)
   *
   * @param config configuration of how out-of-band invitation should be created
   * @returns out-of-band record
   */
  createInvitation(config?: CreateOutOfBandInvitationConfig): Promise<DidCommOutOfBandRecord>;
  /**
   * Creates an outbound out-of-band record in the same way how `createInvitation` method does it,
   * but it also converts out-of-band invitation message to an "legacy" invitation message defined
   * in RFC 0160: Connection Protocol and returns it together with out-of-band record.
   *
   * Agent role: sender (inviter)
   *
   * @param config configuration of how a connection invitation should be created
   * @returns out-of-band record and connection invitation
   */
  createLegacyInvitation(config?: CreateLegacyInvitationConfig): Promise<{
    outOfBandRecord: DidCommOutOfBandRecord;
    invitation: DidCommConnectionInvitationMessage;
  }>;
  createLegacyConnectionlessInvitation<Message extends DidCommMessage>(config: {
    /**
     * @deprecated this value is not used anymore, as the legacy connection-less exchange is now
     * integrated with the out of band protocol. The value is kept to not break the API, but will
     * be removed in a future version, and has no effect.
     */
    recordId?: string;
    message: Message;
    domain: string;
    routing?: DidCommRouting;
  }): Promise<{
    message: Message;
    invitationUrl: string;
    outOfBandRecord: DidCommOutOfBandRecord;
  }>;
  /**
   * Parses URL, decodes invitation and calls `receiveMessage` with parsed invitation message.
   *
   * Agent role: receiver (invitee)
   *
   * @param invitationUrl url containing a base64 encoded invitation to receive
   * @param config configuration of how out-of-band invitation should be processed
   * @returns out-of-band record and connection record if one has been created
   */
  receiveInvitationFromUrl(invitationUrl: string, config: ReceiveOutOfBandInvitationConfig): Promise<{
    outOfBandRecord: DidCommOutOfBandRecord;
    connectionRecord?: DidCommConnectionRecord;
  }>;
  /**
   * Parses URL containing encoded invitation and returns invitation message.
   *
   * Will fetch the url if the url does not contain a base64 encoded invitation.
   *
   * @param invitationUrl URL containing encoded invitation
   *
   * @returns DidCommOutOfBandInvitation
   */
  parseInvitation(invitationUrl: string): Promise<DidCommOutOfBandInvitation>;
  /**
   * Creates inbound out-of-band record and assigns out-of-band invitation message to it if the
   * message is valid. It automatically passes out-of-band invitation for further processing to
   * `acceptInvitation` method. If you don't want to do that you can set `autoAcceptInvitation`
   * attribute in `config` parameter to `false` and accept the message later by calling
   * `acceptInvitation`.
   *
   * It supports both OOB (Aries RFC 0434: Out-of-Band Protocol 1.1) and Connection Invitation
   * (0160: Connection Protocol).
   *
   * Agent role: receiver (invitee)
   *
   * @param invitation either DidCommOutOfBandInvitation or DidCommConnectionInvitationMessage
   * @param config config for handling of invitation
   *
   * @returns out-of-band record and connection record if one has been created.
   */
  receiveInvitation(invitation: DidCommOutOfBandInvitation | DidCommConnectionInvitationMessage, config: ReceiveOutOfBandInvitationConfig): Promise<{
    outOfBandRecord: DidCommOutOfBandRecord;
    connectionRecord?: DidCommConnectionRecord;
  }>;
  /**
   * Creates inbound out-of-band record from an implicit invitation, given as a public DID the agent
   * should be capable of resolving. It automatically passes out-of-band invitation for further
   * processing to `acceptInvitation` method. If you don't want to do that you can set
   * `autoAcceptInvitation` attribute in `config` parameter to `false` and accept the message later by
   * calling `acceptInvitation`.
   *
   * It supports both OOB (Aries RFC 0434: Out-of-Band Protocol 1.1) and Connection Invitation
   * (0160: Connection Protocol). Handshake protocol to be used depends on handshakeProtocols
   * (DID Exchange by default)
   *
   * Agent role: receiver (invitee)
   *
   * @param config config for creating and handling invitation
   *
   * @returns out-of-band record and connection record if one has been created.
   */
  receiveImplicitInvitation(config: ReceiveOutOfBandImplicitInvitationConfig): Promise<{
    outOfBandRecord: DidCommOutOfBandRecord;
    connectionRecord?: DidCommConnectionRecord;
  }>;
  /**
   * Internal receive invitation method, for both explicit and implicit OOB invitations
   */
  private _receiveInvitation;
  /**
   * Creates a connection if the out-of-band invitation message contains `handshake_protocols`
   * attribute, except for the case when connection already exists and `reuseConnection` is enabled.
   *
   * It passes first supported message from `requests~attach` attribute to the agent, except for the
   * case reuse of connection is applied when it just sends `handshake-reuse` message to existing
   * connection.
   *
   * Agent role: receiver (invitee)
   *
   * @param outOfBandId
   * @param config
   * @returns out-of-band record and connection record if one has been created.
   */
  acceptInvitation(outOfBandId: string, config: {
    autoAcceptConnection?: boolean;
    reuseConnection?: boolean;
    label: string;
    alias?: string;
    imageUrl?: string;
    /**
     * Routing for the exchange (either connection or connection-less exchange).
     *
     * If a connection is reused, the routing WILL NOT be used.
     */
    routing?: DidCommRouting;
    timeoutMs?: number;
    ourDid?: string;
  }): Promise<{
    outOfBandRecord: DidCommOutOfBandRecord;
    connectionRecord: DidCommConnectionRecord;
  } | {
    outOfBandRecord: DidCommOutOfBandRecord;
    connectionRecord?: undefined;
  }>;
  findByReceivedInvitationId(receivedInvitationId: string): Promise<DidCommOutOfBandRecord | null>;
  findByCreatedInvitationId(createdInvitationId: string): Promise<DidCommOutOfBandRecord | null>;
  /**
   * Retrieve all out of bands records
   *
   * @returns List containing all  out of band records
   */
  getAll(): Promise<DidCommOutOfBandRecord[]>;
  /**
   * Retrieve all out of bands records by specified query param
   *
   * @returns List containing all out of band records matching specified query params
   */
  findAllByQuery(query: Query<DidCommOutOfBandRecord>, queryOptions?: QueryOptions): Promise<DidCommOutOfBandRecord[]>;
  /**
   * Retrieve a out of band record by id
   *
   * @param outOfBandId The  out of band record id
   * @throws {RecordNotFoundError} If no record is found
   * @return The out of band record
   *
   */
  getById(outOfBandId: string): Promise<DidCommOutOfBandRecord>;
  /**
   * Find an out of band record by id
   *
   * @param outOfBandId the  out of band record id
   * @returns The out of band record or null if not found
   */
  findById(outOfBandId: string): Promise<DidCommOutOfBandRecord | null>;
  /**
   * Delete an out of band record by id
   *
   * @param outOfBandId the out of band record id
   */
  deleteById(outOfBandId: string): Promise<void>;
  private assertHandshakeProtocolsSupported;
  private areHandshakeProtocolsSupported;
  private getSupportedHandshakeProtocols;
  /**
   * Get the first supported protocol based on the handshake protocols provided in the out of band
   * invitation.
   *
   * Returns an enum value from {@link DidCommHandshakeProtocol} or throw an error if no protocol is supported.
   * Minor versions are ignored when selecting a supported protocols, so if the `outOfBandInvitationSupportedProtocolsWithMinorVersion`
   * value is `https://didcomm.org/didexchange/1.0` and the agent supports `https://didcomm.org/didexchange/1.1`
   * this will be fine, and the returned value will be {@link DidCommHandshakeProtocol.DidExchange}.
   */
  private getFirstSupportedProtocol;
  private findExistingConnection;
  private emitWithConnection;
  private emitWithServices;
  private ensureParentThreadId;
  private handleHandshakeReuse;
  private resolveInvitationRecipientKeyFingerprints;
}
//#endregion
export { CreateLegacyInvitationConfig, CreateOutOfBandInvitationConfig, DidCommOutOfBandApi, ReceiveOutOfBandImplicitInvitationConfig, ReceiveOutOfBandInvitationConfig };
//# sourceMappingURL=DidCommOutOfBandApi.d.mts.map