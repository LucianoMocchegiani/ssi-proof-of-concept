{"version":3,"file":"DidCommOutOfBandApi.mjs","names":[],"sources":["../../../src/modules/oob/DidCommOutOfBandApi.ts"],"sourcesContent":["import type { Query, QueryOptions } from '@credo-ts/core'\nimport {\n  AgentContext,\n  CredoError,\n  DidKey,\n  EventEmitter,\n  filterContextCorrelationId,\n  InjectionSymbols,\n  inject,\n  injectable,\n  JsonEncoder,\n  JsonTransformer,\n  Kms,\n  type Logger,\n} from '@credo-ts/core'\nimport { catchError, EmptyError, first, firstValueFrom, map, of, timeout } from 'rxjs'\nimport { DidCommEventTypes, type DidCommMessageReceivedEvent } from '../../DidCommEvents'\nimport type { DidCommMessage } from '../../DidCommMessage'\nimport { DidCommMessageHandlerRegistry } from '../../DidCommMessageHandlerRegistry'\nimport { DidCommMessageSender } from '../../DidCommMessageSender'\nimport type { DidCommAttachment } from '../../decorators/attachment/DidCommAttachment'\nimport { ServiceDecorator } from '../../decorators/service/ServiceDecorator'\nimport type { DidCommRouting } from '../../models'\nimport { DidCommOutboundMessageContext } from '../../models'\nimport { DidCommDocumentService } from '../../services'\nimport type { DidCommPlaintextMessage } from '../../types'\nimport {\n  parseDidCommProtocolUri,\n  parseMessageType,\n  supportsIncomingDidCommProtocolUri,\n  supportsIncomingMessageType,\n} from '../../util/messageType'\nimport { parseInvitationShortUrl } from '../../util/parseInvitation'\nimport {\n  DidCommConnectionInvitationMessage,\n  DidCommConnectionRecord,\n  DidCommDidExchangeState,\n  DidCommHandshakeProtocol,\n} from '../connections'\nimport { DidCommConnectionsApi } from '../connections/DidCommConnectionsApi'\nimport { DidCommRoutingService } from '../routing/services/DidCommRoutingService'\nimport { convertToNewInvitation, convertToOldInvitation } from './converters'\n\nimport { DidCommOutOfBandService } from './DidCommOutOfBandService'\nimport type { DidCommHandshakeReusedEvent } from './domain/DidCommOutOfBandEvents'\nimport { DidCommOutOfBandEventTypes } from './domain/DidCommOutOfBandEvents'\nimport { DidCommOutOfBandRole } from './domain/DidCommOutOfBandRole'\nimport { DidCommOutOfBandState } from './domain/DidCommOutOfBandState'\nimport { OutOfBandDidCommService } from './domain/OutOfBandDidCommService'\nimport { outOfBandServiceToInlineKeysNumAlgo2Did } from './helpers'\nimport { DidCommInvitationType, DidCommOutOfBandInvitation } from './messages'\nimport { DidCommOutOfBandRepository } from './repository'\nimport { type DidCommOutOfBandInlineServiceKey, DidCommOutOfBandRecord } from './repository/DidCommOutOfBandRecord'\nimport { DidCommOutOfBandRecordMetadataKeys } from './repository/outOfBandRecordMetadataTypes'\n\nconst didCommProfiles = ['didcomm/aip1', 'didcomm/aip2;env=rfc19']\n\nexport interface CreateOutOfBandInvitationConfig {\n  label?: string\n  alias?: string // alias for a connection record to be created\n  imageUrl?: string\n  goalCode?: string\n  goal?: string\n  handshake?: boolean\n  handshakeProtocols?: DidCommHandshakeProtocol[]\n  messages?: DidCommMessage[]\n  multiUseInvitation?: boolean\n  autoAcceptConnection?: boolean\n  routing?: DidCommRouting\n  appendedAttachments?: DidCommAttachment[]\n\n  /**\n   * Did to use in the invitation. Cannot be used in combination with `routing`.\n   */\n  invitationDid?: string\n}\n\nexport interface CreateLegacyInvitationConfig {\n  label?: string\n  alias?: string // alias for a connection record to be created\n  imageUrl?: string\n  multiUseInvitation?: boolean\n  autoAcceptConnection?: boolean\n  routing?: DidCommRouting\n}\n\ninterface BaseReceiveOutOfBandInvitationConfig {\n  label: string\n  alias?: string\n  imageUrl?: string\n  autoAcceptInvitation?: boolean\n  autoAcceptConnection?: boolean\n  reuseConnection?: boolean\n  routing?: DidCommRouting\n  acceptInvitationTimeoutMs?: number\n  isImplicit?: boolean\n  ourDid?: string\n}\n\nexport type ReceiveOutOfBandInvitationConfig = Omit<BaseReceiveOutOfBandInvitationConfig, 'isImplicit'>\n\nexport interface ReceiveOutOfBandImplicitInvitationConfig\n  extends Omit<BaseReceiveOutOfBandInvitationConfig, 'isImplicit' | 'reuseConnection'> {\n  did: string\n  handshakeProtocols?: DidCommHandshakeProtocol[]\n}\n\n@injectable()\nexport class DidCommOutOfBandApi {\n  private outOfBandService: DidCommOutOfBandService\n  private routingService: DidCommRoutingService\n  private connectionsApi: DidCommConnectionsApi\n  private messageHandlerRegistry: DidCommMessageHandlerRegistry\n  private didCommDocumentService: DidCommDocumentService\n  private messageSender: DidCommMessageSender\n  private eventEmitter: EventEmitter\n  private agentContext: AgentContext\n  private logger: Logger\n\n  public constructor(\n    messageHandlerRegistry: DidCommMessageHandlerRegistry,\n    didCommDocumentService: DidCommDocumentService,\n    outOfBandService: DidCommOutOfBandService,\n    routingService: DidCommRoutingService,\n    connectionsApi: DidCommConnectionsApi,\n    messageSender: DidCommMessageSender,\n    eventEmitter: EventEmitter,\n    @inject(InjectionSymbols.Logger) logger: Logger,\n    agentContext: AgentContext\n  ) {\n    this.messageHandlerRegistry = messageHandlerRegistry\n    this.didCommDocumentService = didCommDocumentService\n    this.agentContext = agentContext\n    this.logger = logger\n    this.outOfBandService = outOfBandService\n    this.routingService = routingService\n    this.connectionsApi = connectionsApi\n    this.messageSender = messageSender\n    this.eventEmitter = eventEmitter\n  }\n\n  /**\n   * Creates an outbound out-of-band record containing out-of-band invitation message defined in\n   * Aries RFC 0434: Out-of-Band Protocol 1.1.\n   *\n   * It automatically adds all supported handshake protocols by agent to `handshake_protocols`. You\n   * can modify this by setting `handshakeProtocols` in `config` parameter. If you want to create\n   * invitation without handshake, you can set `handshake` to `false`.\n   *\n   * If `config` parameter contains `messages` it adds them to `requests~attach` attribute.\n   *\n   * Agent role: sender (inviter)\n   *\n   * @param config configuration of how out-of-band invitation should be created\n   * @returns out-of-band record\n   */\n  public async createInvitation(config: CreateOutOfBandInvitationConfig = {}): Promise<DidCommOutOfBandRecord> {\n    const multiUseInvitation = config.multiUseInvitation ?? false\n    const handshake = config.handshake ?? true\n    const customHandshakeProtocols = config.handshakeProtocols\n    const autoAcceptConnection = config.autoAcceptConnection ?? this.connectionsApi.config.autoAcceptConnections\n    // We don't want to treat an empty array as messages being provided\n    const messages = config.messages && config.messages.length > 0 ? config.messages : undefined\n    const label = config.label\n    const imageUrl = config.imageUrl\n    const appendedAttachments =\n      config.appendedAttachments && config.appendedAttachments.length > 0 ? config.appendedAttachments : undefined\n\n    if (!handshake && !messages) {\n      throw new CredoError('One or both of handshake_protocols and requests~attach MUST be included in the message.')\n    }\n\n    if (!handshake && customHandshakeProtocols) {\n      throw new CredoError(`Attribute 'handshake' can not be 'false' when 'handshakeProtocols' is defined.`)\n    }\n\n    // For now we disallow creating multi-use invitation with attachments. This would mean we need multi-use\n    // credential and presentation exchanges.\n    if (messages && multiUseInvitation) {\n      throw new CredoError(\"Attribute 'multiUseInvitation' can not be 'true' when 'messages' is defined.\")\n    }\n\n    let handshakeProtocols: string[] | undefined\n    if (handshake) {\n      // Assert ALL custom handshake protocols are supported\n      if (customHandshakeProtocols) {\n        this.assertHandshakeProtocolsSupported(customHandshakeProtocols)\n      }\n\n      // Find supported handshake protocol preserving the order of handshake protocols defined by agent or in config\n      handshakeProtocols = this.getSupportedHandshakeProtocols(customHandshakeProtocols).map(\n        (p) => p.parsedProtocolUri.protocolUri\n      )\n    }\n\n    let mediatorId: string | undefined\n    let services: [string] | OutOfBandDidCommService[]\n    if (config.routing && config.invitationDid) {\n      throw new CredoError(\"Both 'routing' and 'invitationDid' cannot be provided at the same time.\")\n    }\n\n    const invitationInlineServiceKeys: DidCommOutOfBandInlineServiceKey[] = []\n    if (config.invitationDid) {\n      services = [config.invitationDid]\n    } else {\n      const routing = config.routing ?? (await this.routingService.getRouting(this.agentContext, {}))\n      mediatorId = routing?.mediatorId\n\n      services = routing.endpoints.map((endpoint, index) => {\n        // Store the key id for the recipient key\n        invitationInlineServiceKeys.push({\n          kmsKeyId: routing.recipientKey.keyId,\n          recipientKeyFingerprint: routing.recipientKey.fingerprint,\n        })\n        return new OutOfBandDidCommService({\n          id: `#inline-${index}`,\n          serviceEndpoint: endpoint,\n          recipientKeys: [routing.recipientKey].map((key) => new DidKey(key).did),\n          routingKeys: routing.routingKeys.map((key) => new DidKey(key).did),\n        })\n      })\n    }\n\n    const outOfBandInvitation = new DidCommOutOfBandInvitation({\n      label,\n      goal: config.goal,\n      goalCode: config.goalCode,\n      imageUrl,\n      accept: didCommProfiles,\n      services,\n      handshakeProtocols,\n      appendedAttachments,\n    })\n\n    if (messages) {\n      for (const message of messages) {\n        if (message.service) {\n          // We can remove `~service` attribute from message. Newer OOB messages have `services` attribute instead.\n          message.service = undefined\n        }\n        outOfBandInvitation.addRequest(message)\n      }\n    }\n\n    const recipientKeyFingerprints = await this.resolveInvitationRecipientKeyFingerprints(outOfBandInvitation)\n    const outOfBandRecord = new DidCommOutOfBandRecord({\n      mediatorId: mediatorId,\n      role: DidCommOutOfBandRole.Sender,\n      state: DidCommOutOfBandState.AwaitResponse,\n      alias: config.alias,\n      outOfBandInvitation: outOfBandInvitation,\n      reusable: multiUseInvitation,\n      autoAcceptConnection,\n      invitationInlineServiceKeys,\n      tags: {\n        recipientKeyFingerprints,\n      },\n    })\n\n    await this.outOfBandService.save(this.agentContext, outOfBandRecord)\n    this.outOfBandService.emitStateChangedEvent(this.agentContext, outOfBandRecord, null)\n\n    return outOfBandRecord\n  }\n\n  /**\n   * Creates an outbound out-of-band record in the same way how `createInvitation` method does it,\n   * but it also converts out-of-band invitation message to an \"legacy\" invitation message defined\n   * in RFC 0160: Connection Protocol and returns it together with out-of-band record.\n   *\n   * Agent role: sender (inviter)\n   *\n   * @param config configuration of how a connection invitation should be created\n   * @returns out-of-band record and connection invitation\n   */\n  public async createLegacyInvitation(config: CreateLegacyInvitationConfig = {}) {\n    const outOfBandRecord = await this.createInvitation({\n      ...config,\n      handshakeProtocols: [DidCommHandshakeProtocol.Connections],\n    })\n\n    // Set legacy invitation type\n    outOfBandRecord.metadata.set(DidCommOutOfBandRecordMetadataKeys.LegacyInvitation, {\n      legacyInvitationType: DidCommInvitationType.Connection,\n    })\n    const outOfBandRepository = this.agentContext.dependencyManager.resolve(DidCommOutOfBandRepository)\n    await outOfBandRepository.update(this.agentContext, outOfBandRecord)\n\n    return { outOfBandRecord, invitation: convertToOldInvitation(outOfBandRecord.outOfBandInvitation) }\n  }\n\n  public async createLegacyConnectionlessInvitation<Message extends DidCommMessage>(config: {\n    /**\n     * @deprecated this value is not used anymore, as the legacy connection-less exchange is now\n     * integrated with the out of band protocol. The value is kept to not break the API, but will\n     * be removed in a future version, and has no effect.\n     */\n    recordId?: string\n    message: Message\n    domain: string\n    routing?: DidCommRouting\n  }): Promise<{ message: Message; invitationUrl: string; outOfBandRecord: DidCommOutOfBandRecord }> {\n    const outOfBandRecord = await this.createInvitation({\n      messages: [config.message],\n      routing: config.routing,\n    })\n\n    // Set legacy invitation type\n    outOfBandRecord.metadata.set(DidCommOutOfBandRecordMetadataKeys.LegacyInvitation, {\n      legacyInvitationType: DidCommInvitationType.Connectionless,\n    })\n    const outOfBandRepository = this.agentContext.dependencyManager.resolve(DidCommOutOfBandRepository)\n    await outOfBandRepository.update(this.agentContext, outOfBandRecord)\n\n    // Resolve the service and set it on the message\n    const resolvedService = await this.outOfBandService.getResolvedServiceForOutOfBandServices(\n      this.agentContext,\n      outOfBandRecord.outOfBandInvitation.getServices()\n    )\n    config.message.service = ServiceDecorator.fromResolvedDidCommService(resolvedService)\n\n    return {\n      message: config.message,\n      invitationUrl: `${config.domain}?d_m=${JsonEncoder.toBase64URL(JsonTransformer.toJSON(config.message))}`,\n      outOfBandRecord,\n    }\n  }\n\n  /**\n   * Parses URL, decodes invitation and calls `receiveMessage` with parsed invitation message.\n   *\n   * Agent role: receiver (invitee)\n   *\n   * @param invitationUrl url containing a base64 encoded invitation to receive\n   * @param config configuration of how out-of-band invitation should be processed\n   * @returns out-of-band record and connection record if one has been created\n   */\n  public async receiveInvitationFromUrl(invitationUrl: string, config: ReceiveOutOfBandInvitationConfig) {\n    const message = await this.parseInvitation(invitationUrl)\n\n    return this.receiveInvitation(message, config)\n  }\n\n  /**\n   * Parses URL containing encoded invitation and returns invitation message.\n   *\n   * Will fetch the url if the url does not contain a base64 encoded invitation.\n   *\n   * @param invitationUrl URL containing encoded invitation\n   *\n   * @returns DidCommOutOfBandInvitation\n   */\n  public async parseInvitation(invitationUrl: string): Promise<DidCommOutOfBandInvitation> {\n    return parseInvitationShortUrl(invitationUrl, this.agentContext.config.agentDependencies)\n  }\n\n  /**\n   * Creates inbound out-of-band record and assigns out-of-band invitation message to it if the\n   * message is valid. It automatically passes out-of-band invitation for further processing to\n   * `acceptInvitation` method. If you don't want to do that you can set `autoAcceptInvitation`\n   * attribute in `config` parameter to `false` and accept the message later by calling\n   * `acceptInvitation`.\n   *\n   * It supports both OOB (Aries RFC 0434: Out-of-Band Protocol 1.1) and Connection Invitation\n   * (0160: Connection Protocol).\n   *\n   * Agent role: receiver (invitee)\n   *\n   * @param invitation either DidCommOutOfBandInvitation or DidCommConnectionInvitationMessage\n   * @param config config for handling of invitation\n   *\n   * @returns out-of-band record and connection record if one has been created.\n   */\n  public async receiveInvitation(\n    invitation: DidCommOutOfBandInvitation | DidCommConnectionInvitationMessage,\n    config: ReceiveOutOfBandInvitationConfig\n  ): Promise<{ outOfBandRecord: DidCommOutOfBandRecord; connectionRecord?: DidCommConnectionRecord }> {\n    return this._receiveInvitation(invitation, config)\n  }\n\n  /**\n   * Creates inbound out-of-band record from an implicit invitation, given as a public DID the agent\n   * should be capable of resolving. It automatically passes out-of-band invitation for further\n   * processing to `acceptInvitation` method. If you don't want to do that you can set\n   * `autoAcceptInvitation` attribute in `config` parameter to `false` and accept the message later by\n   * calling `acceptInvitation`.\n   *\n   * It supports both OOB (Aries RFC 0434: Out-of-Band Protocol 1.1) and Connection Invitation\n   * (0160: Connection Protocol). Handshake protocol to be used depends on handshakeProtocols\n   * (DID Exchange by default)\n   *\n   * Agent role: receiver (invitee)\n   *\n   * @param config config for creating and handling invitation\n   *\n   * @returns out-of-band record and connection record if one has been created.\n   */\n  public async receiveImplicitInvitation(config: ReceiveOutOfBandImplicitInvitationConfig) {\n    const handshakeProtocols = this.getSupportedHandshakeProtocols(\n      config.handshakeProtocols ?? [DidCommHandshakeProtocol.DidExchange]\n    ).map((p) => p.parsedProtocolUri.protocolUri)\n\n    const invitation = new DidCommOutOfBandInvitation({\n      id: config.did,\n      label: config.alias ?? '',\n      services: [config.did],\n      handshakeProtocols,\n    })\n\n    return this._receiveInvitation(invitation, { ...config, isImplicit: true })\n  }\n\n  /**\n   * Internal receive invitation method, for both explicit and implicit OOB invitations\n   */\n  private async _receiveInvitation(\n    invitation: DidCommOutOfBandInvitation | DidCommConnectionInvitationMessage,\n    config: BaseReceiveOutOfBandInvitationConfig\n  ): Promise<{ outOfBandRecord: DidCommOutOfBandRecord; connectionRecord?: DidCommConnectionRecord }> {\n    // Convert to out of band invitation if needed\n    const outOfBandInvitation =\n      invitation instanceof DidCommOutOfBandInvitation ? invitation : convertToNewInvitation(invitation)\n\n    const { handshakeProtocols } = outOfBandInvitation\n    const { routing } = config\n\n    const autoAcceptInvitation = config.autoAcceptInvitation ?? true\n    const autoAcceptConnection = config.autoAcceptConnection ?? true\n    const reuseConnection = config.reuseConnection ?? false\n    const label = config.label\n    const alias = config.alias\n    const imageUrl = config.imageUrl\n\n    const messages = outOfBandInvitation.getRequests()\n\n    const isConnectionless = handshakeProtocols === undefined || handshakeProtocols.length === 0\n\n    if ((!handshakeProtocols || handshakeProtocols.length === 0) && (!messages || messages?.length === 0)) {\n      throw new CredoError('One or both of handshake_protocols and requests~attach MUST be included in the message.')\n    }\n\n    // Make sure we haven't received this invitation before\n    // It's fine if we created it (means that we are connecting to ourselves) or if it's an implicit\n    // invitation (it allows to connect multiple times to the same public did)\n    if (!config.isImplicit) {\n      const existingOobRecordsFromThisId = await this.outOfBandService.findAllByQuery(this.agentContext, {\n        invitationId: outOfBandInvitation.id,\n        role: DidCommOutOfBandRole.Receiver,\n      })\n      if (existingOobRecordsFromThisId.length > 0) {\n        throw new CredoError(\n          `An out of band record with invitation ${outOfBandInvitation.id} has already been received. Invitations should have a unique id.`\n        )\n      }\n    }\n\n    const recipientKeyFingerprints = await this.resolveInvitationRecipientKeyFingerprints(outOfBandInvitation)\n    const outOfBandRecord = new DidCommOutOfBandRecord({\n      role: DidCommOutOfBandRole.Receiver,\n      state: DidCommOutOfBandState.Initial,\n      outOfBandInvitation: outOfBandInvitation,\n      autoAcceptConnection,\n      tags: { recipientKeyFingerprints },\n      mediatorId: routing?.mediatorId,\n    })\n\n    // If we have routing, and this is a connectionless exchange, or we are not auto accepting the connection\n    // we need to store the routing, so it can be used when we send the first message in response to this invitation\n    if (routing && (isConnectionless || !autoAcceptInvitation)) {\n      this.logger.debug('Storing routing for out of band invitation.')\n      outOfBandRecord.metadata.set(DidCommOutOfBandRecordMetadataKeys.RecipientRouting, {\n        recipientKeyFingerprint: routing.recipientKey.fingerprint,\n        recipientKeyId: routing.recipientKey.keyId,\n        routingKeyFingerprints: routing.routingKeys.map((key) => key.fingerprint),\n        endpoints: routing.endpoints,\n        mediatorId: routing.mediatorId,\n      })\n      outOfBandRecord.setTags({ recipientRoutingKeyFingerprint: routing.recipientKey.fingerprint })\n    }\n\n    // If the invitation was converted from another legacy format, we store this, as its needed for some flows\n    if (outOfBandInvitation.invitationType && outOfBandInvitation.invitationType !== DidCommInvitationType.OutOfBand) {\n      outOfBandRecord.metadata.set(DidCommOutOfBandRecordMetadataKeys.LegacyInvitation, {\n        legacyInvitationType: outOfBandInvitation.invitationType,\n      })\n    }\n\n    await this.outOfBandService.save(this.agentContext, outOfBandRecord)\n    this.outOfBandService.emitStateChangedEvent(this.agentContext, outOfBandRecord, null)\n\n    if (autoAcceptInvitation) {\n      return await this.acceptInvitation(outOfBandRecord.id, {\n        label,\n        alias,\n        imageUrl,\n        autoAcceptConnection,\n        reuseConnection,\n        routing,\n        timeoutMs: config.acceptInvitationTimeoutMs,\n        ourDid: config.ourDid,\n      })\n    }\n\n    return { outOfBandRecord }\n  }\n\n  /**\n   * Creates a connection if the out-of-band invitation message contains `handshake_protocols`\n   * attribute, except for the case when connection already exists and `reuseConnection` is enabled.\n   *\n   * It passes first supported message from `requests~attach` attribute to the agent, except for the\n   * case reuse of connection is applied when it just sends `handshake-reuse` message to existing\n   * connection.\n   *\n   * Agent role: receiver (invitee)\n   *\n   * @param outOfBandId\n   * @param config\n   * @returns out-of-band record and connection record if one has been created.\n   */\n  public async acceptInvitation(\n    outOfBandId: string,\n    config: {\n      autoAcceptConnection?: boolean\n      reuseConnection?: boolean\n      label: string\n      alias?: string\n      imageUrl?: string\n      /**\n       * Routing for the exchange (either connection or connection-less exchange).\n       *\n       * If a connection is reused, the routing WILL NOT be used.\n       */\n      routing?: DidCommRouting\n      timeoutMs?: number\n      ourDid?: string\n    }\n  ) {\n    const outOfBandRecord = await this.outOfBandService.getById(this.agentContext, outOfBandId)\n\n    const { outOfBandInvitation } = outOfBandRecord\n    const { label, alias, imageUrl, autoAcceptConnection, reuseConnection, ourDid } = config\n    const services = outOfBandInvitation.getServices()\n    const messages = outOfBandInvitation.getRequests()\n    const timeoutMs = config.timeoutMs ?? 20000\n\n    let routing = config.routing\n\n    // recipient routing from the receiveInvitation method.\n    const recipientRouting = outOfBandRecord.metadata.get(DidCommOutOfBandRecordMetadataKeys.RecipientRouting)\n    if (!routing && recipientRouting) {\n      const recipientPublicJwk = Kms.PublicJwk.fromFingerprint(\n        recipientRouting.recipientKeyFingerprint\n      ) as Kms.PublicJwk<Kms.Ed25519PublicJwk>\n      recipientPublicJwk.keyId = recipientRouting.recipientKeyId ?? recipientPublicJwk.legacyKeyId\n\n      routing = {\n        recipientKey: recipientPublicJwk,\n        routingKeys: recipientRouting.routingKeyFingerprints.map(\n          (fingerprint) => Kms.PublicJwk.fromFingerprint(fingerprint) as Kms.PublicJwk<Kms.Ed25519PublicJwk>\n        ),\n        endpoints: recipientRouting.endpoints,\n        mediatorId: recipientRouting.mediatorId,\n      }\n    }\n\n    const { handshakeProtocols } = outOfBandInvitation\n\n    const existingConnection = await this.findExistingConnection(outOfBandInvitation)\n\n    await this.outOfBandService.updateState(this.agentContext, outOfBandRecord, DidCommOutOfBandState.PrepareResponse)\n\n    if (handshakeProtocols && handshakeProtocols.length > 0) {\n      this.logger.debug('Out of band message contains handshake protocols.')\n\n      let connectionRecord: DidCommConnectionRecord | undefined\n      if (existingConnection && reuseConnection) {\n        this.logger.debug(\n          `Connection already exists and reuse is enabled. Reusing an existing connection with ID ${existingConnection.id}.`\n        )\n\n        if (!messages || messages?.length === 0) {\n          this.logger.debug('Out of band message does not contain any request messages.')\n          const isHandshakeReuseSuccessful = await this.handleHandshakeReuse(outOfBandRecord, existingConnection)\n\n          // Handshake reuse was successful\n          if (isHandshakeReuseSuccessful) {\n            this.logger.debug(`Handshake reuse successful. Reusing existing connection ${existingConnection.id}.`)\n            connectionRecord = existingConnection\n          } else {\n            // Handshake reuse failed. Not setting connection record\n            this.logger.debug(`Handshake reuse failed. Not using existing connection ${existingConnection.id}.`)\n          }\n        } else {\n          // Handshake reuse because we found a connection and we can respond directly to the message\n          this.logger.debug(`Reusing existing connection ${existingConnection.id}.`)\n          connectionRecord = existingConnection\n        }\n      }\n\n      // If no existing connection was found, reuseConnection is false, or we didn't receive a\n      // handshake-reuse-accepted message we create a new connection\n      if (!connectionRecord) {\n        this.logger.debug('Connection does not exist or reuse is disabled. Creating a new connection.')\n        // Find first supported handshake protocol preserving the order of handshake protocols\n        // defined by `handshake_protocols` attribute in the invitation message\n        const firstSupportedProtocol = this.getFirstSupportedProtocol(handshakeProtocols)\n        connectionRecord = await this.connectionsApi.acceptOutOfBandInvitation(outOfBandRecord, {\n          label,\n          alias,\n          imageUrl,\n          autoAcceptConnection,\n          protocol: firstSupportedProtocol.handshakeProtocol,\n          routing,\n          ourDid,\n        })\n      }\n\n      if (messages && messages.length > 0) {\n        this.logger.debug('Out of band message contains request messages.')\n        if (connectionRecord.isReady) {\n          await this.emitWithConnection(outOfBandRecord, connectionRecord, messages)\n        } else {\n          // Wait until the connection is ready and then pass the messages to the agent for further processing\n          this.connectionsApi\n            .returnWhenIsConnected(connectionRecord.id, { timeoutMs })\n            .then((connectionRecord) => this.emitWithConnection(outOfBandRecord, connectionRecord, messages))\n            .catch((error) => {\n              if (error instanceof EmptyError) {\n                this.logger.warn(\n                  `Agent unsubscribed before connection got into ${DidCommDidExchangeState.Completed} state`,\n                  error\n                )\n              } else {\n                this.logger.error('Promise waiting for the connection to be complete failed.', error)\n              }\n            })\n        }\n      }\n      return { outOfBandRecord, connectionRecord }\n    }\n    if (messages) {\n      this.logger.debug('Out of band message contains only request messages.')\n      if (existingConnection && reuseConnection) {\n        this.logger.debug('Connection already exists.', { connectionId: existingConnection.id })\n        await this.emitWithConnection(outOfBandRecord, existingConnection, messages)\n      } else {\n        await this.emitWithServices(outOfBandRecord, services, messages)\n      }\n    }\n    return { outOfBandRecord }\n  }\n\n  public async findByReceivedInvitationId(receivedInvitationId: string) {\n    return this.outOfBandService.findByReceivedInvitationId(this.agentContext, receivedInvitationId)\n  }\n\n  public async findByCreatedInvitationId(createdInvitationId: string) {\n    return this.outOfBandService.findByCreatedInvitationId(this.agentContext, createdInvitationId)\n  }\n\n  /**\n   * Retrieve all out of bands records\n   *\n   * @returns List containing all  out of band records\n   */\n  public getAll() {\n    return this.outOfBandService.getAll(this.agentContext)\n  }\n\n  /**\n   * Retrieve all out of bands records by specified query param\n   *\n   * @returns List containing all out of band records matching specified query params\n   */\n  public findAllByQuery(query: Query<DidCommOutOfBandRecord>, queryOptions?: QueryOptions) {\n    return this.outOfBandService.findAllByQuery(this.agentContext, query, queryOptions)\n  }\n\n  /**\n   * Retrieve a out of band record by id\n   *\n   * @param outOfBandId The  out of band record id\n   * @throws {RecordNotFoundError} If no record is found\n   * @return The out of band record\n   *\n   */\n  public getById(outOfBandId: string): Promise<DidCommOutOfBandRecord> {\n    return this.outOfBandService.getById(this.agentContext, outOfBandId)\n  }\n\n  /**\n   * Find an out of band record by id\n   *\n   * @param outOfBandId the  out of band record id\n   * @returns The out of band record or null if not found\n   */\n  public findById(outOfBandId: string): Promise<DidCommOutOfBandRecord | null> {\n    return this.outOfBandService.findById(this.agentContext, outOfBandId)\n  }\n\n  /**\n   * Delete an out of band record by id\n   *\n   * @param outOfBandId the out of band record id\n   */\n  public async deleteById(outOfBandId: string) {\n    const outOfBandRecord = await this.getById(outOfBandId)\n\n    const relatedConnections = await this.connectionsApi.findAllByOutOfBandId(outOfBandId)\n\n    // If it uses mediation and there are no related connections, AND we didn't use a did in the invitation\n    // (if that is the case the did is managed outside of this exchange) proceed to delete keys from mediator\n    // Note: if OOB Record is reusable, it is safe to delete it because every connection created from\n    // it will use its own recipient key\n    if (\n      outOfBandRecord.mediatorId &&\n      outOfBandRecord.outOfBandInvitation.getDidServices().length === 0 &&\n      (relatedConnections.length === 0 || outOfBandRecord.reusable)\n    ) {\n      const recipientKeys = outOfBandRecord\n        .getTags()\n        .recipientKeyFingerprints.map(\n          (item) => Kms.PublicJwk.fromFingerprint(item) as Kms.PublicJwk<Kms.Ed25519PublicJwk>\n        )\n\n      await this.routingService.removeRouting(this.agentContext, {\n        recipientKeys,\n        mediatorId: outOfBandRecord.mediatorId,\n      })\n    }\n\n    return this.outOfBandService.deleteById(this.agentContext, outOfBandId)\n  }\n\n  private assertHandshakeProtocolsSupported(handshakeProtocols: DidCommHandshakeProtocol[]) {\n    if (!this.areHandshakeProtocolsSupported(handshakeProtocols)) {\n      const supportedProtocols = this.getSupportedHandshakeProtocols()\n      throw new CredoError(\n        `Handshake protocols [${handshakeProtocols}] are not supported. Supported protocols are [${supportedProtocols}]`\n      )\n    }\n  }\n\n  private areHandshakeProtocolsSupported(handshakeProtocols: DidCommHandshakeProtocol[]) {\n    const supportedProtocols = this.getSupportedHandshakeProtocols(handshakeProtocols)\n    return supportedProtocols.length === handshakeProtocols.length\n  }\n\n  private getSupportedHandshakeProtocols(limitToHandshakeProtocols?: DidCommHandshakeProtocol[]) {\n    const allHandshakeProtocols = limitToHandshakeProtocols ?? Object.values(DidCommHandshakeProtocol)\n\n    // Replace .x in the handshake protocol with .0 to allow it to be parsed\n    const parsedHandshakeProtocolUris = allHandshakeProtocols.map((h) => ({\n      handshakeProtocol: h,\n      parsedProtocolUri: parseDidCommProtocolUri(h.replace('.x', '.0')),\n    }))\n\n    // Now find all handshake protocols that start with the protocol uri without minor version '<base-uri>/<protocol-name>/<major-version>.'\n    const supportedHandshakeProtocols = this.messageHandlerRegistry.filterSupportedProtocolsByProtocolUris(\n      parsedHandshakeProtocolUris.map((p) => p.parsedProtocolUri)\n    )\n\n    if (supportedHandshakeProtocols.length === 0) {\n      throw new CredoError('There is no handshake protocol supported. Agent can not create a connection.')\n    }\n\n    // Order protocols according to `parsedHandshakeProtocolUris` array (order of preference)\n    const orderedProtocols = parsedHandshakeProtocolUris\n      .map((p) => {\n        const found = supportedHandshakeProtocols.find((s) =>\n          supportsIncomingDidCommProtocolUri(s, p.parsedProtocolUri)\n        )\n        // We need to override the parsedProtocolUri with the one from the supported protocols, as we used `.0` as the minor\n        // version before. But when we return it, we want to return the correct minor version that we actually support\n        return found ? { ...p, parsedProtocolUri: found } : null\n      })\n      .filter((p): p is NonNullable<typeof p> => p !== null)\n\n    return orderedProtocols\n  }\n\n  /**\n   * Get the first supported protocol based on the handshake protocols provided in the out of band\n   * invitation.\n   *\n   * Returns an enum value from {@link DidCommHandshakeProtocol} or throw an error if no protocol is supported.\n   * Minor versions are ignored when selecting a supported protocols, so if the `outOfBandInvitationSupportedProtocolsWithMinorVersion`\n   * value is `https://didcomm.org/didexchange/1.0` and the agent supports `https://didcomm.org/didexchange/1.1`\n   * this will be fine, and the returned value will be {@link DidCommHandshakeProtocol.DidExchange}.\n   */\n  private getFirstSupportedProtocol(protocolUris: string[]) {\n    const supportedProtocols = this.getSupportedHandshakeProtocols()\n    const parsedProtocolUris = protocolUris.map(parseDidCommProtocolUri)\n\n    const firstSupportedProtocol = supportedProtocols.find((supportedProtocol) =>\n      parsedProtocolUris.find((parsedProtocol) =>\n        supportsIncomingDidCommProtocolUri(supportedProtocol.parsedProtocolUri, parsedProtocol)\n      )\n    )\n\n    if (!firstSupportedProtocol) {\n      throw new CredoError(\n        `Handshake protocols [${protocolUris}] are not supported. Supported protocols are [${supportedProtocols.map(\n          (p) => p.handshakeProtocol\n        )}]`\n      )\n    }\n\n    return firstSupportedProtocol\n  }\n\n  private async findExistingConnection(outOfBandInvitation: DidCommOutOfBandInvitation) {\n    this.logger.debug('Searching for an existing connection for out-of-band invitation.', { outOfBandInvitation })\n\n    const invitationDids = [\n      ...outOfBandInvitation.invitationDids,\n      // Also search for legacy invitationDids based on inline services (TODO: remove in 0.6.0)\n      ...outOfBandInvitation.getInlineServices().map(outOfBandServiceToInlineKeysNumAlgo2Did),\n    ]\n\n    for (const invitationDid of invitationDids) {\n      const connections = await this.connectionsApi.findByInvitationDid(invitationDid)\n\n      this.logger.debug(`Retrieved ${connections.length} connections for invitation did ${invitationDid}`)\n\n      if (connections.length === 1) {\n        const [firstConnection] = connections\n        return firstConnection\n      }\n      if (connections.length > 1) {\n        this.logger.warn(\n          `There is more than one connection created from invitationDid ${invitationDid}. Taking the first one.`\n        )\n        const [firstConnection] = connections\n        return firstConnection\n      }\n      return null\n    }\n  }\n\n  private async emitWithConnection(\n    outOfBandRecord: DidCommOutOfBandRecord,\n    connectionRecord: DidCommConnectionRecord,\n    messages: DidCommPlaintextMessage[]\n  ) {\n    const supportedMessageTypes = this.messageHandlerRegistry.supportedMessageTypes\n    const plaintextMessage = messages.find((message) => {\n      const parsedMessageType = parseMessageType(message['@type'])\n      return supportedMessageTypes.find((type) => supportsIncomingMessageType(parsedMessageType, type))\n    })\n\n    if (!plaintextMessage) {\n      throw new CredoError('There is no message in requests~attach supported by agent.')\n    }\n\n    // Make sure message has correct parent thread id\n    this.ensureParentThreadId(outOfBandRecord, plaintextMessage)\n\n    this.logger.debug(`Message with type ${plaintextMessage['@type']} can be processed.`)\n\n    this.eventEmitter.emit<DidCommMessageReceivedEvent>(this.agentContext, {\n      type: DidCommEventTypes.DidCommMessageReceived,\n      payload: {\n        message: plaintextMessage,\n        connection: connectionRecord,\n        contextCorrelationId: this.agentContext.contextCorrelationId,\n      },\n    })\n  }\n\n  private async emitWithServices(\n    outOfBandRecord: DidCommOutOfBandRecord,\n    services: Array<OutOfBandDidCommService | string>,\n    messages: DidCommPlaintextMessage[]\n  ) {\n    if (!services || services.length === 0) {\n      throw new CredoError('There are no services. We can not emit messages')\n    }\n\n    const supportedMessageTypes = this.messageHandlerRegistry.supportedMessageTypes\n    const plaintextMessage = messages.find((message) => {\n      const parsedMessageType = parseMessageType(message['@type'])\n      return supportedMessageTypes.find((type) => supportsIncomingMessageType(parsedMessageType, type))\n    })\n\n    if (!plaintextMessage) {\n      throw new CredoError('There is no message in requests~attach supported by agent.')\n    }\n\n    // Make sure message has correct parent thread id\n    this.ensureParentThreadId(outOfBandRecord, plaintextMessage)\n\n    this.logger.debug(`Message with type ${plaintextMessage['@type']} can be processed.`)\n\n    this.eventEmitter.emit<DidCommMessageReceivedEvent>(this.agentContext, {\n      type: DidCommEventTypes.DidCommMessageReceived,\n      payload: {\n        message: plaintextMessage,\n        contextCorrelationId: this.agentContext.contextCorrelationId,\n      },\n    })\n  }\n\n  private ensureParentThreadId(outOfBandRecord: DidCommOutOfBandRecord, plaintextMessage: DidCommPlaintextMessage) {\n    const legacyInvitationMetadata = outOfBandRecord.metadata.get(DidCommOutOfBandRecordMetadataKeys.LegacyInvitation)\n\n    // We need to set the parent thread id to the invitation id, according to RFC 0434.\n    // So if it already has a pthid and it is not the same as the invitation id, we throw an error\n    if (\n      plaintextMessage['~thread']?.pthid &&\n      plaintextMessage['~thread'].pthid !== outOfBandRecord.outOfBandInvitation.id\n    ) {\n      throw new CredoError(\n        `Out of band invitation requests~attach message contains parent thread id ${plaintextMessage['~thread'].pthid} that does not match the invitation id ${outOfBandRecord.outOfBandInvitation.id}`\n      )\n    }\n\n    // If the invitation is created from a legacy connectionless invitation, we don't need to set the pthid\n    // as that's not expected, and it's generated on our side only\n    if (legacyInvitationMetadata?.legacyInvitationType === DidCommInvitationType.Connectionless) {\n      return\n    }\n\n    if (!plaintextMessage['~thread']) {\n      plaintextMessage['~thread'] = {}\n    }\n\n    // The response to an out-of-band message MUST set its ~thread.pthid equal to the @id property of the out-of-band message.\n    // By adding the pthid to the message, we ensure that the response will take over this pthid\n    plaintextMessage['~thread'].pthid = outOfBandRecord.outOfBandInvitation.id\n  }\n\n  private async handleHandshakeReuse(\n    outOfBandRecord: DidCommOutOfBandRecord,\n    connectionRecord: DidCommConnectionRecord\n  ) {\n    const reuseMessage = await this.outOfBandService.createHandShakeReuse(\n      this.agentContext,\n      outOfBandRecord,\n      connectionRecord\n    )\n\n    const reuseAcceptedEventPromise = firstValueFrom(\n      this.eventEmitter.observable<DidCommHandshakeReusedEvent>(DidCommOutOfBandEventTypes.HandshakeReused).pipe(\n        filterContextCorrelationId(this.agentContext.contextCorrelationId),\n        // Find the first reuse event where the handshake reuse accepted matches the reuse message thread\n        // TODO: Should we store the reuse state? Maybe we can keep it in memory for now\n        first(\n          (event) =>\n            event.payload.reuseThreadId === reuseMessage.threadId &&\n            event.payload.outOfBandRecord.id === outOfBandRecord.id &&\n            event.payload.connectionRecord.id === connectionRecord.id\n        ),\n        // If the event is found, we return the value true\n        map(() => true),\n        timeout({\n          first: 15000,\n          meta: 'OutOfBandApi.handleHandshakeReuse',\n        }),\n        // If timeout is reached, we return false\n        catchError(() => of(false))\n      )\n    )\n\n    const outboundMessageContext = new DidCommOutboundMessageContext(reuseMessage, {\n      agentContext: this.agentContext,\n      connection: connectionRecord,\n    })\n    await this.messageSender.sendMessage(outboundMessageContext)\n\n    return reuseAcceptedEventPromise\n  }\n\n  private async resolveInvitationRecipientKeyFingerprints(outOfBandInvitation: DidCommOutOfBandInvitation) {\n    const recipientKeyFingerprints: string[] = []\n\n    for (const service of outOfBandInvitation.getServices()) {\n      // Resolve dids to DIDDocs to retrieve services\n      if (typeof service === 'string') {\n        this.logger.debug(`Resolving services for did ${service}.`)\n        const resolvedDidCommServices = await this.didCommDocumentService.resolveServicesFromDid(\n          this.agentContext,\n          service\n        )\n        recipientKeyFingerprints.push(\n          ...resolvedDidCommServices\n            .reduce<Kms.PublicJwk<Kms.Ed25519PublicJwk | Kms.X25519PublicJwk>[]>(\n              // biome-ignore lint/performance/noAccumulatingSpread: no explanation\n              (aggr, { recipientKeys }) => [...aggr, ...recipientKeys],\n              []\n            )\n            .map((key) => key.fingerprint)\n        )\n      } else {\n        recipientKeyFingerprints.push(\n          ...service.recipientKeys.map((didKey) => DidKey.fromDid(didKey).publicJwk.fingerprint)\n        )\n      }\n    }\n\n    return recipientKeyFingerprints\n  }\n}\n"],"mappings":"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"}