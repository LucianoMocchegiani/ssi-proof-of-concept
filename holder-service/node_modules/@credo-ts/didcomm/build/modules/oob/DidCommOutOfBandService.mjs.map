{"version":3,"file":"DidCommOutOfBandService.mjs","names":[],"sources":["../../../src/modules/oob/DidCommOutOfBandService.ts"],"sourcesContent":["import type { AgentContext, Kms, Query, QueryOptions } from '@credo-ts/core'\nimport { CredoError, DidsApi, EventEmitter, injectable, parseDid } from '@credo-ts/core'\nimport type { DidCommInboundMessageContext } from '../../models'\nimport { DidCommDocumentService } from '../../services'\nimport type { DidCommConnectionRecord, DidCommHandshakeProtocol } from '../connections'\nimport { getResolvedDidcommServiceWithSigningKeyId } from '../connections/services/helpers'\nimport type { OutOfBandDidCommService } from './domain'\nimport type { DidCommHandshakeReusedEvent, DidCommOutOfBandStateChangedEvent } from './domain/DidCommOutOfBandEvents'\nimport { DidCommOutOfBandEventTypes } from './domain/DidCommOutOfBandEvents'\nimport { DidCommOutOfBandRole } from './domain/DidCommOutOfBandRole'\nimport { DidCommOutOfBandState } from './domain/DidCommOutOfBandState'\nimport { DidCommHandshakeReuseMessage, DidCommOutOfBandInvitation } from './messages'\nimport { DidCommHandshakeReuseAcceptedMessage } from './messages/DidCommHandshakeReuseAcceptedMessage'\nimport { type DidCommOutOfBandInlineServiceKey, DidCommOutOfBandRecord, DidCommOutOfBandRepository } from './repository'\n\nexport interface CreateFromImplicitInvitationConfig {\n  did: string\n  threadId: string\n  handshakeProtocols: DidCommHandshakeProtocol[]\n  autoAcceptConnection?: boolean\n  recipientKey: Kms.PublicJwk<Kms.Ed25519PublicJwk>\n}\n\n@injectable()\nexport class DidCommOutOfBandService {\n  private outOfBandRepository: DidCommOutOfBandRepository\n  private eventEmitter: EventEmitter\n  private didCommDocumentService: DidCommDocumentService\n\n  public constructor(\n    outOfBandRepository: DidCommOutOfBandRepository,\n    eventEmitter: EventEmitter,\n    didCommDocumentService: DidCommDocumentService\n  ) {\n    this.outOfBandRepository = outOfBandRepository\n    this.eventEmitter = eventEmitter\n    this.didCommDocumentService = didCommDocumentService\n  }\n\n  /**\n   * Creates an Out of Band record from a Connection/DIDExchange request started by using\n   * a publicly resolvable DID this agent can control\n   */\n  public async createFromImplicitInvitation(\n    agentContext: AgentContext,\n    config: CreateFromImplicitInvitationConfig\n  ): Promise<DidCommOutOfBandRecord> {\n    const { did, threadId, handshakeProtocols, autoAcceptConnection, recipientKey } = config\n\n    // Verify it is a valid did and it is present in the wallet\n    const publicDid = parseDid(did)\n    const didsApi = agentContext.dependencyManager.resolve(DidsApi)\n    const [createdDid] = await didsApi.getCreatedDids({ did: publicDid.did })\n    if (!createdDid) {\n      throw new CredoError(`Referenced public did ${did} not found.`)\n    }\n\n    // Recreate an 'implicit invitation' matching the parameters used by the invitee when\n    // initiating the flow\n    const outOfBandInvitation = new DidCommOutOfBandInvitation({\n      id: did,\n      services: [did],\n      handshakeProtocols,\n    })\n\n    outOfBandInvitation.setThread({ threadId })\n\n    const outOfBandRecord = new DidCommOutOfBandRecord({\n      role: DidCommOutOfBandRole.Sender,\n      state: DidCommOutOfBandState.AwaitResponse,\n      reusable: true,\n      autoAcceptConnection: autoAcceptConnection ?? false,\n      outOfBandInvitation,\n      tags: {\n        recipientKeyFingerprints: [recipientKey.fingerprint],\n      },\n    })\n\n    await this.save(agentContext, outOfBandRecord)\n    this.emitStateChangedEvent(agentContext, outOfBandRecord, null)\n    return outOfBandRecord\n  }\n\n  public async processHandshakeReuse(messageContext: DidCommInboundMessageContext<DidCommHandshakeReuseMessage>) {\n    const reuseMessage = messageContext.message\n    const parentThreadId = reuseMessage.thread?.parentThreadId\n\n    if (!parentThreadId) {\n      throw new CredoError('handshake-reuse message must have a parent thread id')\n    }\n\n    const outOfBandRecord = await this.findByCreatedInvitationId(messageContext.agentContext, parentThreadId)\n    if (!outOfBandRecord) {\n      throw new CredoError('No out of band record found for handshake-reuse message')\n    }\n\n    // Assert\n    outOfBandRecord.assertRole(DidCommOutOfBandRole.Sender)\n    outOfBandRecord.assertState(DidCommOutOfBandState.AwaitResponse)\n\n    const requestLength = outOfBandRecord.outOfBandInvitation.getRequests()?.length ?? 0\n    if (requestLength > 0) {\n      throw new CredoError('Handshake reuse should only be used when no requests are present')\n    }\n\n    const reusedConnection = messageContext.assertReadyConnection()\n    this.eventEmitter.emit<DidCommHandshakeReusedEvent>(messageContext.agentContext, {\n      type: DidCommOutOfBandEventTypes.HandshakeReused,\n      payload: {\n        reuseThreadId: reuseMessage.threadId,\n        connectionRecord: reusedConnection,\n        outOfBandRecord,\n      },\n    })\n\n    // If the out of band record is not reusable we can set the state to done\n    if (!outOfBandRecord.reusable) {\n      await this.updateState(messageContext.agentContext, outOfBandRecord, DidCommOutOfBandState.Done)\n    }\n\n    const reuseAcceptedMessage = new DidCommHandshakeReuseAcceptedMessage({\n      threadId: reuseMessage.threadId,\n      parentThreadId,\n    })\n\n    return reuseAcceptedMessage\n  }\n\n  public async processHandshakeReuseAccepted(\n    messageContext: DidCommInboundMessageContext<DidCommHandshakeReuseAcceptedMessage>\n  ) {\n    const reuseAcceptedMessage = messageContext.message\n    const parentThreadId = reuseAcceptedMessage.thread?.parentThreadId\n\n    if (!parentThreadId) {\n      throw new CredoError('handshake-reuse-accepted message must have a parent thread id')\n    }\n\n    const outOfBandRecord = await this.findByReceivedInvitationId(messageContext.agentContext, parentThreadId)\n    if (!outOfBandRecord) {\n      throw new CredoError('No out of band record found for handshake-reuse-accepted message')\n    }\n\n    // Assert\n    outOfBandRecord.assertRole(DidCommOutOfBandRole.Receiver)\n    outOfBandRecord.assertState(DidCommOutOfBandState.PrepareResponse)\n\n    const reusedConnection = messageContext.assertReadyConnection()\n\n    // Checks whether the connection associated with reuse accepted message matches with the connection\n    // associated with the reuse message.\n    // FIXME: not really a fan of the reuseConnectionId, but it's the only way I can think of now to get the connection\n    // associated with the reuse message. Maybe we can at least move it to the metadata and remove it directly afterwards?\n    // But this is an issue in general that has also come up for ACA-Py. How do I find the connection associated with an oob record?\n    // Because it doesn't work really well with connection reuse.\n    if (outOfBandRecord.reuseConnectionId !== reusedConnection.id) {\n      throw new CredoError('handshake-reuse-accepted is not in response to a handshake-reuse message.')\n    }\n\n    this.eventEmitter.emit<DidCommHandshakeReusedEvent>(messageContext.agentContext, {\n      type: DidCommOutOfBandEventTypes.HandshakeReused,\n      payload: {\n        reuseThreadId: reuseAcceptedMessage.threadId,\n        connectionRecord: reusedConnection,\n        outOfBandRecord,\n      },\n    })\n\n    // receiver role is never reusable, so we can set the state to done\n    await this.updateState(messageContext.agentContext, outOfBandRecord, DidCommOutOfBandState.Done)\n  }\n\n  public async createHandShakeReuse(\n    agentContext: AgentContext,\n    outOfBandRecord: DidCommOutOfBandRecord,\n    connectionRecord: DidCommConnectionRecord\n  ) {\n    const reuseMessage = new DidCommHandshakeReuseMessage({ parentThreadId: outOfBandRecord.outOfBandInvitation.id })\n\n    // Store the reuse connection id\n    outOfBandRecord.reuseConnectionId = connectionRecord.id\n    await this.outOfBandRepository.update(agentContext, outOfBandRecord)\n\n    return reuseMessage\n  }\n\n  public async save(agentContext: AgentContext, outOfBandRecord: DidCommOutOfBandRecord) {\n    return this.outOfBandRepository.save(agentContext, outOfBandRecord)\n  }\n\n  public async updateState(\n    agentContext: AgentContext,\n    outOfBandRecord: DidCommOutOfBandRecord,\n    newState: DidCommOutOfBandState\n  ) {\n    const previousState = outOfBandRecord.state\n    outOfBandRecord.state = newState\n    await this.outOfBandRepository.update(agentContext, outOfBandRecord)\n\n    this.emitStateChangedEvent(agentContext, outOfBandRecord, previousState)\n  }\n\n  public emitStateChangedEvent(\n    agentContext: AgentContext,\n    outOfBandRecord: DidCommOutOfBandRecord,\n    previousState: DidCommOutOfBandState | null\n  ) {\n    this.eventEmitter.emit<DidCommOutOfBandStateChangedEvent>(agentContext, {\n      type: DidCommOutOfBandEventTypes.OutOfBandStateChanged,\n      payload: {\n        outOfBandRecord: outOfBandRecord.clone(),\n        previousState,\n      },\n    })\n  }\n\n  public async findById(agentContext: AgentContext, outOfBandRecordId: string) {\n    return this.outOfBandRepository.findById(agentContext, outOfBandRecordId)\n  }\n\n  public async getById(agentContext: AgentContext, outOfBandRecordId: string) {\n    return this.outOfBandRepository.getById(agentContext, outOfBandRecordId)\n  }\n\n  public async findByReceivedInvitationId(agentContext: AgentContext, receivedInvitationId: string) {\n    return this.outOfBandRepository.findSingleByQuery(agentContext, {\n      invitationId: receivedInvitationId,\n      role: DidCommOutOfBandRole.Receiver,\n    })\n  }\n\n  public async findByCreatedInvitationId(agentContext: AgentContext, createdInvitationId: string, threadId?: string) {\n    return this.outOfBandRepository.findSingleByQuery(agentContext, {\n      invitationId: createdInvitationId,\n      role: DidCommOutOfBandRole.Sender,\n      threadId,\n    })\n  }\n\n  public async findCreatedByRecipientKey(\n    agentContext: AgentContext,\n    recipientKey: Kms.PublicJwk<Kms.Ed25519PublicJwk>\n  ) {\n    return this.outOfBandRepository.findSingleByQuery(agentContext, {\n      recipientKeyFingerprints: [recipientKey.fingerprint],\n      role: DidCommOutOfBandRole.Sender,\n    })\n  }\n\n  public async getAll(agentContext: AgentContext) {\n    return this.outOfBandRepository.getAll(agentContext)\n  }\n\n  public async findAllByQuery(\n    agentContext: AgentContext,\n    query: Query<DidCommOutOfBandRecord>,\n    queryOptions?: QueryOptions\n  ) {\n    return this.outOfBandRepository.findByQuery(agentContext, query, queryOptions)\n  }\n\n  public async deleteById(agentContext: AgentContext, outOfBandId: string) {\n    const outOfBandRecord = await this.getById(agentContext, outOfBandId)\n    return this.outOfBandRepository.delete(agentContext, outOfBandRecord)\n  }\n\n  /**\n   * Extract a resolved didcomm service from an out of band invitation.\n   *\n   * Currently the first service that can be resolved is returned.\n   */\n  public async getResolvedServiceForOutOfBandServices(\n    agentContext: AgentContext,\n    services: Array<string | OutOfBandDidCommService>,\n    /**\n     * Optional keys for the inline services\n     */\n    inlineServiceKeys?: DidCommOutOfBandInlineServiceKey[]\n  ) {\n    for (const service of services) {\n      if (typeof service === 'string') {\n        const [didService] = await this.didCommDocumentService.resolveServicesFromDid(agentContext, service)\n\n        if (didService) return didService\n      } else {\n        return getResolvedDidcommServiceWithSigningKeyId(service, inlineServiceKeys)\n      }\n    }\n\n    throw new CredoError('Could not extract a service from the out of band invitation.')\n  }\n}\n"],"mappings":"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"}