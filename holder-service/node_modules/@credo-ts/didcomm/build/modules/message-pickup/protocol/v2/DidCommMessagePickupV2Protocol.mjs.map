{"version":3,"file":"DidCommMessagePickupV2Protocol.mjs","names":[],"sources":["../../../../../src/modules/message-pickup/protocol/v2/DidCommMessagePickupV2Protocol.ts"],"sourcesContent":["import type { AgentContext } from '@credo-ts/core'\nimport { EventEmitter, injectable, verkeyToDidKey } from '@credo-ts/core'\nimport type { DidCommMessageReceivedEvent } from '../../../../DidCommEvents'\nimport { DidCommEventTypes } from '../../../../DidCommEvents'\nimport type { DidCommFeatureRegistry } from '../../../../DidCommFeatureRegistry'\nimport type { DidCommMessage } from '../../../../DidCommMessage'\nimport type { DidCommMessageHandlerRegistry } from '../../../../DidCommMessageHandlerRegistry'\nimport { DidCommModuleConfig } from '../../../../DidCommModuleConfig'\nimport { DidCommAttachment } from '../../../../decorators/attachment/DidCommAttachment'\nimport { DidCommProblemReportError } from '../../../../errors'\nimport type { DidCommInboundMessageContext } from '../../../../models'\nimport { DidCommOutboundMessageContext, DidCommProtocol } from '../../../../models'\nimport type { DidCommEncryptedMessage } from '../../../../types'\nimport { DidCommRoutingProblemReportReason } from '../../../routing/error'\nimport type { MessagePickupCompletedEvent } from '../../DidCommMessagePickupEvents'\nimport { DidCommMessagePickupEventTypes } from '../../DidCommMessagePickupEvents'\nimport { DidCommMessagePickupModuleConfig } from '../../DidCommMessagePickupModuleConfig'\nimport { DidCommMessagePickupSessionRole } from '../../DidCommMessagePickupSession'\nimport { DidCommMessagePickupSessionService } from '../../services'\nimport { DidCommBaseMessagePickupProtocol } from '../DidCommBaseMessagePickupProtocol'\nimport type {\n  DeliverMessagesProtocolOptions,\n  DeliverMessagesProtocolReturnType,\n  PickupMessagesProtocolOptions,\n  PickupMessagesProtocolReturnType,\n  SetLiveDeliveryModeProtocolOptions,\n  SetLiveDeliveryModeProtocolReturnType,\n} from '../DidCommMessagePickupProtocolOptions'\nimport {\n  DidCommDeliveryRequestV2Handler,\n  DidCommLiveDeliveryChangeV2Handler,\n  DidCommMessageDeliveryV2Handler,\n  DidCommMessagesReceivedV2Handler,\n  DidCommStatusRequestV2Handler,\n  DidCommStatusV2Handler,\n} from './handlers'\nimport {\n  DidCommDeliveryRequestV2Message,\n  DidCommLiveDeliveryChangeV2Message,\n  DidCommMessageDeliveryV2Message,\n  DidCommMessagesReceivedV2Message,\n  DidCommStatusRequestV2Message,\n  DidCommStatusV2Message,\n} from './messages'\n\n@injectable()\nexport class DidCommMessagePickupV2Protocol extends DidCommBaseMessagePickupProtocol {\n  /**\n   * The version of the message pickup protocol this class supports\n   */\n  public readonly version = 'v2' as const\n\n  /**\n   * Registers the protocol implementation (handlers, feature registry) on the agent.\n   */\n  public register(\n    messageHandlerRegistry: DidCommMessageHandlerRegistry,\n    featureRegistry: DidCommFeatureRegistry\n  ): void {\n    messageHandlerRegistry.registerMessageHandlers([\n      new DidCommStatusRequestV2Handler(this),\n      new DidCommDeliveryRequestV2Handler(this),\n      new DidCommMessagesReceivedV2Handler(this),\n      new DidCommStatusV2Handler(this),\n      new DidCommMessageDeliveryV2Handler(this),\n      new DidCommLiveDeliveryChangeV2Handler(this),\n    ])\n\n    featureRegistry.register(\n      new DidCommProtocol({\n        id: 'https://didcomm.org/messagepickup/2.0',\n        roles: ['mediator', 'recipient'],\n      })\n    )\n  }\n\n  public async createPickupMessage(\n    _agentContext: AgentContext,\n    options: PickupMessagesProtocolOptions\n  ): Promise<PickupMessagesProtocolReturnType<DidCommMessage>> {\n    const { connectionRecord, recipientDid: recipientKey } = options\n    connectionRecord.assertReady()\n\n    const message = new DidCommStatusRequestV2Message({\n      recipientKey,\n    })\n\n    return { message }\n  }\n\n  public async createDeliveryMessage(\n    agentContext: AgentContext,\n    options: DeliverMessagesProtocolOptions\n  ): Promise<DeliverMessagesProtocolReturnType<DidCommMessage> | undefined> {\n    const { connectionRecord, recipientKey, messages } = options\n    connectionRecord.assertReady()\n\n    const queueTransportRepository =\n      agentContext.dependencyManager.resolve(DidCommModuleConfig).queueTransportRepository\n\n    // Get available messages from queue, but don't delete them\n    const messagesToDeliver =\n      messages ??\n      (await queueTransportRepository.takeFromQueue(agentContext, {\n        connectionId: connectionRecord.id,\n        recipientDid: recipientKey,\n        limit: 10, // TODO: Define as config parameter\n      }))\n\n    if (messagesToDeliver.length === 0) {\n      return\n    }\n\n    const attachments = messagesToDeliver.map(\n      (msg) =>\n        new DidCommAttachment({\n          id: msg.id,\n          lastmodTime: msg.receivedAt,\n          data: {\n            json: msg.encryptedMessage,\n          },\n        })\n    )\n\n    return {\n      message: new DidCommMessageDeliveryV2Message({\n        attachments,\n      }),\n    }\n  }\n\n  public async setLiveDeliveryMode(\n    _agentContext: AgentContext,\n    options: SetLiveDeliveryModeProtocolOptions\n  ): Promise<SetLiveDeliveryModeProtocolReturnType<DidCommMessage>> {\n    const { connectionRecord, liveDelivery } = options\n    connectionRecord.assertReady()\n    return {\n      message: new DidCommLiveDeliveryChangeV2Message({\n        liveDelivery,\n      }),\n    }\n  }\n\n  public async processStatusRequest(messageContext: DidCommInboundMessageContext<DidCommStatusRequestV2Message>) {\n    // Assert ready connection\n    const connection = messageContext.assertReadyConnection()\n    const recipientKey = messageContext.message.recipientKey\n    const agentContext = messageContext.agentContext\n\n    const queueTransportRepository =\n      agentContext.dependencyManager.resolve(DidCommModuleConfig).queueTransportRepository\n\n    const statusMessage = new DidCommStatusV2Message({\n      threadId: messageContext.message.threadId,\n      recipientKey,\n      messageCount: await queueTransportRepository.getAvailableMessageCount(agentContext, {\n        connectionId: connection.id,\n        recipientDid: recipientKey ? verkeyToDidKey(recipientKey) : undefined,\n      }),\n    })\n\n    return new DidCommOutboundMessageContext(statusMessage, {\n      agentContext: messageContext.agentContext,\n      connection,\n    })\n  }\n\n  public async processDeliveryRequest(messageContext: DidCommInboundMessageContext<DidCommDeliveryRequestV2Message>) {\n    // Assert ready connection\n    const connection = messageContext.assertReadyConnection()\n    const recipientKey = messageContext.message.recipientKey\n\n    const { agentContext, message } = messageContext\n\n    const queueTransportRepository =\n      agentContext.dependencyManager.resolve(DidCommModuleConfig).queueTransportRepository\n\n    // Get available messages from queue, but don't delete them\n    const messages = await queueTransportRepository.takeFromQueue(agentContext, {\n      connectionId: connection.id,\n      recipientDid: recipientKey ? verkeyToDidKey(recipientKey) : undefined,\n      limit: message.limit,\n    })\n\n    const attachments = messages.map(\n      (msg) =>\n        new DidCommAttachment({\n          id: msg.id,\n          lastmodTime: msg.receivedAt,\n          data: {\n            json: msg.encryptedMessage,\n          },\n        })\n    )\n\n    const outboundMessageContext =\n      messages.length > 0\n        ? new DidCommMessageDeliveryV2Message({\n            threadId: messageContext.message.threadId,\n            recipientKey,\n            attachments,\n          })\n        : new DidCommStatusV2Message({\n            threadId: messageContext.message.threadId,\n            recipientKey,\n            messageCount: 0,\n          })\n\n    return new DidCommOutboundMessageContext(outboundMessageContext, {\n      agentContext: messageContext.agentContext,\n      connection,\n    })\n  }\n\n  public async processMessagesReceived(messageContext: DidCommInboundMessageContext<DidCommMessagesReceivedV2Message>) {\n    // Assert ready connection\n    const connection = messageContext.assertReadyConnection()\n\n    const { agentContext, message } = messageContext\n\n    const queueTransportRepository =\n      agentContext.dependencyManager.resolve(DidCommModuleConfig).queueTransportRepository\n\n    if (message.messageIdList.length) {\n      await queueTransportRepository.removeMessages(agentContext, {\n        connectionId: connection.id,\n        messageIds: message.messageIdList,\n      })\n    }\n\n    const statusMessage = new DidCommStatusV2Message({\n      threadId: messageContext.message.threadId,\n      messageCount: await queueTransportRepository.getAvailableMessageCount(agentContext, {\n        connectionId: connection.id,\n      }),\n    })\n\n    return new DidCommOutboundMessageContext(statusMessage, {\n      agentContext: messageContext.agentContext,\n      connection,\n    })\n  }\n\n  public async processStatus(messageContext: DidCommInboundMessageContext<DidCommStatusV2Message>) {\n    const { message: statusMessage } = messageContext\n    const { messageCount, recipientKey } = statusMessage\n\n    const connection = messageContext.assertReadyConnection()\n\n    const messagePickupModuleConfig = messageContext.agentContext.dependencyManager.resolve(\n      DidCommMessagePickupModuleConfig\n    )\n\n    const eventEmitter = messageContext.agentContext.dependencyManager.resolve(EventEmitter)\n\n    //No messages to be retrieved: message pick-up is completed\n    if (messageCount === 0) {\n      eventEmitter.emit<MessagePickupCompletedEvent>(messageContext.agentContext, {\n        type: DidCommMessagePickupEventTypes.MessagePickupCompleted,\n        payload: {\n          connection,\n          threadId: statusMessage.threadId,\n        },\n      })\n      return null\n    }\n\n    const { maximumBatchSize: maximumMessagePickup } = messagePickupModuleConfig\n    const limit = messageCount < maximumMessagePickup ? messageCount : maximumMessagePickup\n\n    const deliveryRequestMessage = new DidCommDeliveryRequestV2Message({\n      limit,\n      recipientKey,\n    })\n\n    return deliveryRequestMessage\n  }\n\n  public async processLiveDeliveryChange(\n    messageContext: DidCommInboundMessageContext<DidCommLiveDeliveryChangeV2Message>\n  ) {\n    const { agentContext, message, sessionId } = messageContext\n\n    const connection = messageContext.assertReadyConnection()\n\n    const queueTransportRepository =\n      agentContext.dependencyManager.resolve(DidCommModuleConfig).queueTransportRepository\n\n    const sessionService = messageContext.agentContext.dependencyManager.resolve(DidCommMessagePickupSessionService)\n\n    if (message.liveDelivery && sessionId) {\n      sessionService.saveLiveSession(agentContext, {\n        connectionId: connection.id,\n        protocolVersion: 'v2',\n        role: DidCommMessagePickupSessionRole.MessageHolder,\n        transportSessionId: sessionId,\n      })\n    } else {\n      sessionService.removeLiveSession(agentContext, { connectionId: connection.id })\n    }\n\n    const statusMessage = new DidCommStatusV2Message({\n      threadId: message.threadId,\n      liveDelivery: message.liveDelivery,\n      messageCount: await queueTransportRepository.getAvailableMessageCount(agentContext, {\n        connectionId: connection.id,\n      }),\n    })\n\n    return new DidCommOutboundMessageContext(statusMessage, { agentContext: messageContext.agentContext, connection })\n  }\n\n  public async processDelivery(messageContext: DidCommInboundMessageContext<DidCommMessageDeliveryV2Message>) {\n    messageContext.assertReadyConnection()\n\n    const { appendedAttachments } = messageContext.message\n\n    const eventEmitter = messageContext.agentContext.dependencyManager.resolve(EventEmitter)\n\n    if (!appendedAttachments)\n      throw new DidCommProblemReportError('Error processing attachments', {\n        problemCode: DidCommRoutingProblemReportReason.ErrorProcessingAttachments,\n      })\n\n    const ids: string[] = []\n    for (const attachment of appendedAttachments) {\n      ids.push(attachment.id)\n\n      eventEmitter.emit<DidCommMessageReceivedEvent>(messageContext.agentContext, {\n        type: DidCommEventTypes.DidCommMessageReceived,\n        payload: {\n          message: attachment.getDataAsJson<DidCommEncryptedMessage>(),\n          contextCorrelationId: messageContext.agentContext.contextCorrelationId,\n          receivedAt: attachment.lastmodTime,\n        },\n      })\n    }\n\n    return new DidCommMessagesReceivedV2Message({\n      messageIdList: ids,\n    })\n  }\n}\n"],"mappings":"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"}