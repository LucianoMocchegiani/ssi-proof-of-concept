import { __decorate } from "../../../../_virtual/_@oxc-project_runtime@0.110.0/helpers/decorate.mjs";
import { DidCommEventTypes } from "../../../../DidCommEvents.mjs";
import { DidCommModuleConfig } from "../../../../DidCommModuleConfig.mjs";
import { DidCommOutboundMessageContext } from "../../../../models/DidCommOutboundMessageContext.mjs";
import { DidCommProtocol } from "../../../../models/features/DidCommProtocol.mjs";
import "../../../../models/index.mjs";
import { DidCommMessagePickupEventTypes } from "../../DidCommMessagePickupEvents.mjs";
import { DidCommMessagePickupModuleConfig } from "../../DidCommMessagePickupModuleConfig.mjs";
import { DidCommBaseMessagePickupProtocol } from "../DidCommBaseMessagePickupProtocol.mjs";
import { DidCommBatchMessage, DidCommBatchMessageMessage } from "./messages/DidCommBatchMessage.mjs";
import { DidCommBatchPickupMessage } from "./messages/DidCommBatchPickupMessage.mjs";
import "./messages/index.mjs";
import { DidCommBatchHandler } from "./handlers/DidCommBatchHandler.mjs";
import { DidCommBatchPickupHandler } from "./handlers/DidCommBatchPickupHandler.mjs";
import "./handlers/index.mjs";
import { CredoError, EventEmitter, injectable } from "@credo-ts/core";

//#region src/modules/message-pickup/protocol/v1/DidCommMessagePickupV1Protocol.ts
let DidCommMessagePickupV1Protocol = class DidCommMessagePickupV1Protocol extends DidCommBaseMessagePickupProtocol {
	constructor(..._args) {
		super(..._args);
		this.version = "v1";
	}
	/**
	* Registers the protocol implementation (handlers, feature registry) on the agent.
	*/
	register(messageHandlerRegistry, featureRegistry) {
		messageHandlerRegistry.registerMessageHandlers([new DidCommBatchPickupHandler(this), new DidCommBatchHandler(this)]);
		featureRegistry.register(new DidCommProtocol({
			id: "https://didcomm.org/messagepickup/1.0",
			roles: [
				"message_holder",
				"recipient",
				"batch_sender",
				"batch_recipient"
			]
		}));
	}
	async createPickupMessage(agentContext, options) {
		const { connectionRecord, batchSize } = options;
		connectionRecord.assertReady();
		const config = agentContext.dependencyManager.resolve(DidCommMessagePickupModuleConfig);
		return { message: new DidCommBatchPickupMessage({ batchSize: batchSize ?? config.maximumBatchSize }) };
	}
	async createDeliveryMessage(agentContext, options) {
		const { connectionRecord, batchSize, messages } = options;
		connectionRecord.assertReady();
		const queueTransportRepository = agentContext.dependencyManager.resolve(DidCommModuleConfig).queueTransportRepository;
		const messagesToDeliver = messages ?? await queueTransportRepository.takeFromQueue(agentContext, {
			connectionId: connectionRecord.id,
			limit: batchSize,
			deleteMessages: true
		});
		const batchMessages = messagesToDeliver.map((msg) => new DidCommBatchMessageMessage({
			id: msg.id,
			message: msg.encryptedMessage
		}));
		if (messagesToDeliver.length > 0) return { message: new DidCommBatchMessage({ messages: batchMessages }) };
	}
	async setLiveDeliveryMode() {
		throw new CredoError("Live Delivery mode not supported in Message Pickup V1 protocol");
	}
	async processBatchPickup(messageContext) {
		const connection = messageContext.assertReadyConnection();
		const { message, agentContext } = messageContext;
		return new DidCommOutboundMessageContext(new DidCommBatchMessage({
			messages: (await agentContext.dependencyManager.resolve(DidCommModuleConfig).queueTransportRepository.takeFromQueue(agentContext, {
				connectionId: connection.id,
				limit: message.batchSize,
				deleteMessages: true
			})).map((msg) => new DidCommBatchMessageMessage({
				id: msg.id,
				message: msg.encryptedMessage
			})),
			threadId: message.threadId
		}), {
			agentContext: messageContext.agentContext,
			connection
		});
	}
	async processBatch(messageContext) {
		const { message: batchMessage, agentContext } = messageContext;
		const { messages } = batchMessage;
		const connection = messageContext.assertReadyConnection();
		const eventEmitter = messageContext.agentContext.dependencyManager.resolve(EventEmitter);
		for (const message of messages) eventEmitter.emit(messageContext.agentContext, {
			type: DidCommEventTypes.DidCommMessageReceived,
			payload: {
				message: message.message,
				contextCorrelationId: messageContext.agentContext.contextCorrelationId
			}
		});
		if (messages.length === 0) {
			eventEmitter.emit(messageContext.agentContext, {
				type: DidCommMessagePickupEventTypes.MessagePickupCompleted,
				payload: {
					connection,
					threadId: batchMessage.threadId
				}
			});
			return null;
		}
		return (await this.createPickupMessage(agentContext, { connectionRecord: connection })).message;
	}
};
DidCommMessagePickupV1Protocol = __decorate([injectable()], DidCommMessagePickupV1Protocol);

//#endregion
export { DidCommMessagePickupV1Protocol };
//# sourceMappingURL=DidCommMessagePickupV1Protocol.mjs.map