{"version":3,"file":"DidCommMessagePickupApi.mjs","names":[],"sources":["../../../src/modules/message-pickup/DidCommMessagePickupApi.ts"],"sourcesContent":["import {\n  AgentContext,\n  CredoError,\n  EventEmitter,\n  InjectionSymbols,\n  inject,\n  injectable,\n  type Logger,\n} from '@credo-ts/core'\nimport { filter, first, firstValueFrom, ReplaySubject, Subject, takeUntil, timeout } from 'rxjs'\nimport { DidCommMessageSender } from '../../DidCommMessageSender'\nimport { DidCommModuleConfig } from '../../DidCommModuleConfig'\nimport { DidCommOutboundMessageContext } from '../../models'\nimport { DidCommConnectionService } from '../connections/services'\nimport type {\n  DeliverMessagesFromQueueOptions,\n  DeliverMessagesFromQueueReturnType,\n  DeliverMessagesOptions,\n  DeliverMessagesReturnType,\n  PickupMessagesOptions,\n  PickupMessagesReturnType,\n  QueueMessageOptions,\n  QueueMessageReturnType,\n  SetLiveDeliveryModeOptions,\n  SetLiveDeliveryModeReturnType,\n} from './DidCommMessagePickupApiOptions'\nimport type { MessagePickupCompletedEvent } from './DidCommMessagePickupEvents'\nimport { DidCommMessagePickupEventTypes } from './DidCommMessagePickupEvents'\nimport { DidCommMessagePickupModuleConfig } from './DidCommMessagePickupModuleConfig'\nimport type { DidCommMessagePickupSession, DidCommMessagePickupSessionRole } from './DidCommMessagePickupSession'\nimport type { DidCommMessagePickupV1Protocol, DidCommMessagePickupV2Protocol } from './protocol'\nimport type { DidCommMessagePickupProtocol } from './protocol/DidCommMessagePickupProtocol'\nimport { DidCommMessagePickupSessionService } from './services/DidCommMessagePickupSessionService'\n\nexport interface DidCommMessagePickupApi<MPPs extends DidCommMessagePickupProtocol[]> {\n  queueMessage(options: QueueMessageOptions): Promise<QueueMessageReturnType>\n  pickupMessages(options: PickupMessagesOptions<MPPs>): Promise<PickupMessagesReturnType>\n  getLiveModeSession(options: {\n    connectionId: string\n    role?: DidCommMessagePickupSessionRole\n  }): Promise<DidCommMessagePickupSession | undefined>\n  deliverMessages(options: DeliverMessagesOptions): Promise<DeliverMessagesReturnType>\n  deliverMessagesFromQueue(options: DeliverMessagesFromQueueOptions): Promise<DeliverMessagesFromQueueReturnType>\n  setLiveDeliveryMode(options: SetLiveDeliveryModeOptions): Promise<SetLiveDeliveryModeReturnType>\n}\n\n@injectable()\n// biome-ignore lint/suspicious/noUnsafeDeclarationMerging: no explanation\nexport class DidCommMessagePickupApi<\n  MPPs extends DidCommMessagePickupProtocol[] = [DidCommMessagePickupV1Protocol, DidCommMessagePickupV2Protocol],\n> implements DidCommMessagePickupApi<MPPs>\n{\n  public config: DidCommMessagePickupModuleConfig<MPPs>\n\n  private messageSender: DidCommMessageSender\n  private agentContext: AgentContext\n  private eventEmitter: EventEmitter\n  private connectionService: DidCommConnectionService\n  private messagePickupSessionService: DidCommMessagePickupSessionService\n  private logger: Logger\n  private stop$: Subject<boolean>\n\n  public constructor(\n    messageSender: DidCommMessageSender,\n    agentContext: AgentContext,\n    connectionService: DidCommConnectionService,\n    eventEmitter: EventEmitter,\n    messagePickupSessionService: DidCommMessagePickupSessionService,\n    config: DidCommMessagePickupModuleConfig<MPPs>,\n    @inject(InjectionSymbols.Stop$) stop$: Subject<boolean>,\n    @inject(InjectionSymbols.Logger) logger: Logger\n  ) {\n    this.messageSender = messageSender\n    this.connectionService = connectionService\n    this.agentContext = agentContext\n    this.eventEmitter = eventEmitter\n    this.config = config\n    this.messagePickupSessionService = messagePickupSessionService\n    this.stop$ = stop$\n    this.logger = logger\n  }\n\n  private getProtocol<MPP extends MPPs[number]['version']>(protocolVersion: MPP): DidCommMessagePickupProtocol {\n    const protocol = this.config.protocols.find((protocol) => protocol.version === protocolVersion)\n\n    if (!protocol) {\n      throw new CredoError(`No message pickup protocol registered for protocol version ${protocolVersion}`)\n    }\n\n    return protocol\n  }\n\n  /**\n   * Add an encrypted message to the message pickup queue\n   *\n   * @param options: connectionId associated to the message and the encrypted message itself\n   */\n  public async queueMessage(options: QueueMessageOptions): Promise<QueueMessageReturnType> {\n    this.logger.debug('Queuing message...')\n    const { connectionId, message, recipientDids } = options\n    const connectionRecord = await this.connectionService.getById(this.agentContext, connectionId)\n\n    const queueTransportRepository =\n      this.agentContext.dependencyManager.resolve(DidCommModuleConfig).queueTransportRepository\n\n    await queueTransportRepository.addMessage(this.agentContext, {\n      connectionId: connectionRecord.id,\n      recipientDids,\n      payload: message,\n    })\n  }\n\n  /**\n   * Get current active live mode message pickup session for a given connection. Undefined if no active session found\n   *\n   * @param options connection id and optional role\n   * @returns live mode session\n   */\n  public async getLiveModeSession(options: { connectionId: string; role?: DidCommMessagePickupSessionRole }) {\n    const { connectionId, role } = options\n    return this.messagePickupSessionService.getLiveSessionByConnectionId(this.agentContext, { connectionId, role })\n  }\n\n  /**\n   * Deliver specific messages to an active live mode pickup session through message pickup protocol.\n   *\n   * This will deliver the messages regardless of the state of the message pickup queue, meaning that\n   * any message stuck there should be sent separately (e.g. using deliverQU).\n   *\n   * @param options: pickup session id and the messages to deliver\n   */\n  public async deliverMessages(options: DeliverMessagesOptions) {\n    const { pickupSessionId, messages } = options\n\n    const session = this.messagePickupSessionService.getLiveSession(this.agentContext, pickupSessionId)\n\n    if (!session) {\n      throw new CredoError(`No active live mode session found with id ${pickupSessionId}`)\n    }\n\n    const connectionRecord = await this.connectionService.getById(this.agentContext, session.connectionId)\n\n    const protocol = this.getProtocol(session.protocolVersion)\n\n    const createDeliveryReturn = await protocol.createDeliveryMessage(this.agentContext, {\n      connectionRecord,\n      messages,\n    })\n\n    if (createDeliveryReturn) {\n      await this.messageSender.sendMessage(\n        new DidCommOutboundMessageContext(createDeliveryReturn.message, {\n          agentContext: this.agentContext,\n          connection: connectionRecord,\n        }),\n        { transportPriority: { schemes: ['wss', 'ws'] } }\n      )\n    }\n  }\n\n  /**\n   * Deliver messages in the Message Pickup Queue for a given live mode session and key (if specified).\n   *\n   * This will retrieve messages up to 'batchSize' messages from the queue and deliver it through the\n   * corresponding Message Pickup protocol. If there are more than 'batchSize' messages in the queue,\n   * the recipient may request remaining messages after receiving the first batch of messages.\n   *\n   */\n  public async deliverMessagesFromQueue(options: DeliverMessagesFromQueueOptions) {\n    this.logger.debug('Delivering queued messages')\n\n    const { pickupSessionId, recipientDid: recipientKey, batchSize } = options\n\n    const session = this.messagePickupSessionService.getLiveSession(this.agentContext, pickupSessionId)\n\n    if (!session) {\n      throw new CredoError(`No active live mode session found with id ${pickupSessionId}`)\n    }\n    const connectionRecord = await this.connectionService.getById(this.agentContext, session.connectionId)\n\n    const protocol = this.getProtocol(session.protocolVersion)\n\n    const deliverMessagesReturn = await protocol.createDeliveryMessage(this.agentContext, {\n      connectionRecord,\n      recipientKey,\n      batchSize,\n    })\n\n    if (deliverMessagesReturn) {\n      await this.messageSender.sendMessage(\n        new DidCommOutboundMessageContext(deliverMessagesReturn.message, {\n          agentContext: this.agentContext,\n          connection: connectionRecord,\n        }),\n        { transportPriority: { schemes: ['wss', 'ws'] } }\n      )\n    }\n  }\n\n  /**\n   * Pickup queued messages from a message holder. It attempts to retrieve all current messages from the\n   * queue, receiving up to `batchSize` messages per batch retrieval.\n   *\n   * By default, this method only waits until the initial pick-up request is sent. Use `options.awaitCompletion`\n   * if you want to wait until all messages are effectively retrieved.\n   *\n   * @param options connectionId, protocol version to use and batch size, awaitCompletion,\n   * awaitCompletionTimeoutMs\n   */\n  public async pickupMessages(options: PickupMessagesOptions<MPPs>): Promise<PickupMessagesReturnType> {\n    const connectionRecord = await this.connectionService.getById(this.agentContext, options.connectionId)\n\n    const protocol = this.getProtocol(options.protocolVersion)\n    const { message } = await protocol.createPickupMessage(this.agentContext, {\n      connectionRecord,\n      batchSize: options.batchSize,\n      recipientDid: options.recipientDid,\n    })\n\n    const outboundMessageContext = new DidCommOutboundMessageContext(message, {\n      agentContext: this.agentContext,\n      connection: connectionRecord,\n    })\n\n    const replaySubject = new ReplaySubject(1)\n\n    if (options.awaitCompletion) {\n      this.eventEmitter\n        .observable<MessagePickupCompletedEvent>(DidCommMessagePickupEventTypes.MessagePickupCompleted)\n        .pipe(\n          // Stop when the agent shuts down\n          takeUntil(this.stop$),\n          // filter by connection id\n          filter((e) => e.payload.connection.id === connectionRecord.id),\n          // Only wait for first event that matches the criteria\n          first(),\n          // If we don't receive all messages within timeoutMs miliseconds (no response, not supported, etc...) error\n          timeout({\n            first: options.awaitCompletionTimeoutMs ?? 10000,\n            meta: 'DidCommMessagePickupApi.pickupMessages',\n          })\n        )\n        .subscribe(replaySubject)\n    }\n\n    // For picking up messages we prefer a long-lived transport session, so we will set a higher priority to\n    // WebSocket endpoints. However, it is not extrictly required.\n    await this.messageSender.sendMessage(outboundMessageContext, { transportPriority: { schemes: ['wss', 'ws'] } })\n\n    if (options.awaitCompletion) {\n      await firstValueFrom(replaySubject)\n    }\n  }\n\n  /**\n   * Enable or disable Live Delivery mode as a recipient. Depending on the message pickup protocol used,\n   * after receiving a response from the mediator the agent might retrieve any pending message.\n   *\n   * @param options connectionId, protocol version to use and boolean to enable/disable Live Mode\n   */\n  public async setLiveDeliveryMode(options: SetLiveDeliveryModeOptions): Promise<SetLiveDeliveryModeReturnType> {\n    const connectionRecord = await this.connectionService.getById(this.agentContext, options.connectionId)\n    const protocol = this.getProtocol(options.protocolVersion)\n    const { message } = await protocol.setLiveDeliveryMode(this.agentContext, {\n      connectionRecord,\n      liveDelivery: options.liveDelivery,\n    })\n\n    // Live mode requires a long-lived transport session, so we'll require WebSockets to send this message\n    await this.messageSender.sendMessage(\n      new DidCommOutboundMessageContext(message, {\n        agentContext: this.agentContext,\n        connection: connectionRecord,\n      }),\n      { transportPriority: { schemes: ['wss', 'ws'], restrictive: options.liveDelivery } }\n    )\n  }\n}\n"],"mappings":"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"}