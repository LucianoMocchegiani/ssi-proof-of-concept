{"version":3,"file":"DidCommConnectionsApi.mjs","names":[],"sources":["../../../src/modules/connections/DidCommConnectionsApi.ts"],"sourcesContent":["import type { Query, QueryOptions } from '@credo-ts/core'\nimport { AgentContext, CredoError, DidResolverService, injectable } from '@credo-ts/core'\nimport { DidCommMessageSender } from '../../DidCommMessageSender'\nimport { ReturnRouteTypes } from '../../decorators/transport/TransportDecorator'\nimport type { DidCommRouting } from '../../models'\nimport { DidCommOutboundMessageContext } from '../../models'\nimport { DidCommOutOfBandService } from '../oob/DidCommOutOfBandService'\nimport type { DidCommOutOfBandRecord } from '../oob/repository'\nimport { DidCommRoutingService } from '../routing/services/DidCommRoutingService'\nimport { getMediationRecordForDidDocument } from '../routing/services/helpers'\nimport { DidCommConnectionsModuleConfig } from './DidCommConnectionsModuleConfig'\nimport { DidExchangeProtocol } from './DidExchangeProtocol'\nimport { DidCommConnectionRequestMessage, DidCommDidExchangeRequestMessage } from './messages'\nimport type { DidCommConnectionType } from './models'\nimport { DidCommHandshakeProtocol } from './models'\nimport type { DidCommConnectionRecord } from './repository'\nimport { DidCommConnectionService, DidCommDidRotateService } from './services'\n\nexport interface SendPingOptions {\n  responseRequested?: boolean\n  withReturnRouting?: boolean\n}\n\n@injectable()\nexport class DidCommConnectionsApi {\n  /**\n   * Configuration for the connections module\n   */\n  public readonly config: DidCommConnectionsModuleConfig\n\n  private didExchangeProtocol: DidExchangeProtocol\n  private connectionService: DidCommConnectionService\n  private didRotateService: DidCommDidRotateService\n  private outOfBandService: DidCommOutOfBandService\n  private messageSender: DidCommMessageSender\n  private routingService: DidCommRoutingService\n  private didResolverService: DidResolverService\n  private agentContext: AgentContext\n\n  public constructor(\n    didExchangeProtocol: DidExchangeProtocol,\n    connectionService: DidCommConnectionService,\n    didRotateService: DidCommDidRotateService,\n    outOfBandService: DidCommOutOfBandService,\n    routingService: DidCommRoutingService,\n    didResolverService: DidResolverService,\n    messageSender: DidCommMessageSender,\n    agentContext: AgentContext,\n    connectionsModuleConfig: DidCommConnectionsModuleConfig\n  ) {\n    this.didExchangeProtocol = didExchangeProtocol\n    this.connectionService = connectionService\n    this.didRotateService = didRotateService\n    this.outOfBandService = outOfBandService\n    this.routingService = routingService\n    this.messageSender = messageSender\n    this.didResolverService = didResolverService\n    this.agentContext = agentContext\n    this.config = connectionsModuleConfig\n  }\n\n  public async acceptOutOfBandInvitation(\n    outOfBandRecord: DidCommOutOfBandRecord,\n    config: {\n      autoAcceptConnection?: boolean\n      label: string\n      alias?: string\n      imageUrl?: string\n      protocol: DidCommHandshakeProtocol\n      routing?: DidCommRouting\n      ourDid?: string\n    }\n  ) {\n    const { protocol, label, alias, imageUrl, autoAcceptConnection, ourDid } = config\n\n    if (ourDid && config.routing) {\n      throw new CredoError(`'routing' is disallowed when defining 'ourDid'`)\n    }\n\n    // Only generate routing if ourDid hasn't been provided\n    let routing = config.routing\n    if (!routing && !ourDid) {\n      routing = await this.routingService.getRouting(this.agentContext, { mediatorId: outOfBandRecord.mediatorId })\n    }\n\n    let result: {\n      message: DidCommDidExchangeRequestMessage | DidCommConnectionRequestMessage\n      connectionRecord: DidCommConnectionRecord\n    }\n    if (protocol === DidCommHandshakeProtocol.DidExchange) {\n      result = await this.didExchangeProtocol.createRequest(this.agentContext, outOfBandRecord, {\n        label,\n        alias,\n        routing,\n        autoAcceptConnection,\n        ourDid,\n      })\n    } else if (protocol === DidCommHandshakeProtocol.Connections) {\n      if (ourDid) {\n        throw new CredoError('Using an externally defined did for connections protocol is unsupported')\n      }\n      // This is just to make TS happy, as we always generate routing if ourDid is not provided\n      // and ourDid is not supported for connection (see check above)\n      if (!routing) {\n        throw new CredoError('Routing is required for connections protocol')\n      }\n\n      result = await this.connectionService.createRequest(this.agentContext, outOfBandRecord, {\n        label,\n        alias,\n        imageUrl,\n        routing,\n        autoAcceptConnection,\n      })\n    } else {\n      throw new CredoError(`Unsupported handshake protocol ${protocol}.`)\n    }\n\n    const { message, connectionRecord } = result\n    const outboundMessageContext = new DidCommOutboundMessageContext(message, {\n      agentContext: this.agentContext,\n      connection: connectionRecord,\n      outOfBand: outOfBandRecord,\n    })\n    await this.messageSender.sendMessage(outboundMessageContext)\n    return connectionRecord\n  }\n\n  /**\n   * Accept a connection request as inviter (by sending a connection response message) for the connection with the specified connection id.\n   * This is not needed when auto accepting of connection is enabled.\n   *\n   * @param connectionId the id of the connection for which to accept the request\n   * @returns connection record\n   */\n  public async acceptRequest(connectionId: string): Promise<DidCommConnectionRecord> {\n    const connectionRecord = await this.connectionService.findById(this.agentContext, connectionId)\n    if (!connectionRecord) {\n      throw new CredoError(`Connection record ${connectionId} not found.`)\n    }\n    if (!connectionRecord.outOfBandId) {\n      throw new CredoError(`Connection record ${connectionId} does not have out-of-band record.`)\n    }\n\n    const outOfBandRecord = await this.outOfBandService.findById(this.agentContext, connectionRecord.outOfBandId)\n    if (!outOfBandRecord) {\n      throw new CredoError(`Out-of-band record ${connectionRecord.outOfBandId} not found.`)\n    }\n\n    // We generate routing in two scenarios:\n    // 1. When the out-of-band invitation is reusable, as otherwise all connections use the same keys\n    // 2. When the out-of-band invitation has no inline services, as we don't want to generate a legacy did doc from a service did\n    const routing =\n      outOfBandRecord.reusable || outOfBandRecord.outOfBandInvitation.getInlineServices().length === 0\n        ? await this.routingService.getRouting(this.agentContext)\n        : undefined\n\n    let outboundMessageContext: DidCommOutboundMessageContext\n    if (connectionRecord.protocol === DidCommHandshakeProtocol.DidExchange) {\n      const message = await this.didExchangeProtocol.createResponse(\n        this.agentContext,\n        connectionRecord,\n        outOfBandRecord,\n        routing\n      )\n      outboundMessageContext = new DidCommOutboundMessageContext(message, {\n        agentContext: this.agentContext,\n        connection: connectionRecord,\n      })\n    } else {\n      // We generate routing in two scenarios:\n      // 1. When the out-of-band invitation is reusable, as otherwise all connections use the same keys\n      // 2. When the out-of-band invitation has no inline services, as we don't want to generate a legacy did doc from a service did\n      const routing =\n        outOfBandRecord.reusable || outOfBandRecord.outOfBandInvitation.getInlineServices().length === 0\n          ? await this.routingService.getRouting(this.agentContext)\n          : undefined\n\n      const { message } = await this.connectionService.createResponse(\n        this.agentContext,\n        connectionRecord,\n        outOfBandRecord,\n        routing\n      )\n      outboundMessageContext = new DidCommOutboundMessageContext(message, {\n        agentContext: this.agentContext,\n        connection: connectionRecord,\n      })\n    }\n\n    await this.messageSender.sendMessage(outboundMessageContext)\n    return connectionRecord\n  }\n\n  /**\n   * Accept a connection response as invitee (by sending a trust ping message) for the connection with the specified connection id.\n   * This is not needed when auto accepting of connection is enabled.\n   *\n   * @param connectionId the id of the connection for which to accept the response\n   * @returns connection record\n   */\n  public async acceptResponse(connectionId: string): Promise<DidCommConnectionRecord> {\n    const connectionRecord = await this.connectionService.getById(this.agentContext, connectionId)\n\n    let outboundMessageContext: DidCommOutboundMessageContext\n    if (connectionRecord.protocol === DidCommHandshakeProtocol.DidExchange) {\n      if (!connectionRecord.outOfBandId) {\n        throw new CredoError(`Connection ${connectionRecord.id} does not have outOfBandId!`)\n      }\n      const outOfBandRecord = await this.outOfBandService.findById(this.agentContext, connectionRecord.outOfBandId)\n      if (!outOfBandRecord) {\n        throw new CredoError(\n          `OutOfBand record for connection ${connectionRecord.id} with outOfBandId ${connectionRecord.outOfBandId} not found!`\n        )\n      }\n      const message = await this.didExchangeProtocol.createComplete(\n        this.agentContext,\n        connectionRecord,\n        outOfBandRecord\n      )\n      // Disable return routing as we don't want to receive a response for this message over the same channel\n      // This has led to long timeouts as not all clients actually close an http socket if there is no response message\n      message.setReturnRouting(ReturnRouteTypes.none)\n      outboundMessageContext = new DidCommOutboundMessageContext(message, {\n        agentContext: this.agentContext,\n        connection: connectionRecord,\n      })\n    } else {\n      const { message } = await this.connectionService.createTrustPing(this.agentContext, connectionRecord, {\n        responseRequested: false,\n      })\n      // Disable return routing as we don't want to receive a response for this message over the same channel\n      // This has led to long timeouts as not all clients actually close an http socket if there is no response message\n      message.setReturnRouting(ReturnRouteTypes.none)\n      outboundMessageContext = new DidCommOutboundMessageContext(message, {\n        agentContext: this.agentContext,\n        connection: connectionRecord,\n      })\n    }\n\n    await this.messageSender.sendMessage(outboundMessageContext)\n    return connectionRecord\n  }\n\n  /**\n   * Send a trust ping to an established connection\n   *\n   * @param connectionId the id of the connection for which to accept the response\n   * @param responseRequested do we want a response to our ping\n   * @param withReturnRouting do we want a response at the time of posting\n   * @returns TrustPingMessage\n   */\n  public async sendPing(\n    connectionId: string,\n    { responseRequested = true, withReturnRouting = undefined }: SendPingOptions = {}\n  ) {\n    const connection = await this.getById(connectionId)\n\n    const { message } = await this.connectionService.createTrustPing(this.agentContext, connection, {\n      responseRequested: responseRequested,\n    })\n\n    if (withReturnRouting === true) {\n      message.setReturnRouting(ReturnRouteTypes.all)\n    }\n\n    // Disable return routing as we don't want to receive a response for this message over the same channel\n    // This has led to long timeouts as not all clients actually close an http socket if there is no response message\n    if (withReturnRouting === false) {\n      message.setReturnRouting(ReturnRouteTypes.none)\n    }\n\n    await this.messageSender.sendMessage(\n      new DidCommOutboundMessageContext(message, { agentContext: this.agentContext, connection })\n    )\n\n    return message\n  }\n\n  /**\n   * Rotate the DID used for a given connection, notifying the other party immediately.\n   *\n   *  If `toDid` is not specified, a new peer did will be created. Optionally, routing\n   * configuration can be set.\n   *\n   * Note: any did created or imported in agent wallet can be used as `toDid`, as long as\n   * there are valid DIDComm services in its DID Document.\n   *\n   * @param options connectionId and optional target did and routing configuration\n   * @returns object containing the new did\n   */\n  public async rotate(options: { connectionId: string; toDid?: string; routing?: DidCommRouting }) {\n    const { connectionId, toDid } = options\n    const connection = await this.connectionService.getById(this.agentContext, connectionId)\n\n    if (toDid && options.routing) {\n      throw new CredoError(`'routing' is disallowed when defining 'toDid'`)\n    }\n\n    let routing = options.routing\n    if (!toDid && !routing) {\n      routing = await this.routingService.getRouting(this.agentContext, {})\n    }\n\n    const message = await this.didRotateService.createRotate(this.agentContext, {\n      connection,\n      toDid,\n      routing,\n    })\n\n    const outboundMessageContext = new DidCommOutboundMessageContext(message, {\n      agentContext: this.agentContext,\n      connection,\n    })\n\n    await this.messageSender.sendMessage(outboundMessageContext)\n\n    return { newDid: message.toDid }\n  }\n\n  /**\n   * Terminate a connection by sending a hang-up message to the other party. The connection record itself and any\n   * keys used for mediation will only be deleted if `deleteAfterHangup` flag is set.\n   *\n   * @param options connectionId\n   */\n  public async hangup(options: { connectionId: string; deleteAfterHangup?: boolean }) {\n    const connection = await this.connectionService.getById(this.agentContext, options.connectionId)\n\n    const connectionBeforeHangup = connection.clone()\n\n    // Create Hangup message and update did in connection record\n    const message = await this.didRotateService.createHangup(this.agentContext, { connection })\n\n    const outboundMessageContext = new DidCommOutboundMessageContext(message, {\n      agentContext: this.agentContext,\n      connection: connectionBeforeHangup,\n    })\n\n    await this.messageSender.sendMessage(outboundMessageContext)\n\n    // After hang-up message submission, delete connection if required\n    if (options.deleteAfterHangup) {\n      // First remove any recipient keys related to it\n      await this.removeRouting(connectionBeforeHangup)\n\n      await this.deleteById(connection.id)\n    }\n  }\n\n  public async returnWhenIsConnected(\n    connectionId: string,\n    options?: { timeoutMs: number }\n  ): Promise<DidCommConnectionRecord> {\n    return this.connectionService.returnWhenIsConnected(this.agentContext, connectionId, options?.timeoutMs)\n  }\n\n  /**\n   * Retrieve all connections records\n   *\n   * @returns List containing all connection records\n   */\n  public getAll() {\n    return this.connectionService.getAll(this.agentContext)\n  }\n\n  /**\n   * Retrieve all connections records by specified query params\n   *\n   * @returns List containing all connection records matching specified query paramaters\n   */\n  public findAllByQuery(query: Query<DidCommConnectionRecord>, queryOptions?: QueryOptions) {\n    return this.connectionService.findAllByQuery(this.agentContext, query, queryOptions)\n  }\n\n  /**\n   * Allows for the addition of connectionType to the record.\n   *  Either updates or creates an array of string connection types\n   * @param connectionId\n   * @param type\n   * @throws {RecordNotFoundError} If no record is found\n   */\n  public async addConnectionType(connectionId: string, type: DidCommConnectionType | string) {\n    const record = await this.getById(connectionId)\n\n    await this.connectionService.addConnectionType(this.agentContext, record, type)\n\n    return record\n  }\n\n  /**\n   * Removes the given tag from the given record found by connectionId, if the tag exists otherwise does nothing\n   * @param connectionId\n   * @param type\n   * @throws {RecordNotFoundError} If no record is found\n   */\n  public async removeConnectionType(connectionId: string, type: DidCommConnectionType | string) {\n    const record = await this.getById(connectionId)\n\n    await this.connectionService.removeConnectionType(this.agentContext, record, type)\n\n    return record\n  }\n\n  /**\n   * Gets the known connection types for the record matching the given connectionId\n   * @param connectionId\n   * @returns An array of known connection types or null if none exist\n   * @throws {RecordNotFoundError} If no record is found\n   */\n  public async getConnectionTypes(connectionId: string) {\n    const record = await this.getById(connectionId)\n\n    return this.connectionService.getConnectionTypes(record)\n  }\n\n  /**\n   *\n   * @param connectionTypes An array of connection types to query for a match for\n   * @returns a promise of ab array of connection records\n   */\n  public async findAllByConnectionTypes(connectionTypes: Array<DidCommConnectionType | string>) {\n    return this.connectionService.findAllByConnectionTypes(this.agentContext, connectionTypes)\n  }\n\n  /**\n   * Retrieve a connection record by id\n   *\n   * @param connectionId The connection record id\n   * @throws {RecordNotFoundError} If no record is found\n   * @return The connection record\n   *\n   */\n  public getById(connectionId: string): Promise<DidCommConnectionRecord> {\n    return this.connectionService.getById(this.agentContext, connectionId)\n  }\n\n  /**\n   * Find a connection record by id\n   *\n   * @param connectionId the connection record id\n   * @returns The connection record or null if not found\n   */\n  public findById(connectionId: string): Promise<DidCommConnectionRecord | null> {\n    return this.connectionService.findById(this.agentContext, connectionId)\n  }\n\n  /**\n   * Delete a connection record by id\n   *\n   * @param connectionId the connection record id\n   */\n  public async deleteById(connectionId: string) {\n    const connection = await this.connectionService.getById(this.agentContext, connectionId)\n\n    await this.removeRouting(connection)\n\n    return this.connectionService.deleteById(this.agentContext, connectionId)\n  }\n\n  private async removeRouting(connection: DidCommConnectionRecord) {\n    if (connection.mediatorId && connection.did) {\n      const { didDocument } = await this.didResolverService.resolve(this.agentContext, connection.did)\n\n      if (didDocument) {\n        await this.routingService.removeRouting(this.agentContext, {\n          recipientKeys: didDocument\n            .getRecipientKeysWithVerificationMethod({ mapX25519ToEd25519: true })\n            .map(({ publicJwk }) => publicJwk),\n          mediatorId: connection.mediatorId,\n        })\n      }\n    }\n  }\n\n  /**\n   * Remove relationship of a connection with any previous did (either ours or theirs), preventing it from accepting\n   * messages from them. This is usually called when a DID Rotation flow has been succesful and we are sure that no\n   * more messages with older keys will arrive.\n   *\n   * It will remove routing keys from mediator if applicable.\n   *\n   * Note: this will not actually delete any DID from the wallet.\n   *\n   * @param connectionId\n   */\n  public async removePreviousDids(options: { connectionId: string }) {\n    const connection = await this.connectionService.getById(this.agentContext, options.connectionId)\n\n    for (const previousDid of connection.previousDids) {\n      const did = await this.didResolverService.resolve(this.agentContext, previousDid)\n      if (!did.didDocument) continue\n      const mediatorRecord = await getMediationRecordForDidDocument(this.agentContext, did.didDocument)\n\n      if (mediatorRecord) {\n        await this.routingService.removeRouting(this.agentContext, {\n          recipientKeys: did.didDocument\n            .getRecipientKeysWithVerificationMethod({ mapX25519ToEd25519: true })\n            .map(({ publicJwk }) => publicJwk),\n          mediatorId: mediatorRecord.id,\n        })\n      }\n    }\n\n    connection.previousDids = []\n    connection.previousTheirDids = []\n\n    await this.connectionService.update(this.agentContext, connection)\n  }\n\n  public async findAllByOutOfBandId(outOfBandId: string) {\n    return this.connectionService.findAllByOutOfBandId(this.agentContext, outOfBandId)\n  }\n\n  /**\n   * Retrieve a connection record by thread id\n   *\n   * @param threadId The thread id\n   * @throws {RecordNotFoundError} If no record is found\n   * @throws {RecordDuplicateError} If multiple records are found\n   * @returns The connection record\n   */\n  public getByThreadId(threadId: string): Promise<DidCommConnectionRecord> {\n    return this.connectionService.getByThreadId(this.agentContext, threadId)\n  }\n\n  public async findByDid(did: string): Promise<DidCommConnectionRecord | null> {\n    return this.connectionService.findByTheirDid(this.agentContext, did)\n  }\n\n  public async findByInvitationDid(invitationDid: string): Promise<DidCommConnectionRecord[]> {\n    return this.connectionService.findByInvitationDid(this.agentContext, invitationDid)\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;AAwBO,kCAAM,sBAAsB;CAejC,AAAO,YACL,qBACA,mBACA,kBACA,kBACA,gBACA,oBACA,eACA,cACA,yBACA;AACA,OAAK,sBAAsB;AAC3B,OAAK,oBAAoB;AACzB,OAAK,mBAAmB;AACxB,OAAK,mBAAmB;AACxB,OAAK,iBAAiB;AACtB,OAAK,gBAAgB;AACrB,OAAK,qBAAqB;AAC1B,OAAK,eAAe;AACpB,OAAK,SAAS;;CAGhB,MAAa,0BACX,iBACA,QASA;EACA,MAAM,EAAE,UAAU,OAAO,OAAO,UAAU,sBAAsB,WAAW;AAE3E,MAAI,UAAU,OAAO,QACnB,OAAM,IAAI,WAAW,iDAAiD;EAIxE,IAAI,UAAU,OAAO;AACrB,MAAI,CAAC,WAAW,CAAC,OACf,WAAU,MAAM,KAAK,eAAe,WAAW,KAAK,cAAc,EAAE,YAAY,gBAAgB,YAAY,CAAC;EAG/G,IAAI;AAIJ,MAAI,aAAa,yBAAyB,YACxC,UAAS,MAAM,KAAK,oBAAoB,cAAc,KAAK,cAAc,iBAAiB;GACxF;GACA;GACA;GACA;GACA;GACD,CAAC;WACO,aAAa,yBAAyB,aAAa;AAC5D,OAAI,OACF,OAAM,IAAI,WAAW,0EAA0E;AAIjG,OAAI,CAAC,QACH,OAAM,IAAI,WAAW,+CAA+C;AAGtE,YAAS,MAAM,KAAK,kBAAkB,cAAc,KAAK,cAAc,iBAAiB;IACtF;IACA;IACA;IACA;IACA;IACD,CAAC;QAEF,OAAM,IAAI,WAAW,kCAAkC,SAAS,GAAG;EAGrE,MAAM,EAAE,SAAS,qBAAqB;EACtC,MAAM,yBAAyB,IAAI,8BAA8B,SAAS;GACxE,cAAc,KAAK;GACnB,YAAY;GACZ,WAAW;GACZ,CAAC;AACF,QAAM,KAAK,cAAc,YAAY,uBAAuB;AAC5D,SAAO;;;;;;;;;CAUT,MAAa,cAAc,cAAwD;EACjF,MAAM,mBAAmB,MAAM,KAAK,kBAAkB,SAAS,KAAK,cAAc,aAAa;AAC/F,MAAI,CAAC,iBACH,OAAM,IAAI,WAAW,qBAAqB,aAAa,aAAa;AAEtE,MAAI,CAAC,iBAAiB,YACpB,OAAM,IAAI,WAAW,qBAAqB,aAAa,oCAAoC;EAG7F,MAAM,kBAAkB,MAAM,KAAK,iBAAiB,SAAS,KAAK,cAAc,iBAAiB,YAAY;AAC7G,MAAI,CAAC,gBACH,OAAM,IAAI,WAAW,sBAAsB,iBAAiB,YAAY,aAAa;EAMvF,MAAM,UACJ,gBAAgB,YAAY,gBAAgB,oBAAoB,mBAAmB,CAAC,WAAW,IAC3F,MAAM,KAAK,eAAe,WAAW,KAAK,aAAa,GACvD;EAEN,IAAI;AACJ,MAAI,iBAAiB,aAAa,yBAAyB,YAOzD,0BAAyB,IAAI,8BANb,MAAM,KAAK,oBAAoB,eAC7C,KAAK,cACL,kBACA,iBACA,QACD,EACmE;GAClE,cAAc,KAAK;GACnB,YAAY;GACb,CAAC;OACG;GAIL,MAAM,UACJ,gBAAgB,YAAY,gBAAgB,oBAAoB,mBAAmB,CAAC,WAAW,IAC3F,MAAM,KAAK,eAAe,WAAW,KAAK,aAAa,GACvD;GAEN,MAAM,EAAE,YAAY,MAAM,KAAK,kBAAkB,eAC/C,KAAK,cACL,kBACA,iBACA,QACD;AACD,4BAAyB,IAAI,8BAA8B,SAAS;IAClE,cAAc,KAAK;IACnB,YAAY;IACb,CAAC;;AAGJ,QAAM,KAAK,cAAc,YAAY,uBAAuB;AAC5D,SAAO;;;;;;;;;CAUT,MAAa,eAAe,cAAwD;EAClF,MAAM,mBAAmB,MAAM,KAAK,kBAAkB,QAAQ,KAAK,cAAc,aAAa;EAE9F,IAAI;AACJ,MAAI,iBAAiB,aAAa,yBAAyB,aAAa;AACtE,OAAI,CAAC,iBAAiB,YACpB,OAAM,IAAI,WAAW,cAAc,iBAAiB,GAAG,6BAA6B;GAEtF,MAAM,kBAAkB,MAAM,KAAK,iBAAiB,SAAS,KAAK,cAAc,iBAAiB,YAAY;AAC7G,OAAI,CAAC,gBACH,OAAM,IAAI,WACR,mCAAmC,iBAAiB,GAAG,oBAAoB,iBAAiB,YAAY,aACzG;GAEH,MAAM,UAAU,MAAM,KAAK,oBAAoB,eAC7C,KAAK,cACL,kBACA,gBACD;AAGD,WAAQ,iBAAiB,iBAAiB,KAAK;AAC/C,4BAAyB,IAAI,8BAA8B,SAAS;IAClE,cAAc,KAAK;IACnB,YAAY;IACb,CAAC;SACG;GACL,MAAM,EAAE,YAAY,MAAM,KAAK,kBAAkB,gBAAgB,KAAK,cAAc,kBAAkB,EACpG,mBAAmB,OACpB,CAAC;AAGF,WAAQ,iBAAiB,iBAAiB,KAAK;AAC/C,4BAAyB,IAAI,8BAA8B,SAAS;IAClE,cAAc,KAAK;IACnB,YAAY;IACb,CAAC;;AAGJ,QAAM,KAAK,cAAc,YAAY,uBAAuB;AAC5D,SAAO;;;;;;;;;;CAWT,MAAa,SACX,cACA,EAAE,oBAAoB,MAAM,oBAAoB,WAA+B,EAAE,EACjF;EACA,MAAM,aAAa,MAAM,KAAK,QAAQ,aAAa;EAEnD,MAAM,EAAE,YAAY,MAAM,KAAK,kBAAkB,gBAAgB,KAAK,cAAc,YAAY,EAC3E,mBACpB,CAAC;AAEF,MAAI,sBAAsB,KACxB,SAAQ,iBAAiB,iBAAiB,IAAI;AAKhD,MAAI,sBAAsB,MACxB,SAAQ,iBAAiB,iBAAiB,KAAK;AAGjD,QAAM,KAAK,cAAc,YACvB,IAAI,8BAA8B,SAAS;GAAE,cAAc,KAAK;GAAc;GAAY,CAAC,CAC5F;AAED,SAAO;;;;;;;;;;;;;;CAeT,MAAa,OAAO,SAA6E;EAC/F,MAAM,EAAE,cAAc,UAAU;EAChC,MAAM,aAAa,MAAM,KAAK,kBAAkB,QAAQ,KAAK,cAAc,aAAa;AAExF,MAAI,SAAS,QAAQ,QACnB,OAAM,IAAI,WAAW,gDAAgD;EAGvE,IAAI,UAAU,QAAQ;AACtB,MAAI,CAAC,SAAS,CAAC,QACb,WAAU,MAAM,KAAK,eAAe,WAAW,KAAK,cAAc,EAAE,CAAC;EAGvE,MAAM,UAAU,MAAM,KAAK,iBAAiB,aAAa,KAAK,cAAc;GAC1E;GACA;GACA;GACD,CAAC;EAEF,MAAM,yBAAyB,IAAI,8BAA8B,SAAS;GACxE,cAAc,KAAK;GACnB;GACD,CAAC;AAEF,QAAM,KAAK,cAAc,YAAY,uBAAuB;AAE5D,SAAO,EAAE,QAAQ,QAAQ,OAAO;;;;;;;;CASlC,MAAa,OAAO,SAAgE;EAClF,MAAM,aAAa,MAAM,KAAK,kBAAkB,QAAQ,KAAK,cAAc,QAAQ,aAAa;EAEhG,MAAM,yBAAyB,WAAW,OAAO;EAKjD,MAAM,yBAAyB,IAAI,8BAFnB,MAAM,KAAK,iBAAiB,aAAa,KAAK,cAAc,EAAE,YAAY,CAAC,EAEjB;GACxE,cAAc,KAAK;GACnB,YAAY;GACb,CAAC;AAEF,QAAM,KAAK,cAAc,YAAY,uBAAuB;AAG5D,MAAI,QAAQ,mBAAmB;AAE7B,SAAM,KAAK,cAAc,uBAAuB;AAEhD,SAAM,KAAK,WAAW,WAAW,GAAG;;;CAIxC,MAAa,sBACX,cACA,SACkC;AAClC,SAAO,KAAK,kBAAkB,sBAAsB,KAAK,cAAc,cAAc,SAAS,UAAU;;;;;;;CAQ1G,AAAO,SAAS;AACd,SAAO,KAAK,kBAAkB,OAAO,KAAK,aAAa;;;;;;;CAQzD,AAAO,eAAe,OAAuC,cAA6B;AACxF,SAAO,KAAK,kBAAkB,eAAe,KAAK,cAAc,OAAO,aAAa;;;;;;;;;CAUtF,MAAa,kBAAkB,cAAsB,MAAsC;EACzF,MAAM,SAAS,MAAM,KAAK,QAAQ,aAAa;AAE/C,QAAM,KAAK,kBAAkB,kBAAkB,KAAK,cAAc,QAAQ,KAAK;AAE/E,SAAO;;;;;;;;CAST,MAAa,qBAAqB,cAAsB,MAAsC;EAC5F,MAAM,SAAS,MAAM,KAAK,QAAQ,aAAa;AAE/C,QAAM,KAAK,kBAAkB,qBAAqB,KAAK,cAAc,QAAQ,KAAK;AAElF,SAAO;;;;;;;;CAST,MAAa,mBAAmB,cAAsB;EACpD,MAAM,SAAS,MAAM,KAAK,QAAQ,aAAa;AAE/C,SAAO,KAAK,kBAAkB,mBAAmB,OAAO;;;;;;;CAQ1D,MAAa,yBAAyB,iBAAwD;AAC5F,SAAO,KAAK,kBAAkB,yBAAyB,KAAK,cAAc,gBAAgB;;;;;;;;;;CAW5F,AAAO,QAAQ,cAAwD;AACrE,SAAO,KAAK,kBAAkB,QAAQ,KAAK,cAAc,aAAa;;;;;;;;CASxE,AAAO,SAAS,cAA+D;AAC7E,SAAO,KAAK,kBAAkB,SAAS,KAAK,cAAc,aAAa;;;;;;;CAQzE,MAAa,WAAW,cAAsB;EAC5C,MAAM,aAAa,MAAM,KAAK,kBAAkB,QAAQ,KAAK,cAAc,aAAa;AAExF,QAAM,KAAK,cAAc,WAAW;AAEpC,SAAO,KAAK,kBAAkB,WAAW,KAAK,cAAc,aAAa;;CAG3E,MAAc,cAAc,YAAqC;AAC/D,MAAI,WAAW,cAAc,WAAW,KAAK;GAC3C,MAAM,EAAE,gBAAgB,MAAM,KAAK,mBAAmB,QAAQ,KAAK,cAAc,WAAW,IAAI;AAEhG,OAAI,YACF,OAAM,KAAK,eAAe,cAAc,KAAK,cAAc;IACzD,eAAe,YACZ,uCAAuC,EAAE,oBAAoB,MAAM,CAAC,CACpE,KAAK,EAAE,gBAAgB,UAAU;IACpC,YAAY,WAAW;IACxB,CAAC;;;;;;;;;;;;;;CAgBR,MAAa,mBAAmB,SAAmC;EACjE,MAAM,aAAa,MAAM,KAAK,kBAAkB,QAAQ,KAAK,cAAc,QAAQ,aAAa;AAEhG,OAAK,MAAM,eAAe,WAAW,cAAc;GACjD,MAAM,MAAM,MAAM,KAAK,mBAAmB,QAAQ,KAAK,cAAc,YAAY;AACjF,OAAI,CAAC,IAAI,YAAa;GACtB,MAAM,iBAAiB,MAAM,iCAAiC,KAAK,cAAc,IAAI,YAAY;AAEjG,OAAI,eACF,OAAM,KAAK,eAAe,cAAc,KAAK,cAAc;IACzD,eAAe,IAAI,YAChB,uCAAuC,EAAE,oBAAoB,MAAM,CAAC,CACpE,KAAK,EAAE,gBAAgB,UAAU;IACpC,YAAY,eAAe;IAC5B,CAAC;;AAIN,aAAW,eAAe,EAAE;AAC5B,aAAW,oBAAoB,EAAE;AAEjC,QAAM,KAAK,kBAAkB,OAAO,KAAK,cAAc,WAAW;;CAGpE,MAAa,qBAAqB,aAAqB;AACrD,SAAO,KAAK,kBAAkB,qBAAqB,KAAK,cAAc,YAAY;;;;;;;;;;CAWpF,AAAO,cAAc,UAAoD;AACvE,SAAO,KAAK,kBAAkB,cAAc,KAAK,cAAc,SAAS;;CAG1E,MAAa,UAAU,KAAsD;AAC3E,SAAO,KAAK,kBAAkB,eAAe,KAAK,cAAc,IAAI;;CAGtE,MAAa,oBAAoB,eAA2D;AAC1F,SAAO,KAAK,kBAAkB,oBAAoB,KAAK,cAAc,cAAc;;;oCA5ftF,YAAY"}