{"version":3,"file":"DidExchangeProtocol.mjs","names":[],"sources":["../../../src/modules/connections/DidExchangeProtocol.ts"],"sourcesContent":["import type { AgentContext, DidDocumentKey, ResolvedDidCommService } from '@credo-ts/core'\nimport {\n  Buffer,\n  base64ToBase64URL,\n  CredoError,\n  DidDocument,\n  DidKey,\n  DidRepository,\n  DidsApi,\n  getAlternativeDidsForPeerDid,\n  getNumAlgoFromPeerDid,\n  getPublicJwkFromVerificationMethod,\n  InjectionSymbols,\n  inject,\n  injectable,\n  isDid,\n  isValidPeerDid,\n  JsonEncoder,\n  JsonTransformer,\n  JwsService,\n  Kms,\n  type Logger,\n  PeerDidNumAlgo,\n  parseDid,\n  TypedArrayEncoder,\n  tryParseDid,\n} from '@credo-ts/core'\nimport { DidCommAttachment, DidCommAttachmentData } from '../../decorators/attachment/DidCommAttachment'\nimport type { DidCommRouting } from '../../models'\nimport { DidCommInboundMessageContext } from '../../models'\nimport type { ParsedMessageType } from '../../util/messageType'\nimport { DidCommOutOfBandRole } from '../oob/domain/DidCommOutOfBandRole'\nimport { DidCommOutOfBandState } from '../oob/domain/DidCommOutOfBandState'\nimport type { DidCommOutOfBandRecord } from '../oob/repository'\nimport { getMediationRecordForDidDocument } from '../routing/services/helpers'\nimport { DidCommConnectionsModuleConfig } from './DidCommConnectionsModuleConfig'\nimport { DidExchangeStateMachine } from './DidExchangeStateMachine'\nimport { DidExchangeProblemReportError, DidExchangeProblemReportReason } from './errors'\nimport {\n  DidCommDidExchangeCompleteMessage,\n  DidCommDidExchangeRequestMessage,\n  DidCommDidExchangeResponseMessage,\n} from './messages'\nimport { DidCommDidExchangeRole, DidCommDidExchangeState, DidCommHandshakeProtocol } from './models'\nimport type { DidCommConnectionRecord } from './repository'\nimport { DidCommConnectionService } from './services'\nimport {\n  createPeerDidFromServices,\n  getResolvedDidcommServiceWithSigningKeyId,\n  routingToServices,\n} from './services/helpers'\n\ninterface DidExchangeRequestParams {\n  label: string\n  alias?: string\n  goal?: string\n  goalCode?: string\n  routing?: DidCommRouting\n  autoAcceptConnection?: boolean\n  ourDid?: string\n}\n\n@injectable()\nexport class DidExchangeProtocol {\n  private connectionService: DidCommConnectionService\n  private jwsService: JwsService\n  private didRepository: DidRepository\n  private logger: Logger\n\n  public constructor(\n    connectionService: DidCommConnectionService,\n    didRepository: DidRepository,\n    jwsService: JwsService,\n    @inject(InjectionSymbols.Logger) logger: Logger\n  ) {\n    this.connectionService = connectionService\n    this.didRepository = didRepository\n    this.jwsService = jwsService\n    this.logger = logger\n  }\n\n  public async createRequest(\n    agentContext: AgentContext,\n    outOfBandRecord: DidCommOutOfBandRecord,\n    params: DidExchangeRequestParams\n  ): Promise<{ message: DidCommDidExchangeRequestMessage; connectionRecord: DidCommConnectionRecord }> {\n    this.logger.debug(`Create message ${DidCommDidExchangeRequestMessage.type.messageTypeUri} start`, {\n      outOfBandRecord,\n      params,\n    })\n    const config = agentContext.dependencyManager.resolve(DidCommConnectionsModuleConfig)\n\n    const { outOfBandInvitation } = outOfBandRecord\n    const { alias, goal, goalCode, routing, autoAcceptConnection, ourDid: did } = params\n    // TODO: We should store only one did that we'll use to send the request message with success.\n    // We take just the first one for now.\n    const [invitationDid] = outOfBandInvitation.invitationDids\n\n    // Create message\n    const label = params.label\n\n    let didDocument: DidDocument\n    let keys: DidDocumentKey[] | undefined\n    let mediatorId: string | undefined\n\n    // If our did is specified, make sure we have all key material for it\n    if (did) {\n      const dids = agentContext.resolve(DidsApi)\n      const resolved = await dids.resolveCreatedDidDocumentWithKeys(did)\n      didDocument = resolved.didDocument\n      keys = resolved.keys\n      mediatorId = (await getMediationRecordForDidDocument(agentContext, didDocument))?.id\n    }\n    // Otherwise, create a did:peer based on the provided routing\n    else {\n      if (!routing) throw new CredoError(`'routing' must be defined if 'ourDid' is not specified`)\n\n      const resolved = await createPeerDidFromServices(\n        agentContext,\n        routingToServices(routing),\n        config.peerNumAlgoForDidExchangeRequests\n      )\n      didDocument = resolved.didDocument\n      keys = resolved.keys\n      mediatorId = routing.mediatorId\n    }\n\n    const parentThreadId = outOfBandRecord.outOfBandInvitation.id\n\n    const message = new DidCommDidExchangeRequestMessage({ label, parentThreadId, did: didDocument.id, goal, goalCode })\n\n    const signingKeys = didDocument\n      .getRecipientKeysWithVerificationMethod({ mapX25519ToEd25519: true })\n      .map(({ publicJwk, verificationMethod }) => {\n        // Bind the kmsKeyIds\n        const kmsKeyId = keys?.find(({ didDocumentRelativeKeyId }) =>\n          verificationMethod.id.endsWith(didDocumentRelativeKeyId)\n        )?.kmsKeyId\n\n        publicJwk.keyId = kmsKeyId ?? publicJwk.legacyKeyId\n\n        return publicJwk\n      })\n\n    // Create sign attachment containing didDoc\n    if (isValidPeerDid(didDocument.id) && getNumAlgoFromPeerDid(didDocument.id) === PeerDidNumAlgo.GenesisDoc) {\n      const didDocAttach = await this.createSignedAttachment(agentContext, didDocument.toJSON(), signingKeys)\n      message.didDoc = didDocAttach\n    }\n\n    const connectionRecord = await this.connectionService.createConnection(agentContext, {\n      protocol: DidCommHandshakeProtocol.DidExchange,\n      role: DidCommDidExchangeRole.Requester,\n      alias,\n      state: DidCommDidExchangeState.InvitationReceived,\n      theirLabel: outOfBandInvitation.label,\n      mediatorId,\n      autoAcceptConnection: outOfBandRecord.autoAcceptConnection,\n      outOfBandId: outOfBandRecord.id,\n      invitationDid,\n      imageUrl: outOfBandInvitation.imageUrl,\n    })\n\n    DidExchangeStateMachine.assertCreateMessageState(DidCommDidExchangeRequestMessage.type, connectionRecord)\n\n    connectionRecord.did = didDocument.id\n    connectionRecord.threadId = message.id\n\n    if (autoAcceptConnection !== undefined || autoAcceptConnection !== null) {\n      connectionRecord.autoAcceptConnection = autoAcceptConnection\n    }\n\n    await this.updateState(agentContext, DidCommDidExchangeRequestMessage.type, connectionRecord)\n    this.logger.debug(`Create message ${DidCommDidExchangeRequestMessage.type.messageTypeUri} end`, {\n      connectionRecord,\n      message,\n    })\n    return { message, connectionRecord }\n  }\n\n  public async processRequest(\n    messageContext: DidCommInboundMessageContext<DidCommDidExchangeRequestMessage>,\n    outOfBandRecord: DidCommOutOfBandRecord\n  ): Promise<DidCommConnectionRecord> {\n    this.logger.debug(`Process message ${messageContext.message.type} start`, {\n      message: messageContext.message,\n    })\n\n    outOfBandRecord.assertRole(DidCommOutOfBandRole.Sender)\n    outOfBandRecord.assertState(DidCommOutOfBandState.AwaitResponse)\n\n    // TODO check there is no connection record for particular oob record\n\n    const { message, agentContext } = messageContext\n\n    // Check corresponding invitation ID is the request's ~thread.pthid or pthid is a public did\n    // TODO Maybe we can do it in handler, but that actually does not make sense because we try to find oob by parent thread ID there.\n    const parentThreadId = message.thread?.parentThreadId\n    if (\n      !parentThreadId ||\n      (!tryParseDid(parentThreadId) && parentThreadId !== outOfBandRecord.getTags().invitationId)\n    ) {\n      throw new DidExchangeProblemReportError('Missing reference to invitation.', {\n        problemCode: DidExchangeProblemReportReason.RequestNotAccepted,\n      })\n    }\n\n    // If the responder wishes to continue the exchange, they will persist the received information in their wallet.\n\n    // Get DID Document either from message (if it is a supported did:peer) or resolve it externally\n    const didDocument = await this.resolveDidDocument(agentContext, message)\n\n    // A DID Record must be stored in order to allow for searching for its recipient keys when receiving a message\n    const didRecord = await this.didRepository.storeReceivedDid(messageContext.agentContext, {\n      did: didDocument.id,\n      // It is important to take the did document from the PeerDid class\n      // as it will have the id property\n      didDocument:\n        !isValidPeerDid(didDocument.id) || getNumAlgoFromPeerDid(message.did) === PeerDidNumAlgo.GenesisDoc\n          ? didDocument\n          : undefined,\n      tags: {\n        // We need to save the recipientKeys, so we can find the associated did\n        // of a key when we receive a message from another connection.\n        recipientKeyFingerprints: didDocument.recipientKeys.map((key) => key.fingerprint),\n\n        // For did:peer, store any alternative dids (like short form did:peer:4),\n        // it may have in order to relate any message referencing it\n        alternativeDids: isValidPeerDid(didDocument.id) ? getAlternativeDidsForPeerDid(didDocument.id) : undefined,\n      },\n    })\n\n    this.logger.debug('Saved DID record', {\n      id: didRecord.id,\n      did: didRecord.did,\n      role: didRecord.role,\n      tags: didRecord.getTags(),\n      didDocument: 'omitted...',\n    })\n\n    const connectionRecord = await this.connectionService.createConnection(messageContext.agentContext, {\n      protocol: DidCommHandshakeProtocol.DidExchange,\n      role: DidCommDidExchangeRole.Responder,\n      state: DidCommDidExchangeState.RequestReceived,\n      alias: outOfBandRecord.alias,\n      theirDid: message.did,\n      theirLabel: message.label,\n      threadId: message.threadId,\n      mediatorId: outOfBandRecord.mediatorId,\n      autoAcceptConnection: outOfBandRecord.autoAcceptConnection,\n      outOfBandId: outOfBandRecord.id,\n    })\n\n    await this.updateState(messageContext.agentContext, DidCommDidExchangeRequestMessage.type, connectionRecord)\n    this.logger.debug(`Process message ${DidCommDidExchangeRequestMessage.type.messageTypeUri} end`, connectionRecord)\n    return connectionRecord\n  }\n\n  public async createResponse(\n    agentContext: AgentContext,\n    connectionRecord: DidCommConnectionRecord,\n    outOfBandRecord: DidCommOutOfBandRecord,\n    routing?: DidCommRouting\n  ): Promise<DidCommDidExchangeResponseMessage> {\n    this.logger.debug(`Create message ${DidCommDidExchangeResponseMessage.type.messageTypeUri} start`, connectionRecord)\n    DidExchangeStateMachine.assertCreateMessageState(DidCommDidExchangeResponseMessage.type, connectionRecord)\n\n    const { threadId, theirDid } = connectionRecord\n\n    const config = agentContext.dependencyManager.resolve(DidCommConnectionsModuleConfig)\n\n    if (!threadId) {\n      throw new CredoError('Missing threadId on connection record.')\n    }\n\n    if (!theirDid) {\n      throw new CredoError('Missing theirDid on connection record.')\n    }\n\n    // Extract keys from the out of band record metadata\n    const inlineResolvedServices = outOfBandRecord.outOfBandInvitation\n      .getInlineServices()\n      .map((service) => getResolvedDidcommServiceWithSigningKeyId(service, outOfBandRecord.invitationInlineServiceKeys))\n\n    let services: ResolvedDidCommService[] = []\n\n    if (routing) {\n      services = routingToServices(routing)\n    } else if (inlineResolvedServices.length > 0) {\n      services = inlineResolvedServices\n    } else {\n      // We don't support using a did from the OOB invitation services currently, in this case we always pass routing to this method\n      throw new CredoError(\n        'No routing provided, and no inline services found in out of band invitation. When using did services in out of band invitation, make sure to provide routing information for rotation.'\n      )\n    }\n\n    // Use the same num algo for response as received in request\n    const numAlgo = isValidPeerDid(theirDid)\n      ? getNumAlgoFromPeerDid(theirDid)\n      : config.peerNumAlgoForDidExchangeRequests\n\n    const { didDocument } = await createPeerDidFromServices(agentContext, services, numAlgo)\n    const message = new DidCommDidExchangeResponseMessage({ did: didDocument.id, threadId })\n\n    // DID Rotate attachment should be signed with invitation keys\n    const invitationRecipientKeys = inlineResolvedServices.flatMap((s) => s.recipientKeys)\n\n    // Consider also pure-DID services, used when DID Exchange is started with an implicit invitation or a public DID\n    for (const did of outOfBandRecord.outOfBandInvitation.getDidServices()) {\n      const dids = agentContext.resolve(DidsApi)\n      const resolved = await dids.resolveCreatedDidDocumentWithKeys(parseDid(did).did)\n      invitationRecipientKeys.push(\n        ...resolved.didDocument\n          .getRecipientKeysWithVerificationMethod({ mapX25519ToEd25519: true })\n          .map(({ publicJwk, verificationMethod }) => {\n            const kmsKeyId = resolved.keys?.find(({ didDocumentRelativeKeyId }) =>\n              verificationMethod.id.endsWith(didDocumentRelativeKeyId)\n            )?.kmsKeyId\n\n            publicJwk.keyId = kmsKeyId ?? publicJwk.legacyKeyId\n            return publicJwk\n          })\n      )\n    }\n\n    if (numAlgo === PeerDidNumAlgo.GenesisDoc) {\n      message.didDoc = await this.createSignedAttachment(agentContext, didDocument.toJSON(), invitationRecipientKeys)\n    } else {\n      // We assume any other case is a resolvable did (e.g. did:peer:2 or did:peer:4)\n      message.didRotate = await this.createSignedAttachment(agentContext, didDocument.id, invitationRecipientKeys)\n    }\n\n    connectionRecord.did = didDocument.id\n\n    await this.updateState(agentContext, DidCommDidExchangeResponseMessage.type, connectionRecord)\n    this.logger.debug(`Create message ${DidCommDidExchangeResponseMessage.type.messageTypeUri} end`, {\n      connectionRecord,\n      message,\n    })\n    return message\n  }\n\n  public async processResponse(\n    messageContext: DidCommInboundMessageContext<DidCommDidExchangeResponseMessage>,\n    outOfBandRecord: DidCommOutOfBandRecord\n  ): Promise<DidCommConnectionRecord> {\n    this.logger.debug(`Process message ${DidCommDidExchangeResponseMessage.type.messageTypeUri} start`, {\n      message: messageContext.message,\n    })\n\n    const { connection: connectionRecord, message, agentContext } = messageContext\n\n    if (!connectionRecord) {\n      throw new CredoError('No connection record in message context.')\n    }\n\n    DidExchangeStateMachine.assertProcessMessageState(DidCommDidExchangeResponseMessage.type, connectionRecord)\n\n    if (!message.thread?.threadId || message.thread?.threadId !== connectionRecord.threadId) {\n      throw new DidExchangeProblemReportError('Invalid or missing thread ID.', {\n        problemCode: DidExchangeProblemReportReason.ResponseNotAccepted,\n      })\n    }\n\n    // Get DID Document either from message (if it is a did:peer) or resolve it externally\n    const didDocument = await this.resolveDidDocument(\n      agentContext,\n      message,\n      outOfBandRecord.getTags().recipientKeyFingerprints.map((fingerprint) => {\n        const publicJwk = Kms.PublicJwk.fromFingerprint(fingerprint)\n        if (!publicJwk.is(Kms.Ed25519PublicJwk)) {\n          throw new CredoError('Expected fingerprint to be of type Ed25519')\n        }\n        return publicJwk\n      })\n    )\n\n    if (isValidPeerDid(didDocument.id)) {\n      const didRecord = await this.didRepository.storeReceivedDid(messageContext.agentContext, {\n        did: didDocument.id,\n        didDocument: getNumAlgoFromPeerDid(message.did) === PeerDidNumAlgo.GenesisDoc ? didDocument : undefined,\n        tags: {\n          // We need to save the recipientKeys, so we can find the associated did\n          // of a key when we receive a message from another connection.\n          recipientKeyFingerprints: didDocument.recipientKeys.map((key) => key.fingerprint),\n\n          // For did:peer, store any alternative dids (like short form did:peer:4),\n          // it may have in order to relate any message referencing it\n          alternativeDids: getAlternativeDidsForPeerDid(didDocument.id),\n        },\n      })\n\n      this.logger.debug('Saved DID record', {\n        id: didRecord.id,\n        did: didRecord.did,\n        role: didRecord.role,\n        tags: didRecord.getTags(),\n        didDocument: 'omitted...',\n      })\n    }\n\n    connectionRecord.theirDid = message.did\n\n    await this.updateState(messageContext.agentContext, DidCommDidExchangeResponseMessage.type, connectionRecord)\n    this.logger.debug(`Process message ${DidCommDidExchangeResponseMessage.type.messageTypeUri} end`, connectionRecord)\n    return connectionRecord\n  }\n\n  public async createComplete(\n    agentContext: AgentContext,\n    connectionRecord: DidCommConnectionRecord,\n    outOfBandRecord: DidCommOutOfBandRecord\n  ): Promise<DidCommDidExchangeCompleteMessage> {\n    this.logger.debug(`Create message ${DidCommDidExchangeCompleteMessage.type.messageTypeUri} start`, connectionRecord)\n    DidExchangeStateMachine.assertCreateMessageState(DidCommDidExchangeCompleteMessage.type, connectionRecord)\n\n    const threadId = connectionRecord.threadId\n    const parentThreadId = outOfBandRecord.outOfBandInvitation.id\n\n    if (!threadId) {\n      throw new CredoError(`Connection record ${connectionRecord.id} does not have 'threadId' attribute.`)\n    }\n\n    if (!parentThreadId) {\n      throw new CredoError(`Connection record ${connectionRecord.id} does not have 'parentThreadId' attribute.`)\n    }\n\n    const message = new DidCommDidExchangeCompleteMessage({ threadId, parentThreadId })\n\n    await this.updateState(agentContext, DidCommDidExchangeCompleteMessage.type, connectionRecord)\n    this.logger.debug(`Create message ${DidCommDidExchangeCompleteMessage.type.messageTypeUri} end`, {\n      connectionRecord,\n      message,\n    })\n    return message\n  }\n\n  public async processComplete(\n    messageContext: DidCommInboundMessageContext<DidCommDidExchangeCompleteMessage>,\n    outOfBandRecord: DidCommOutOfBandRecord\n  ): Promise<DidCommConnectionRecord> {\n    this.logger.debug(`Process message ${DidCommDidExchangeCompleteMessage.type.messageTypeUri} start`, {\n      message: messageContext.message,\n    })\n\n    const { connection: connectionRecord, message } = messageContext\n\n    if (!connectionRecord) {\n      throw new CredoError('No connection record in message context.')\n    }\n\n    DidExchangeStateMachine.assertProcessMessageState(DidCommDidExchangeCompleteMessage.type, connectionRecord)\n\n    if (message.threadId !== connectionRecord.threadId) {\n      throw new DidExchangeProblemReportError('Invalid or missing thread ID.', {\n        problemCode: DidExchangeProblemReportReason.CompleteRejected,\n      })\n    }\n    const pthid = message.thread?.parentThreadId\n    if (!pthid || pthid !== outOfBandRecord.outOfBandInvitation.id) {\n      throw new DidExchangeProblemReportError('Invalid or missing parent thread ID referencing to the invitation.', {\n        problemCode: DidExchangeProblemReportReason.CompleteRejected,\n      })\n    }\n\n    await this.updateState(messageContext.agentContext, DidCommDidExchangeCompleteMessage.type, connectionRecord)\n    this.logger.debug(`Process message ${DidCommDidExchangeCompleteMessage.type.messageTypeUri} end`, {\n      connectionRecord,\n    })\n    return connectionRecord\n  }\n\n  private async updateState(\n    agentContext: AgentContext,\n    messageType: ParsedMessageType,\n    connectionRecord: DidCommConnectionRecord\n  ) {\n    this.logger.debug('Updating state', { connectionRecord })\n    const nextState = DidExchangeStateMachine.nextState(messageType, connectionRecord)\n    return this.connectionService.updateState(agentContext, connectionRecord, nextState)\n  }\n\n  private async createSignedAttachment(\n    agentContext: AgentContext,\n    data: string | Record<string, unknown>,\n    signingKeys: Kms.PublicJwk<Kms.Ed25519PublicJwk>[]\n  ) {\n    this.logger.debug('Creating signed attachment')\n    const signedAttach = new DidCommAttachment({\n      mimeType: typeof data === 'string' ? undefined : 'application/json',\n      data: new DidCommAttachmentData({\n        base64:\n          typeof data === 'string' ? TypedArrayEncoder.toBase64URL(Buffer.from(data)) : JsonEncoder.toBase64(data),\n      }),\n    })\n\n    await Promise.all(\n      signingKeys.map(async (signingKey) => {\n        const kid = new DidKey(signingKey).did\n        const payload = typeof data === 'string' ? TypedArrayEncoder.fromString(data) : JsonEncoder.toBuffer(data)\n\n        const jws = await this.jwsService.createJws(agentContext, {\n          payload,\n          keyId: signingKey.keyId,\n          header: {\n            kid,\n          },\n          protectedHeaderOptions: {\n            alg: Kms.KnownJwaSignatureAlgorithms.EdDSA,\n            jwk: signingKey,\n          },\n        })\n        signedAttach.addJws(jws)\n      })\n    )\n\n    return signedAttach\n  }\n\n  /**\n   * Resolves a did document from a given `request` or `response` message, verifying its signature or did rotate\n   * signature in case it is taken from message attachment.\n   *\n   * @param message DID request or DID response message\n   * @param invitationKeys array containing keys from connection invitation that could be used for signing of DID document\n   * @returns verified DID document content from message attachment\n   */\n\n  private async resolveDidDocument(\n    agentContext: AgentContext,\n    message: DidCommDidExchangeRequestMessage | DidCommDidExchangeResponseMessage,\n    invitationKeys: Kms.PublicJwk<Kms.Ed25519PublicJwk>[] = []\n  ) {\n    // The only supported case where we expect to receive a did-document attachment is did:peer algo 1\n    return isDid(message.did, 'peer') && getNumAlgoFromPeerDid(message.did) === PeerDidNumAlgo.GenesisDoc\n      ? this.extractAttachedDidDocument(agentContext, message, invitationKeys)\n      : this.extractResolvableDidDocument(agentContext, message, invitationKeys)\n  }\n\n  /**\n   * Extracts DID document from message (resolving it externally if required) and verifies did-rotate attachment signature\n   * if applicable\n   */\n  private async extractResolvableDidDocument(\n    agentContext: AgentContext,\n    message: DidCommDidExchangeRequestMessage | DidCommDidExchangeResponseMessage,\n    invitationKeys?: Kms.PublicJwk<Kms.Ed25519PublicJwk>[]\n  ) {\n    // Validate did-rotate attachment in case of DID Exchange response\n    if (message instanceof DidCommDidExchangeResponseMessage) {\n      const didRotateAttachment = message.didRotate\n\n      if (!didRotateAttachment) {\n        throw new DidExchangeProblemReportError('DID Rotate attachment is missing.', {\n          problemCode: DidExchangeProblemReportReason.ResponseNotAccepted,\n        })\n      }\n\n      const jws = didRotateAttachment.data.jws\n\n      if (!jws) {\n        throw new DidExchangeProblemReportError('DID Rotate signature is missing.', {\n          problemCode: DidExchangeProblemReportReason.ResponseNotAccepted,\n        })\n      }\n\n      if (!didRotateAttachment.data.base64) {\n        throw new CredoError('DID Rotate attachment is missing base64 property for signed did.')\n      }\n\n      // JWS payload must be base64url encoded\n      const base64UrlPayload = base64ToBase64URL(didRotateAttachment.data.base64)\n      const signedDid = TypedArrayEncoder.fromBase64(base64UrlPayload).toString()\n\n      if (signedDid !== message.did) {\n        throw new CredoError(\n          `DID Rotate attachment's did ${message.did} does not correspond to message did ${message.did}`\n        )\n      }\n\n      const { isValid, jwsSigners } = await this.jwsService.verifyJws(agentContext, {\n        jws: {\n          ...jws,\n          payload: base64UrlPayload,\n        },\n        allowedJwsSignerMethods: ['did'],\n        resolveJwsSigner: ({ jws: { header } }) => {\n          if (typeof header.kid !== 'string' || !isDid(header.kid, 'key')) {\n            throw new CredoError('JWS header kid must be a did:key DID.')\n          }\n\n          const didKey = DidKey.fromDid(header.kid)\n          return {\n            method: 'did',\n            didUrl: `${didKey.did}#${didKey.publicJwk.fingerprint}`,\n            jwk: didKey.publicJwk,\n          }\n        },\n      })\n\n      const jwsSignerKeys = jwsSigners.map((signer) => signer.jwk)\n      if (!jwsSignerKeys.every((key) => key.is(Kms.Ed25519PublicJwk))) {\n        throw new DidExchangeProblemReportError('Expected DID Rotate signature to be signed with Ed25519 key.', {\n          problemCode: DidExchangeProblemReportReason.ResponseNotAccepted,\n        })\n      }\n\n      if (\n        !isValid ||\n        !jwsSignerKeys.every((key) => invitationKeys?.some((invitationKey) => invitationKey.equals(key)))\n      ) {\n        throw new DidExchangeProblemReportError(\n          `DID Rotate signature is invalid. isValid: ${isValid} signerKeys: ${JSON.stringify(\n            jwsSignerKeys.map((key) => key.fingerprint)\n          )} invitationKeys:${JSON.stringify(invitationKeys?.map((key) => key.fingerprint))}`,\n          {\n            problemCode: DidExchangeProblemReportReason.ResponseNotAccepted,\n          }\n        )\n      }\n    }\n\n    // Now resolve the document related to the did (which can be either a public did or an inline did)\n    try {\n      return await agentContext.dependencyManager.resolve(DidsApi).resolveDidDocument(message.did)\n    } catch (error) {\n      const problemCode =\n        message instanceof DidCommDidExchangeRequestMessage\n          ? DidExchangeProblemReportReason.RequestNotAccepted\n          : DidExchangeProblemReportReason.ResponseNotAccepted\n\n      throw new DidExchangeProblemReportError(error, {\n        problemCode,\n      })\n    }\n  }\n\n  /**\n   * Extracts DID document as is from request or response message attachment and verifies its signature.\n   *\n   * @param message DID request or DID response message\n   * @param invitationKeys array containing keys from connection invitation that could be used for signing of DID document\n   * @returns verified DID document content from message attachment\n   */\n  private async extractAttachedDidDocument(\n    agentContext: AgentContext,\n    message: DidCommDidExchangeRequestMessage | DidCommDidExchangeResponseMessage,\n    invitationKeys: Kms.PublicJwk<Kms.Ed25519PublicJwk>[] = []\n  ): Promise<DidDocument> {\n    if (!message.didDoc) {\n      const problemCode =\n        message instanceof DidCommDidExchangeRequestMessage\n          ? DidExchangeProblemReportReason.RequestNotAccepted\n          : DidExchangeProblemReportReason.ResponseNotAccepted\n      throw new DidExchangeProblemReportError('DID Document attachment is missing.', { problemCode })\n    }\n    const didDocumentAttachment = message.didDoc\n    const jws = didDocumentAttachment.data.jws\n\n    if (!jws) {\n      const problemCode =\n        message instanceof DidCommDidExchangeRequestMessage\n          ? DidExchangeProblemReportReason.RequestNotAccepted\n          : DidExchangeProblemReportReason.ResponseNotAccepted\n      throw new DidExchangeProblemReportError('DID Document signature is missing.', { problemCode })\n    }\n\n    if (!didDocumentAttachment.data.base64) {\n      throw new CredoError('DID Document attachment is missing base64 property for signed did document.')\n    }\n\n    // JWS payload must be base64url encoded\n    const base64UrlPayload = base64ToBase64URL(didDocumentAttachment.data.base64)\n\n    const { isValid, jwsSigners } = await this.jwsService.verifyJws(agentContext, {\n      jws: {\n        ...jws,\n        payload: base64UrlPayload,\n      },\n      allowedJwsSignerMethods: ['did'],\n      resolveJwsSigner: ({ jws: { header } }) => {\n        if (typeof header.kid !== 'string' || !isDid(header.kid, 'key')) {\n          throw new CredoError('JWS header kid must be a did:key DID.')\n        }\n\n        const didKey = DidKey.fromDid(header.kid)\n        return {\n          method: 'did',\n          didUrl: `${didKey.did}#${didKey.publicJwk.fingerprint}`,\n          jwk: didKey.publicJwk,\n        }\n      },\n    })\n\n    const json = JsonEncoder.fromBase64(didDocumentAttachment.data.base64)\n    const didDocument = JsonTransformer.fromJSON(json, DidDocument)\n    const didDocumentKeys = didDocument.authentication\n      ?.map((authentication) => {\n        const verificationMethod =\n          typeof authentication === 'string'\n            ? didDocument.dereferenceVerificationMethod(authentication)\n            : authentication\n\n        const publicJwk = getPublicJwkFromVerificationMethod(verificationMethod)\n        return publicJwk\n      })\n      .concat(invitationKeys)\n\n    this.logger.trace('JWS verification result', { isValid, jwsSigners })\n\n    if (!isValid || !jwsSigners.every((jwsSigner) => didDocumentKeys?.some((key) => key.equals(jwsSigner.jwk)))) {\n      const problemCode =\n        message instanceof DidCommDidExchangeRequestMessage\n          ? DidExchangeProblemReportReason.RequestNotAccepted\n          : DidExchangeProblemReportReason.ResponseNotAccepted\n      throw new DidExchangeProblemReportError('DID Document signature is invalid.', { problemCode })\n    }\n\n    return didDocument\n  }\n}\n"],"mappings":"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"}