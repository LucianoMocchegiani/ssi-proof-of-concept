import { __decorate } from "../../../_virtual/_@oxc-project_runtime@0.110.0/helpers/decorate.mjs";
import { __decorateMetadata } from "../../../_virtual/_@oxc-project_runtime@0.110.0/helpers/decorateMetadata.mjs";
import { DidCommDidExchangeState } from "../models/DidCommDidExchangeState.mjs";
import { rfc0160StateFromDidExchangeState } from "../models/DidCommConnectionState.mjs";
import { DidCommDidExchangeRole } from "../models/DidCommDidExchangeRole.mjs";
import { DidCommHandshakeProtocol } from "../models/DidCommHandshakeProtocol.mjs";
import "../models/index.mjs";
import { BaseRecord, CredoError, utils } from "@credo-ts/core";
import { Transform } from "class-transformer";

//#region src/modules/connections/repository/DidCommConnectionRecord.ts
var _ref;
var DidCommConnectionRecord = class DidCommConnectionRecord extends BaseRecord {
	constructor(props) {
		super();
		this.connectionTypes = [];
		this.previousDids = [];
		this.previousTheirDids = [];
		this.type = DidCommConnectionRecord.type;
		this.allowCache = DidCommConnectionRecord.allowCache;
		if (props) {
			this.id = props.id ?? utils.uuid();
			this.createdAt = props.createdAt ?? /* @__PURE__ */ new Date();
			this.did = props.did;
			this.invitationDid = props.invitationDid;
			this.theirDid = props.theirDid;
			this.theirLabel = props.theirLabel;
			this.state = props.state;
			this.role = props.role;
			this.alias = props.alias;
			this.autoAcceptConnection = props.autoAcceptConnection;
			this._tags = props.tags ?? {};
			this.threadId = props.threadId;
			this.imageUrl = props.imageUrl;
			this.mediatorId = props.mediatorId;
			this.errorMessage = props.errorMessage;
			this.protocol = props.protocol;
			this.outOfBandId = props.outOfBandId;
			this.connectionTypes = props.connectionTypes ?? [];
			this.previousDids = props.previousDids ?? [];
			this.previousTheirDids = props.previousTheirDids ?? [];
		}
	}
	getTags() {
		return {
			...this._tags,
			state: this.state,
			role: this.role,
			threadId: this.threadId,
			mediatorId: this.mediatorId,
			did: this.did,
			theirDid: this.theirDid,
			outOfBandId: this.outOfBandId,
			invitationDid: this.invitationDid,
			connectionTypes: this.connectionTypes,
			previousDids: this.previousDids,
			previousTheirDids: this.previousTheirDids
		};
	}
	get isRequester() {
		return this.role === DidCommDidExchangeRole.Requester;
	}
	get rfc0160State() {
		return rfc0160StateFromDidExchangeState(this.state);
	}
	get isReady() {
		return this.state && [DidCommDidExchangeState.Completed, DidCommDidExchangeState.ResponseSent].includes(this.state);
	}
	assertReady() {
		if (!this.isReady) throw new CredoError(`Connection record is not ready to be used. Expected ${DidCommDidExchangeState.ResponseSent}, ${DidCommDidExchangeState.ResponseReceived} or ${DidCommDidExchangeState.Completed}, found invalid state ${this.state}`);
	}
	assertState(expectedStates) {
		if (!Array.isArray(expectedStates)) expectedStates = [expectedStates];
		if (!expectedStates.includes(this.state)) throw new CredoError(`Connection record is in invalid state ${this.state}. Valid states are: ${expectedStates.join(", ")}.`);
	}
	assertRole(expectedRole) {
		if (this.role !== expectedRole) throw new CredoError(`Connection record has invalid role ${this.role}. Expected role ${expectedRole}.`);
	}
};
DidCommConnectionRecord.type = "ConnectionRecord";
DidCommConnectionRecord.allowCache = true;
__decorate([Transform(({ value }) => {
	if (!value || typeof value !== "string" || value.endsWith(".x")) return value;
	return `${value.split(".").slice(0, -1).join(".")}.x`;
}, { toClassOnly: true }), __decorateMetadata("design:type", typeof (_ref = typeof DidCommHandshakeProtocol !== "undefined" && DidCommHandshakeProtocol) === "function" ? _ref : Object)], DidCommConnectionRecord.prototype, "protocol", void 0);

//#endregion
export { DidCommConnectionRecord };
//# sourceMappingURL=DidCommConnectionRecord.mjs.map