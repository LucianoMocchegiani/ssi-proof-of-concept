import { DidCommDidExchangeRole } from "../models/DidCommDidExchangeRole.mjs";
import { DidCommHandshakeProtocol } from "../models/DidCommHandshakeProtocol.mjs";
import "../models/index.mjs";
import { ReturnRouteTypes } from "../../../decorators/transport/TransportDecorator.mjs";
import { DidCommOutboundMessageContext } from "../../../models/DidCommOutboundMessageContext.mjs";
import "../../../models/index.mjs";
import { DidCommOutOfBandState } from "../../oob/domain/DidCommOutOfBandState.mjs";
import { DidCommDidExchangeResponseMessage } from "../messages/DidCommDidExchangeResponseMessage.mjs";
import "../messages/index.mjs";
import { CredoError } from "@credo-ts/core";

//#region src/modules/connections/handlers/DidCommDidExchangeResponseHandler.ts
var DidCommDidExchangeResponseHandler = class {
	constructor(didExchangeProtocol, outOfBandService, connectionService, didResolverService, connectionsModuleConfig) {
		this.supportedMessages = [DidCommDidExchangeResponseMessage];
		this.didExchangeProtocol = didExchangeProtocol;
		this.outOfBandService = outOfBandService;
		this.connectionService = connectionService;
		this.didResolverService = didResolverService;
		this.connectionsModuleConfig = connectionsModuleConfig;
	}
	async handle(messageContext) {
		const { agentContext, recipientKey, senderKey, message } = messageContext;
		if (!recipientKey || !senderKey) throw new CredoError("Unable to process connection response without sender key or recipient key");
		const connectionRecord = await this.connectionService.getByRoleAndThreadId(agentContext, DidCommDidExchangeRole.Requester, message.threadId);
		if (!connectionRecord) throw new CredoError(`Connection for thread ID ${message.threadId} not found!`);
		if (!connectionRecord.did) throw new CredoError(`Connection record ${connectionRecord.id} has no 'did'`);
		const ourDidDocument = await this.didResolverService.resolveDidDocument(agentContext, connectionRecord.did);
		if (!ourDidDocument) throw new CredoError(`Did document for did ${connectionRecord.did} was not resolved`);
		if (!ourDidDocument.recipientKeys.find((key) => key.fingerprint === recipientKey.fingerprint)) throw new CredoError(`Recipient key ${recipientKey.fingerprint} not found in did document recipient keys.`);
		const { protocol } = connectionRecord;
		if (protocol !== DidCommHandshakeProtocol.DidExchange) throw new CredoError(`Connection record protocol is ${protocol} but handler supports only ${DidCommHandshakeProtocol.DidExchange}.`);
		if (!connectionRecord.outOfBandId) throw new CredoError(`Connection ${connectionRecord.id} does not have outOfBandId!`);
		const outOfBandRecord = await this.outOfBandService.findById(agentContext, connectionRecord.outOfBandId);
		if (!outOfBandRecord) throw new CredoError(`OutOfBand record for connection ${connectionRecord.id} with outOfBandId ${connectionRecord.outOfBandId} not found!`);
		messageContext.connection = connectionRecord;
		const connection = await this.didExchangeProtocol.processResponse(messageContext, outOfBandRecord);
		if (!outOfBandRecord.reusable) await this.outOfBandService.updateState(agentContext, outOfBandRecord, DidCommOutOfBandState.Done);
		if (connection.autoAcceptConnection ?? this.connectionsModuleConfig.autoAcceptConnections) {
			const message = await this.didExchangeProtocol.createComplete(agentContext, connection, outOfBandRecord);
			message.setReturnRouting(ReturnRouteTypes.none);
			return new DidCommOutboundMessageContext(message, {
				agentContext,
				connection
			});
		}
	}
};

//#endregion
export { DidCommDidExchangeResponseHandler };
//# sourceMappingURL=DidCommDidExchangeResponseHandler.mjs.map