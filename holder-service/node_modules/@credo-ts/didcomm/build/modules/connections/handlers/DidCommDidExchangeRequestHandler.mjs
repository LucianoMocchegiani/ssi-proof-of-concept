import { DidCommHandshakeProtocol } from "../models/DidCommHandshakeProtocol.mjs";
import "../models/index.mjs";
import { DidCommTransportService } from "../../../DidCommTransportService.mjs";
import { DidCommOutboundMessageContext } from "../../../models/DidCommOutboundMessageContext.mjs";
import "../../../models/index.mjs";
import { DidCommOutOfBandState } from "../../oob/domain/DidCommOutOfBandState.mjs";
import { DidCommDidExchangeRequestMessage } from "../messages/DidCommDidExchangeRequestMessage.mjs";
import "../messages/index.mjs";
import { CredoError, tryParseDid } from "@credo-ts/core";

//#region src/modules/connections/handlers/DidCommDidExchangeRequestHandler.ts
var DidCommDidExchangeRequestHandler = class {
	constructor(didExchangeProtocol, outOfBandService, routingService, didRepository, connectionsModuleConfig) {
		this.supportedMessages = [DidCommDidExchangeRequestMessage];
		this.didExchangeProtocol = didExchangeProtocol;
		this.outOfBandService = outOfBandService;
		this.routingService = routingService;
		this.didRepository = didRepository;
		this.connectionsModuleConfig = connectionsModuleConfig;
	}
	async handle(messageContext) {
		const { agentContext, recipientKey, senderKey, message, connection, sessionId } = messageContext;
		if (!recipientKey || !senderKey) throw new CredoError("Unable to process connection request without senderKey or recipientKey");
		const parentThreadId = message.thread?.parentThreadId;
		if (!parentThreadId) throw new CredoError(`Message does not contain 'pthid' attribute`);
		const outOfBandRecord = tryParseDid(parentThreadId) ? await this.outOfBandService.createFromImplicitInvitation(agentContext, {
			did: parentThreadId,
			threadId: message.threadId,
			recipientKey,
			handshakeProtocols: [DidCommHandshakeProtocol.DidExchange]
		}) : await this.outOfBandService.findByCreatedInvitationId(agentContext, parentThreadId);
		if (!outOfBandRecord) throw new CredoError(`OutOfBand record for message ID ${parentThreadId} not found!`);
		if (connection && !outOfBandRecord.reusable) throw new CredoError(`Connection record for non-reusable out-of-band ${outOfBandRecord.id} already exists.`);
		if (await this.didRepository.findReceivedDidByRecipientKey(agentContext, senderKey)) throw new CredoError(`A received did record for sender key ${senderKey.fingerprint} already exists.`);
		if (outOfBandRecord.state === DidCommOutOfBandState.Done) throw new CredoError("Out-of-band record has been already processed and it does not accept any new requests");
		const connectionRecord = await this.didExchangeProtocol.processRequest(messageContext, outOfBandRecord);
		if (sessionId) agentContext.dependencyManager.resolve(DidCommTransportService).setConnectionIdForSession(sessionId, connectionRecord.id);
		if (!outOfBandRecord.reusable) await this.outOfBandService.updateState(agentContext, outOfBandRecord, DidCommOutOfBandState.Done);
		if (connectionRecord.autoAcceptConnection ?? this.connectionsModuleConfig.autoAcceptConnections) {
			const routing = outOfBandRecord.reusable || outOfBandRecord.outOfBandInvitation.getInlineServices().length === 0 ? await this.routingService.getRouting(agentContext) : void 0;
			return new DidCommOutboundMessageContext(await this.didExchangeProtocol.createResponse(agentContext, connectionRecord, outOfBandRecord, routing), {
				agentContext,
				connection: connectionRecord,
				outOfBand: outOfBandRecord
			});
		}
	}
};

//#endregion
export { DidCommDidExchangeRequestHandler };
//# sourceMappingURL=DidCommDidExchangeRequestHandler.mjs.map