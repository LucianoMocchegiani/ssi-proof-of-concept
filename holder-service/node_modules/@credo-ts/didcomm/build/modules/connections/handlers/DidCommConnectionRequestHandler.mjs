import { DidCommHandshakeProtocol } from "../models/DidCommHandshakeProtocol.mjs";
import "../models/index.mjs";
import { DidCommTransportService } from "../../../DidCommTransportService.mjs";
import { DidCommOutboundMessageContext } from "../../../models/DidCommOutboundMessageContext.mjs";
import "../../../models/index.mjs";
import { DidCommOutOfBandState } from "../../oob/domain/DidCommOutOfBandState.mjs";
import { DidCommConnectionRequestMessage } from "../messages/DidCommConnectionRequestMessage.mjs";
import "../messages/index.mjs";
import { CredoError, tryParseDid } from "@credo-ts/core";

//#region src/modules/connections/handlers/DidCommConnectionRequestHandler.ts
var DidCommConnectionRequestHandler = class {
	constructor(connectionService, outOfBandService, routingService, didRepository, connectionsModuleConfig) {
		this.supportedMessages = [DidCommConnectionRequestMessage];
		this.connectionService = connectionService;
		this.outOfBandService = outOfBandService;
		this.routingService = routingService;
		this.didRepository = didRepository;
		this.connectionsModuleConfig = connectionsModuleConfig;
	}
	async handle(messageContext) {
		const { agentContext, connection, recipientKey, senderKey, message, sessionId } = messageContext;
		if (!recipientKey || !senderKey) throw new CredoError("Unable to process connection request without senderVerkey or recipientKey");
		const parentThreadId = message.thread?.parentThreadId;
		const outOfBandRecord = parentThreadId && tryParseDid(parentThreadId) ? await this.outOfBandService.createFromImplicitInvitation(agentContext, {
			did: parentThreadId,
			threadId: message.threadId,
			recipientKey,
			handshakeProtocols: [DidCommHandshakeProtocol.Connections]
		}) : await this.outOfBandService.findCreatedByRecipientKey(agentContext, recipientKey);
		if (!outOfBandRecord) throw new CredoError(`Out-of-band record for recipient key ${recipientKey.fingerprint} was not found.`);
		if (connection && !outOfBandRecord.reusable) throw new CredoError(`Connection record for non-reusable out-of-band ${outOfBandRecord.id} already exists.`);
		if (await this.didRepository.findReceivedDidByRecipientKey(agentContext, senderKey)) throw new CredoError(`A received did record for sender key ${senderKey.fingerprint} already exists.`);
		if (outOfBandRecord.state === DidCommOutOfBandState.Done) throw new CredoError("Out-of-band record has been already processed and it does not accept any new requests");
		const connectionRecord = await this.connectionService.processRequest(messageContext, outOfBandRecord);
		if (sessionId) agentContext.dependencyManager.resolve(DidCommTransportService).setConnectionIdForSession(sessionId, connectionRecord.id);
		if (!outOfBandRecord.reusable) await this.outOfBandService.updateState(agentContext, outOfBandRecord, DidCommOutOfBandState.Done);
		if (connectionRecord?.autoAcceptConnection ?? this.connectionsModuleConfig.autoAcceptConnections) {
			const routing = outOfBandRecord.reusable || outOfBandRecord.outOfBandInvitation.getInlineServices().length === 0 ? await this.routingService.getRouting(agentContext) : void 0;
			const { message } = await this.connectionService.createResponse(agentContext, connectionRecord, outOfBandRecord, routing);
			return new DidCommOutboundMessageContext(message, {
				agentContext,
				connection: connectionRecord,
				outOfBand: outOfBandRecord
			});
		}
	}
};

//#endregion
export { DidCommConnectionRequestHandler };
//# sourceMappingURL=DidCommConnectionRequestHandler.mjs.map