import { DidCommDidExchangeRole } from "../models/DidCommDidExchangeRole.mjs";
import "../models/index.mjs";
import { ReturnRouteTypes } from "../../../decorators/transport/TransportDecorator.mjs";
import { DidCommOutboundMessageContext } from "../../../models/DidCommOutboundMessageContext.mjs";
import "../../../models/index.mjs";
import { DidCommOutOfBandState } from "../../oob/domain/DidCommOutOfBandState.mjs";
import { DidCommConnectionResponseMessage } from "../messages/DidCommConnectionResponseMessage.mjs";
import "../messages/index.mjs";
import { CredoError } from "@credo-ts/core";

//#region src/modules/connections/handlers/DidCommConnectionResponseHandler.ts
var DidCommConnectionResponseHandler = class {
	constructor(connectionService, outOfBandService, didResolverService, connectionsModuleConfig) {
		this.supportedMessages = [DidCommConnectionResponseMessage];
		this.connectionService = connectionService;
		this.outOfBandService = outOfBandService;
		this.didResolverService = didResolverService;
		this.connectionsModuleConfig = connectionsModuleConfig;
	}
	async handle(messageContext) {
		const { recipientKey, senderKey, message } = messageContext;
		if (!recipientKey || !senderKey) throw new CredoError("Unable to process connection response without senderKey or recipientKey");
		const connectionRecord = await this.connectionService.getByRoleAndThreadId(messageContext.agentContext, DidCommDidExchangeRole.Requester, message.threadId);
		if (!connectionRecord) throw new CredoError(`Connection for thread ID ${message.threadId} not found!`);
		if (!connectionRecord.did) throw new CredoError(`Connection record ${connectionRecord.id} has no 'did'`);
		const ourDidDocument = await this.didResolverService.resolveDidDocument(messageContext.agentContext, connectionRecord.did);
		if (!ourDidDocument) throw new CredoError(`Did document for did ${connectionRecord.did} was not resolved!`);
		if (!ourDidDocument.recipientKeys.find((key) => key.fingerprint === recipientKey.fingerprint)) throw new CredoError(`Recipient key ${recipientKey.fingerprint} not found in did document recipient keys.`);
		const outOfBandRecord = connectionRecord.outOfBandId && await this.outOfBandService.findById(messageContext.agentContext, connectionRecord.outOfBandId);
		if (!outOfBandRecord) throw new CredoError(`Out-of-band record ${connectionRecord.outOfBandId} was not found.`);
		messageContext.connection = connectionRecord;
		const connection = await this.connectionService.processResponse(messageContext, outOfBandRecord);
		if (!outOfBandRecord.reusable) await this.outOfBandService.updateState(messageContext.agentContext, outOfBandRecord, DidCommOutOfBandState.Done);
		if (connection.autoAcceptConnection ?? this.connectionsModuleConfig.autoAcceptConnections) {
			const { message } = await this.connectionService.createTrustPing(messageContext.agentContext, connection, { responseRequested: false });
			message.setReturnRouting(ReturnRouteTypes.none);
			return new DidCommOutboundMessageContext(message, {
				agentContext: messageContext.agentContext,
				connection
			});
		}
	}
};

//#endregion
export { DidCommConnectionResponseHandler };
//# sourceMappingURL=DidCommConnectionResponseHandler.mjs.map