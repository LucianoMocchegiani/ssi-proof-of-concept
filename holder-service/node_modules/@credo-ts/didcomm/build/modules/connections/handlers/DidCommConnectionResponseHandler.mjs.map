{"version":3,"file":"DidCommConnectionResponseHandler.mjs","names":[],"sources":["../../../../src/modules/connections/handlers/DidCommConnectionResponseHandler.ts"],"sourcesContent":["import type { DidResolverService } from '@credo-ts/core'\nimport { CredoError } from '@credo-ts/core'\nimport { ReturnRouteTypes } from '../../../decorators/transport/TransportDecorator'\nimport type { DidCommMessageHandler, DidCommMessageHandlerInboundMessage } from '../../../handlers'\nimport { DidCommOutboundMessageContext } from '../../../models'\nimport type { DidCommOutOfBandService } from '../../oob/DidCommOutOfBandService'\nimport { DidCommOutOfBandState } from '../../oob/domain/DidCommOutOfBandState'\nimport type { DidCommConnectionsModuleConfig } from '../DidCommConnectionsModuleConfig'\nimport { DidCommConnectionResponseMessage } from '../messages'\nimport { DidCommDidExchangeRole } from '../models'\nimport type { DidCommConnectionService } from '../services'\n\nexport class DidCommConnectionResponseHandler implements DidCommMessageHandler {\n  private connectionService: DidCommConnectionService\n  private outOfBandService: DidCommOutOfBandService\n  private didResolverService: DidResolverService\n  private connectionsModuleConfig: DidCommConnectionsModuleConfig\n\n  public supportedMessages = [DidCommConnectionResponseMessage]\n\n  public constructor(\n    connectionService: DidCommConnectionService,\n    outOfBandService: DidCommOutOfBandService,\n    didResolverService: DidResolverService,\n    connectionsModuleConfig: DidCommConnectionsModuleConfig\n  ) {\n    this.connectionService = connectionService\n    this.outOfBandService = outOfBandService\n    this.didResolverService = didResolverService\n    this.connectionsModuleConfig = connectionsModuleConfig\n  }\n\n  public async handle(messageContext: DidCommMessageHandlerInboundMessage<DidCommConnectionResponseHandler>) {\n    const { recipientKey, senderKey, message } = messageContext\n\n    if (!recipientKey || !senderKey) {\n      throw new CredoError('Unable to process connection response without senderKey or recipientKey')\n    }\n\n    // Query by both role and thread id to allow connecting to self\n    const connectionRecord = await this.connectionService.getByRoleAndThreadId(\n      messageContext.agentContext,\n      DidCommDidExchangeRole.Requester,\n      message.threadId\n    )\n    if (!connectionRecord) {\n      throw new CredoError(`Connection for thread ID ${message.threadId} not found!`)\n    }\n\n    if (!connectionRecord.did) {\n      throw new CredoError(`Connection record ${connectionRecord.id} has no 'did'`)\n    }\n\n    const ourDidDocument = await this.didResolverService.resolveDidDocument(\n      messageContext.agentContext,\n      connectionRecord.did\n    )\n    if (!ourDidDocument) {\n      throw new CredoError(`Did document for did ${connectionRecord.did} was not resolved!`)\n    }\n\n    // Validate if recipient key is included in recipient keys of the did document resolved by\n    // connection record did\n    if (!ourDidDocument.recipientKeys.find((key) => key.fingerprint === recipientKey.fingerprint)) {\n      throw new CredoError(`Recipient key ${recipientKey.fingerprint} not found in did document recipient keys.`)\n    }\n\n    const outOfBandRecord =\n      connectionRecord.outOfBandId &&\n      (await this.outOfBandService.findById(messageContext.agentContext, connectionRecord.outOfBandId))\n\n    if (!outOfBandRecord) {\n      throw new CredoError(`Out-of-band record ${connectionRecord.outOfBandId} was not found.`)\n    }\n\n    messageContext.connection = connectionRecord\n    const connection = await this.connectionService.processResponse(messageContext, outOfBandRecord)\n\n    if (!outOfBandRecord.reusable) {\n      await this.outOfBandService.updateState(messageContext.agentContext, outOfBandRecord, DidCommOutOfBandState.Done)\n    }\n\n    // TODO: should we only send ping message in case of autoAcceptConnection or always?\n    // In AATH we have a separate step to send the ping. So for now we'll only do it\n    // if auto accept is enable\n    if (connection.autoAcceptConnection ?? this.connectionsModuleConfig.autoAcceptConnections) {\n      const { message } = await this.connectionService.createTrustPing(messageContext.agentContext, connection, {\n        responseRequested: false,\n      })\n\n      // Disable return routing as we don't want to receive a response for this message over the same channel\n      // This has led to long timeouts as not all clients actually close an http socket if there is no response message\n      message.setReturnRouting(ReturnRouteTypes.none)\n\n      return new DidCommOutboundMessageContext(message, { agentContext: messageContext.agentContext, connection })\n    }\n  }\n}\n"],"mappings":";;;;;;;;;;;AAYA,IAAa,mCAAb,MAA+E;CAQ7E,AAAO,YACL,mBACA,kBACA,oBACA,yBACA;OAPK,oBAAoB,CAAC,iCAAiC;AAQ3D,OAAK,oBAAoB;AACzB,OAAK,mBAAmB;AACxB,OAAK,qBAAqB;AAC1B,OAAK,0BAA0B;;CAGjC,MAAa,OAAO,gBAAuF;EACzG,MAAM,EAAE,cAAc,WAAW,YAAY;AAE7C,MAAI,CAAC,gBAAgB,CAAC,UACpB,OAAM,IAAI,WAAW,0EAA0E;EAIjG,MAAM,mBAAmB,MAAM,KAAK,kBAAkB,qBACpD,eAAe,cACf,uBAAuB,WACvB,QAAQ,SACT;AACD,MAAI,CAAC,iBACH,OAAM,IAAI,WAAW,4BAA4B,QAAQ,SAAS,aAAa;AAGjF,MAAI,CAAC,iBAAiB,IACpB,OAAM,IAAI,WAAW,qBAAqB,iBAAiB,GAAG,eAAe;EAG/E,MAAM,iBAAiB,MAAM,KAAK,mBAAmB,mBACnD,eAAe,cACf,iBAAiB,IAClB;AACD,MAAI,CAAC,eACH,OAAM,IAAI,WAAW,wBAAwB,iBAAiB,IAAI,oBAAoB;AAKxF,MAAI,CAAC,eAAe,cAAc,MAAM,QAAQ,IAAI,gBAAgB,aAAa,YAAY,CAC3F,OAAM,IAAI,WAAW,iBAAiB,aAAa,YAAY,4CAA4C;EAG7G,MAAM,kBACJ,iBAAiB,eAChB,MAAM,KAAK,iBAAiB,SAAS,eAAe,cAAc,iBAAiB,YAAY;AAElG,MAAI,CAAC,gBACH,OAAM,IAAI,WAAW,sBAAsB,iBAAiB,YAAY,iBAAiB;AAG3F,iBAAe,aAAa;EAC5B,MAAM,aAAa,MAAM,KAAK,kBAAkB,gBAAgB,gBAAgB,gBAAgB;AAEhG,MAAI,CAAC,gBAAgB,SACnB,OAAM,KAAK,iBAAiB,YAAY,eAAe,cAAc,iBAAiB,sBAAsB,KAAK;AAMnH,MAAI,WAAW,wBAAwB,KAAK,wBAAwB,uBAAuB;GACzF,MAAM,EAAE,YAAY,MAAM,KAAK,kBAAkB,gBAAgB,eAAe,cAAc,YAAY,EACxG,mBAAmB,OACpB,CAAC;AAIF,WAAQ,iBAAiB,iBAAiB,KAAK;AAE/C,UAAO,IAAI,8BAA8B,SAAS;IAAE,cAAc,eAAe;IAAc;IAAY,CAAC"}