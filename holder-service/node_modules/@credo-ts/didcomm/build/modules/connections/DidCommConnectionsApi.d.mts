import { DidCommConnectionType } from "./models/DidCommConnectionType.mjs";
import { DidCommHandshakeProtocol } from "./models/DidCommHandshakeProtocol.mjs";
import "./models/index.mjs";
import { DidCommTrustPingMessage } from "./messages/DidCommTrustPingMessage.mjs";
import "./messages/index.mjs";
import { DidCommOutOfBandRecord } from "../oob/repository/DidCommOutOfBandRecord.mjs";
import "../oob/repository/index.mjs";
import { DidCommConnectionService } from "./services/DidCommConnectionService.mjs";
import { DidCommDidRotateService } from "./services/DidCommDidRotateService.mjs";
import "./services/index.mjs";
import { DidCommRoutingService } from "../routing/services/DidCommRoutingService.mjs";
import { DidCommOutOfBandService } from "../oob/DidCommOutOfBandService.mjs";
import { DidCommMessageSender } from "../../DidCommMessageSender.mjs";
import { DidCommConnectionsModuleConfig } from "./DidCommConnectionsModuleConfig.mjs";
import { DidExchangeProtocol } from "./DidExchangeProtocol.mjs";
import { DidCommConnectionRecord } from "./repository/DidCommConnectionRecord.mjs";
import "./repository/index.mjs";
import { DidCommRouting } from "../../models/DidCommRouting.mjs";
import "../../models/index.mjs";
import { AgentContext, DidResolverService, Query, QueryOptions } from "@credo-ts/core";

//#region src/modules/connections/DidCommConnectionsApi.d.ts
interface SendPingOptions {
  responseRequested?: boolean;
  withReturnRouting?: boolean;
}
declare class DidCommConnectionsApi {
  /**
   * Configuration for the connections module
   */
  readonly config: DidCommConnectionsModuleConfig;
  private didExchangeProtocol;
  private connectionService;
  private didRotateService;
  private outOfBandService;
  private messageSender;
  private routingService;
  private didResolverService;
  private agentContext;
  constructor(didExchangeProtocol: DidExchangeProtocol, connectionService: DidCommConnectionService, didRotateService: DidCommDidRotateService, outOfBandService: DidCommOutOfBandService, routingService: DidCommRoutingService, didResolverService: DidResolverService, messageSender: DidCommMessageSender, agentContext: AgentContext, connectionsModuleConfig: DidCommConnectionsModuleConfig);
  acceptOutOfBandInvitation(outOfBandRecord: DidCommOutOfBandRecord, config: {
    autoAcceptConnection?: boolean;
    label: string;
    alias?: string;
    imageUrl?: string;
    protocol: DidCommHandshakeProtocol;
    routing?: DidCommRouting;
    ourDid?: string;
  }): Promise<DidCommConnectionRecord>;
  /**
   * Accept a connection request as inviter (by sending a connection response message) for the connection with the specified connection id.
   * This is not needed when auto accepting of connection is enabled.
   *
   * @param connectionId the id of the connection for which to accept the request
   * @returns connection record
   */
  acceptRequest(connectionId: string): Promise<DidCommConnectionRecord>;
  /**
   * Accept a connection response as invitee (by sending a trust ping message) for the connection with the specified connection id.
   * This is not needed when auto accepting of connection is enabled.
   *
   * @param connectionId the id of the connection for which to accept the response
   * @returns connection record
   */
  acceptResponse(connectionId: string): Promise<DidCommConnectionRecord>;
  /**
   * Send a trust ping to an established connection
   *
   * @param connectionId the id of the connection for which to accept the response
   * @param responseRequested do we want a response to our ping
   * @param withReturnRouting do we want a response at the time of posting
   * @returns TrustPingMessage
   */
  sendPing(connectionId: string, {
    responseRequested,
    withReturnRouting
  }?: SendPingOptions): Promise<DidCommTrustPingMessage>;
  /**
   * Rotate the DID used for a given connection, notifying the other party immediately.
   *
   *  If `toDid` is not specified, a new peer did will be created. Optionally, routing
   * configuration can be set.
   *
   * Note: any did created or imported in agent wallet can be used as `toDid`, as long as
   * there are valid DIDComm services in its DID Document.
   *
   * @param options connectionId and optional target did and routing configuration
   * @returns object containing the new did
   */
  rotate(options: {
    connectionId: string;
    toDid?: string;
    routing?: DidCommRouting;
  }): Promise<{
    newDid: string;
  }>;
  /**
   * Terminate a connection by sending a hang-up message to the other party. The connection record itself and any
   * keys used for mediation will only be deleted if `deleteAfterHangup` flag is set.
   *
   * @param options connectionId
   */
  hangup(options: {
    connectionId: string;
    deleteAfterHangup?: boolean;
  }): Promise<void>;
  returnWhenIsConnected(connectionId: string, options?: {
    timeoutMs: number;
  }): Promise<DidCommConnectionRecord>;
  /**
   * Retrieve all connections records
   *
   * @returns List containing all connection records
   */
  getAll(): Promise<DidCommConnectionRecord[]>;
  /**
   * Retrieve all connections records by specified query params
   *
   * @returns List containing all connection records matching specified query paramaters
   */
  findAllByQuery(query: Query<DidCommConnectionRecord>, queryOptions?: QueryOptions): Promise<DidCommConnectionRecord[]>;
  /**
   * Allows for the addition of connectionType to the record.
   *  Either updates or creates an array of string connection types
   * @param connectionId
   * @param type
   * @throws {RecordNotFoundError} If no record is found
   */
  addConnectionType(connectionId: string, type: DidCommConnectionType | string): Promise<DidCommConnectionRecord>;
  /**
   * Removes the given tag from the given record found by connectionId, if the tag exists otherwise does nothing
   * @param connectionId
   * @param type
   * @throws {RecordNotFoundError} If no record is found
   */
  removeConnectionType(connectionId: string, type: DidCommConnectionType | string): Promise<DidCommConnectionRecord>;
  /**
   * Gets the known connection types for the record matching the given connectionId
   * @param connectionId
   * @returns An array of known connection types or null if none exist
   * @throws {RecordNotFoundError} If no record is found
   */
  getConnectionTypes(connectionId: string): Promise<string[]>;
  /**
   *
   * @param connectionTypes An array of connection types to query for a match for
   * @returns a promise of ab array of connection records
   */
  findAllByConnectionTypes(connectionTypes: Array<DidCommConnectionType | string>): Promise<DidCommConnectionRecord[]>;
  /**
   * Retrieve a connection record by id
   *
   * @param connectionId The connection record id
   * @throws {RecordNotFoundError} If no record is found
   * @return The connection record
   *
   */
  getById(connectionId: string): Promise<DidCommConnectionRecord>;
  /**
   * Find a connection record by id
   *
   * @param connectionId the connection record id
   * @returns The connection record or null if not found
   */
  findById(connectionId: string): Promise<DidCommConnectionRecord | null>;
  /**
   * Delete a connection record by id
   *
   * @param connectionId the connection record id
   */
  deleteById(connectionId: string): Promise<void>;
  private removeRouting;
  /**
   * Remove relationship of a connection with any previous did (either ours or theirs), preventing it from accepting
   * messages from them. This is usually called when a DID Rotation flow has been succesful and we are sure that no
   * more messages with older keys will arrive.
   *
   * It will remove routing keys from mediator if applicable.
   *
   * Note: this will not actually delete any DID from the wallet.
   *
   * @param connectionId
   */
  removePreviousDids(options: {
    connectionId: string;
  }): Promise<void>;
  findAllByOutOfBandId(outOfBandId: string): Promise<DidCommConnectionRecord[]>;
  /**
   * Retrieve a connection record by thread id
   *
   * @param threadId The thread id
   * @throws {RecordNotFoundError} If no record is found
   * @throws {RecordDuplicateError} If multiple records are found
   * @returns The connection record
   */
  getByThreadId(threadId: string): Promise<DidCommConnectionRecord>;
  findByDid(did: string): Promise<DidCommConnectionRecord | null>;
  findByInvitationDid(invitationDid: string): Promise<DidCommConnectionRecord[]>;
}
//#endregion
export { DidCommConnectionsApi, SendPingOptions };
//# sourceMappingURL=DidCommConnectionsApi.d.mts.map