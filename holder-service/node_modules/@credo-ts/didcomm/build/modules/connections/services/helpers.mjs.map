{"version":3,"file":"helpers.mjs","names":[],"sources":["../../../../src/modules/connections/services/helpers.ts"],"sourcesContent":["import {\n  AgentContext,\n  CredoError,\n  createPeerDidDocumentFromServices,\n  DidCommV1Service,\n  DidDocumentBuilder,\n  type DidDocumentKey,\n  DidDocumentRole,\n  DidRepository,\n  DidsApi,\n  didDocumentJsonToNumAlgo1Did,\n  getEd25519VerificationKey2018,\n  IndyAgentService,\n  Kms,\n  PeerDidNumAlgo,\n  type ResolvedDidCommService,\n  TypedArrayEncoder,\n} from '@credo-ts/core'\nimport type { DidCommRouting } from '../../../models'\nimport { OutOfBandDidCommService } from '../../oob/domain/OutOfBandDidCommService'\nimport type { DidCommOutOfBandInlineServiceKey } from '../../oob/repository/DidCommOutOfBandRecord'\nimport type { DidDoc, PublicKey } from '../models'\nimport { EmbeddedAuthentication } from '../models'\n\nexport function convertToNewDidDocument(didDoc: DidDoc, keys?: DidDocumentKey[]) {\n  const didDocumentBuilder = new DidDocumentBuilder('')\n\n  const oldIdNewIdMapping: { [key: string]: string } = {}\n\n  for (const auth of didDoc.authentication) {\n    const { publicKey: pk } = auth\n\n    // did:peer did documents can only use referenced keys.\n    if (pk.type === 'Ed25519VerificationKey2018' && pk.value) {\n      const ed25519VerificationMethod = convertPublicKeyToVerificationMethod(pk)\n\n      const oldKeyId = normalizeId(pk.id)\n      oldIdNewIdMapping[oldKeyId] = ed25519VerificationMethod.id\n      didDocumentBuilder.addAuthentication(ed25519VerificationMethod.id)\n\n      // Only the auth is embedded, we also need to add the key to the verificationMethod\n      // for referenced authentication this should already be the case\n      if (auth instanceof EmbeddedAuthentication) {\n        didDocumentBuilder.addVerificationMethod(ed25519VerificationMethod)\n      }\n    }\n  }\n\n  for (const pk of didDoc.publicKey) {\n    if (pk.type === 'Ed25519VerificationKey2018' && pk.value) {\n      const ed25519VerificationMethod = convertPublicKeyToVerificationMethod(pk)\n\n      const oldKeyId = normalizeId(pk.id)\n      oldIdNewIdMapping[oldKeyId] = ed25519VerificationMethod.id\n      didDocumentBuilder.addVerificationMethod(ed25519VerificationMethod)\n    }\n  }\n\n  // FIXME: we reverse the didCommServices here, as the previous implementation was wrong\n  // and we need to keep the same order to not break the did creation process.\n  // When we implement the migration to did:peer:2 and did:peer:3 according to the\n  // RFCs we can change it.\n\n  for (let service of didDoc.didCommServices.reverse()) {\n    const serviceId = normalizeId(service.id)\n\n    // For didcommv1, we need to replace the old id with the new ones\n    if (service instanceof DidCommV1Service) {\n      const recipientKeys = service.recipientKeys.map((keyId) => {\n        const oldKeyId = normalizeId(keyId)\n        return oldIdNewIdMapping[oldKeyId]\n      })\n\n      service = new DidCommV1Service({\n        id: serviceId,\n        recipientKeys,\n        serviceEndpoint: service.serviceEndpoint,\n        routingKeys: service.routingKeys,\n        accept: service.accept,\n        priority: service.priority,\n      })\n    } else if (service instanceof IndyAgentService) {\n      service = new IndyAgentService({\n        id: serviceId,\n        recipientKeys: service.recipientKeys,\n        serviceEndpoint: service.serviceEndpoint,\n        routingKeys: service.routingKeys,\n        priority: service.priority,\n      })\n    }\n\n    didDocumentBuilder.addService(service)\n  }\n\n  const didDocument = didDocumentBuilder.build()\n\n  const peerDid = didDocumentJsonToNumAlgo1Did(didDocument.toJSON())\n  didDocument.id = peerDid\n\n  return {\n    didDocument,\n    keys: keys?.map((key) => ({\n      ...key,\n      didDocumentRelativeKeyId: oldIdNewIdMapping[key.didDocumentRelativeKeyId],\n    })),\n  }\n}\n\nfunction normalizeId(fullId: string): `#${string}` {\n  // Some old dids use `;` as the delimiter for the id. If we can't find a `#`\n  // and a `;` exists, we will parse everything after `;` as the id.\n  if (!fullId.includes('#') && fullId.includes(';')) {\n    const [, ...ids] = fullId.split(';')\n\n    return `#${ids.join(';')}`\n  }\n\n  const [, ...ids] = fullId.split('#')\n  return `#${ids.length ? ids.join('#') : fullId}`\n}\n\nfunction convertPublicKeyToVerificationMethod(publicKey: PublicKey) {\n  if (!publicKey.value) {\n    throw new CredoError(`Public key ${publicKey.id} does not have value property`)\n  }\n  const publicKeyBase58 = publicKey.value\n  const ed25519Key = Kms.PublicJwk.fromPublicKey({\n    kty: 'OKP',\n    crv: 'Ed25519',\n    publicKey: TypedArrayEncoder.fromBase58(publicKeyBase58),\n  })\n  return getEd25519VerificationKey2018({\n    id: `#${publicKeyBase58.slice(0, 8)}`,\n    publicJwk: ed25519Key,\n    controller: '#id',\n  })\n}\n\nexport function routingToServices(routing: DidCommRouting): ResolvedDidCommService[] {\n  return routing.endpoints.map((endpoint, index) => ({\n    id: `#inline-${index}`,\n    serviceEndpoint: endpoint,\n    recipientKeys: [routing.recipientKey],\n    routingKeys: routing.routingKeys,\n  }))\n}\n\n/**\n * Asserts that the keys we are going to use for creating a did document haven't already been used in another did document\n * Due to how DIDComm v1 works (only reference the key not the did in encrypted message) we can't have multiple dids containing\n * the same key as we won't know which did (and thus which connection) a message is intended for.\n */\nexport async function assertNoCreatedDidExistsForKeys(agentContext: AgentContext, recipientKeys: Kms.PublicJwk[]) {\n  const didRepository = agentContext.dependencyManager.resolve(DidRepository)\n  const recipientKeyFingerprints = recipientKeys.map((key) => key.fingerprint)\n\n  const didsForServices = await didRepository.findByQuery(agentContext, {\n    role: DidDocumentRole.Created,\n\n    // We want an $or query so we query for each key individually, not one did document\n    // containing exactly the same keys as the did document we are trying to create\n    $or: recipientKeyFingerprints.map((fingerprint) => ({\n      recipientKeyFingerprints: [fingerprint],\n    })),\n  })\n\n  if (didsForServices.length > 0) {\n    const allDidRecipientKeys = didsForServices.flatMap((did) => did.getTags().recipientKeyFingerprints ?? [])\n    const matchingFingerprints = allDidRecipientKeys.filter((f) => recipientKeyFingerprints.includes(f))\n    throw new CredoError(\n      `A did already exists for some of the keys in the provided services. DIDComm v1 uses key based routing, and therefore it is not allowed to re-use the same key in multiple did documents for DIDComm. If you use the same 'routing' object for multiple invitations, instead provide an 'invitationDid' to the create invitation method. The following fingerprints are already in use: ${matchingFingerprints.join(\n        ','\n      )}`\n    )\n  }\n}\n\nexport async function createPeerDidFromServices(\n  agentContext: AgentContext,\n  services: ResolvedDidCommService[],\n  numAlgo: PeerDidNumAlgo\n) {\n  const didsApi = agentContext.dependencyManager.resolve(DidsApi)\n\n  // Create did document without the id property\n  const { didDocument, keys } = createPeerDidDocumentFromServices(services, true)\n\n  // Assert that the keys we are going to use for creating a did document haven't already been used in another did document\n  await assertNoCreatedDidExistsForKeys(agentContext, didDocument.recipientKeys)\n\n  // Register did:peer document. This will generate the id property and save it to a did record\n  const result = await didsApi.create({\n    method: 'peer',\n    didDocument,\n    options: {\n      numAlgo,\n      keys,\n    },\n  })\n\n  if (result.didState?.state !== 'finished') {\n    throw new CredoError(`Did document creation failed: ${JSON.stringify(result.didState)}`)\n  }\n\n  // FIXME: didApi.create should return the did document\n  return didsApi.resolveCreatedDidDocumentWithKeys(result.didState.did)\n}\n\nexport function getResolvedDidcommServiceWithSigningKeyId(\n  outOfBandDidcommService: OutOfBandDidCommService,\n  /**\n   * Optional keys for the inline services\n   */\n  inlineServiceKeys?: DidCommOutOfBandInlineServiceKey[]\n) {\n  const resolvedService = outOfBandDidcommService.resolvedDidCommService\n\n  // Make sure the key id is set for service keys\n  for (const recipientKey of resolvedService.recipientKeys) {\n    const kmsKeyId = inlineServiceKeys?.find(\n      ({ recipientKeyFingerprint }) => recipientKeyFingerprint === recipientKey.fingerprint\n    )?.kmsKeyId\n\n    recipientKey.keyId = kmsKeyId ?? recipientKey.legacyKeyId\n  }\n\n  return resolvedService\n}\n"],"mappings":"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"}