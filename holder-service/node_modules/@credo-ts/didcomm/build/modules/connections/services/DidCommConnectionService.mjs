import { __decorate } from "../../../_virtual/_@oxc-project_runtime@0.110.0/helpers/decorate.mjs";
import { __decorateMetadata } from "../../../_virtual/_@oxc-project_runtime@0.110.0/helpers/decorateMetadata.mjs";
import { Ed25119Sig2018 } from "../models/did/publicKey/Ed25119Sig2018.mjs";
import { ReferencedAuthentication } from "../models/did/authentication/ReferencedAuthentication.mjs";
import { authenticationTypes } from "../models/did/authentication/index.mjs";
import { DidDoc } from "../models/did/DidDoc.mjs";
import { DidCommConnection } from "../models/DidCommConnection.mjs";
import { DidCommDidExchangeState } from "../models/DidCommDidExchangeState.mjs";
import { DidCommDidExchangeRole } from "../models/DidCommDidExchangeRole.mjs";
import { DidCommHandshakeProtocol } from "../models/DidCommHandshakeProtocol.mjs";
import "../models/index.mjs";
import { assertNoCreatedDidExistsForKeys, convertToNewDidDocument, getResolvedDidcommServiceWithSigningKeyId } from "./helpers.mjs";
import { DidCommOutOfBandRole } from "../../oob/domain/DidCommOutOfBandRole.mjs";
import { DidCommInvitationType } from "../../oob/messages/DidCommOutOfBandInvitation.mjs";
import "../../oob/messages/index.mjs";
import { __decorateParam } from "../../../_virtual/_@oxc-project_runtime@0.110.0/helpers/decorateParam.mjs";
import { DidCommOutOfBandRepository } from "../../oob/repository/DidCommOutOfBandRepository.mjs";
import { DidCommOutOfBandRecordMetadataKeys } from "../../oob/repository/outOfBandRecordMetadataTypes.mjs";
import { signData, unpackAndVerifySignatureDecorator } from "../../../decorators/signature/SignatureDecoratorUtils.mjs";
import { DidCommOutOfBandState } from "../../oob/domain/DidCommOutOfBandState.mjs";
import "../../oob/repository/index.mjs";
import { DidCommOutOfBandService } from "../../oob/DidCommOutOfBandService.mjs";
import { DidCommConnectionEventTypes } from "../DidCommConnectionEvents.mjs";
import { DidCommConnectionRequestMessage } from "../messages/DidCommConnectionRequestMessage.mjs";
import { DidCommConnectionResponseMessage } from "../messages/DidCommConnectionResponseMessage.mjs";
import { DidCommTrustPingMessage } from "../messages/DidCommTrustPingMessage.mjs";
import "../messages/index.mjs";
import { ConnectionProblemReportError } from "../errors/ConnectionProblemReportError.mjs";
import { ConnectionProblemReportReason } from "../errors/ConnectionProblemReportReason.mjs";
import "../errors/index.mjs";
import { DidCommConnectionRecord } from "../repository/DidCommConnectionRecord.mjs";
import { DidCommConnectionRepository } from "../repository/DidCommConnectionRepository.mjs";
import "../repository/index.mjs";
import { CredoError, DidDocumentRole, DidRecord, DidRecordMetadataKeys, DidRepository, DidsApi, EventEmitter, IndyAgentService, InjectionSymbols, JsonTransformer, Kms, TypedArrayEncoder, didDocumentJsonToNumAlgo1Did, filterContextCorrelationId, inject, injectable, parseDid, utils } from "@credo-ts/core";
import { ReplaySubject, firstValueFrom } from "rxjs";
import { first as first$1, map as map$1, timeout as timeout$1 } from "rxjs/operators";

//#region src/modules/connections/services/DidCommConnectionService.ts
var _ref, _ref2, _ref3;
let DidCommConnectionService = class DidCommConnectionService {
	constructor(logger, connectionRepository, didRepository, eventEmitter) {
		this.hasLoggedWarning = false;
		this.connectionRepository = connectionRepository;
		this.didRepository = didRepository;
		this.eventEmitter = eventEmitter;
		this.logger = logger;
	}
	ensureWarningLoggedOnce() {
		if (this.hasLoggedWarning) return;
		this.logger.debug("The v1 connection protocol is deprecated and will be removed in version 0.7 of Credo. You should upgrade to the did exchange protocol instead.");
		this.hasLoggedWarning = true;
	}
	/**
	* Create a connection request message for a given out-of-band.
	*
	* @param outOfBandRecord out-of-band record for which to create a connection request
	* @param config config for creation of connection request
	* @returns outbound message containing connection request
	*/
	async createRequest(agentContext, outOfBandRecord, config) {
		this.ensureWarningLoggedOnce();
		this.logger.debug(`Create message ${DidCommConnectionRequestMessage.type.messageTypeUri} start`, outOfBandRecord);
		outOfBandRecord.assertRole(DidCommOutOfBandRole.Receiver);
		outOfBandRecord.assertState(DidCommOutOfBandState.PrepareResponse);
		const { outOfBandInvitation } = outOfBandRecord;
		const { mediatorId } = config.routing;
		const { didDoc, keys } = this.createDidDoc(config.routing);
		const [invitationDid] = outOfBandInvitation.invitationDids;
		const { did: peerDid } = await this.createDid(agentContext, {
			role: DidDocumentRole.Created,
			didDoc,
			keys
		});
		const { label, imageUrl } = config;
		const connectionRequest = new DidCommConnectionRequestMessage({
			label,
			did: didDoc.id,
			didDoc,
			imageUrl
		});
		connectionRequest.setThread({
			threadId: connectionRequest.threadId,
			parentThreadId: outOfBandRecord.outOfBandInvitation.id
		});
		const connectionRecord = await this.createConnection(agentContext, {
			protocol: DidCommHandshakeProtocol.Connections,
			role: DidCommDidExchangeRole.Requester,
			state: DidCommDidExchangeState.InvitationReceived,
			theirLabel: outOfBandInvitation.label,
			alias: config?.alias,
			did: peerDid,
			mediatorId,
			autoAcceptConnection: config?.autoAcceptConnection,
			outOfBandId: outOfBandRecord.id,
			invitationDid,
			imageUrl: outOfBandInvitation.imageUrl,
			threadId: connectionRequest.threadId
		});
		await this.updateState(agentContext, connectionRecord, DidCommDidExchangeState.RequestSent);
		return {
			connectionRecord,
			message: connectionRequest
		};
	}
	async processRequest(messageContext, outOfBandRecord) {
		this.ensureWarningLoggedOnce();
		this.logger.debug(`Process message ${DidCommConnectionRequestMessage.type.messageTypeUri} start`, { message: messageContext.message });
		outOfBandRecord.assertRole(DidCommOutOfBandRole.Sender);
		outOfBandRecord.assertState(DidCommOutOfBandState.AwaitResponse);
		const { message } = messageContext;
		if (!message.connection.didDoc) throw new ConnectionProblemReportError("Public DIDs are not supported yet", { problemCode: ConnectionProblemReportReason.RequestNotAccepted });
		const { did: peerDid } = await this.createDid(messageContext.agentContext, {
			role: DidDocumentRole.Received,
			didDoc: message.connection.didDoc
		});
		const connectionRecord = await this.createConnection(messageContext.agentContext, {
			protocol: DidCommHandshakeProtocol.Connections,
			role: DidCommDidExchangeRole.Responder,
			state: DidCommDidExchangeState.RequestReceived,
			alias: outOfBandRecord.alias,
			theirLabel: message.label,
			imageUrl: message.imageUrl,
			outOfBandId: outOfBandRecord.id,
			theirDid: peerDid,
			threadId: message.threadId,
			mediatorId: outOfBandRecord.mediatorId,
			autoAcceptConnection: outOfBandRecord.autoAcceptConnection
		});
		await this.connectionRepository.update(messageContext.agentContext, connectionRecord);
		this.emitStateChangedEvent(messageContext.agentContext, connectionRecord, null);
		this.logger.debug(`Process message ${DidCommConnectionRequestMessage.type.messageTypeUri} end`, connectionRecord);
		return connectionRecord;
	}
	/**
	* Create a connection response message for the connection with the specified connection id.
	*
	* @param connectionRecord the connection for which to create a connection response
	* @returns outbound message containing connection response
	*/
	async createResponse(agentContext, connectionRecord, outOfBandRecord, routing) {
		this.ensureWarningLoggedOnce();
		this.logger.debug(`Create message ${DidCommConnectionResponseMessage.type.messageTypeUri} start`, connectionRecord);
		connectionRecord.assertState(DidCommDidExchangeState.RequestReceived);
		connectionRecord.assertRole(DidCommDidExchangeRole.Responder);
		let didDoc;
		let keys;
		if (routing) {
			const result = this.createDidDoc(routing);
			didDoc = result.didDoc;
			keys = result.keys;
		} else if (outOfBandRecord.outOfBandInvitation.getInlineServices().length > 0) {
			const result = this.createDidDocFromOutOfBandDidCommServices(outOfBandRecord);
			didDoc = result.didDoc;
			keys = result.keys;
		} else throw new CredoError("No routing provided, and no inline services found in out of band invitation. When using did services in out of band invitation, make sure to provide routing information for rotation.");
		const { did: peerDid } = await this.createDid(agentContext, {
			role: DidDocumentRole.Created,
			didDoc,
			keys
		});
		const connection = new DidCommConnection({
			did: didDoc.id,
			didDoc
		});
		const connectionJson = JsonTransformer.toJSON(connection);
		if (!connectionRecord.threadId) throw new CredoError(`Connection record with id ${connectionRecord.id} does not have a thread id`);
		let signingKey;
		const firstService = outOfBandRecord.outOfBandInvitation.getServices()[0];
		if (typeof firstService === "string") {
			const resolved = await agentContext.resolve(DidsApi).resolveCreatedDidDocumentWithKeys(parseDid(firstService).did);
			const recipientKeys = resolved.didDocument.getRecipientKeysWithVerificationMethod({ mapX25519ToEd25519: true });
			if (recipientKeys.length === 0) throw new CredoError(`Unable to extract signing key for connection response from did '${firstService}'`);
			signingKey = recipientKeys[0].publicJwk;
			signingKey.keyId = resolved.keys?.find(({ didDocumentRelativeKeyId }) => recipientKeys[0].verificationMethod.id.endsWith(didDocumentRelativeKeyId))?.kmsKeyId ?? signingKey.legacyKeyId;
		} else signingKey = getResolvedDidcommServiceWithSigningKeyId(firstService, outOfBandRecord.invitationInlineServiceKeys).recipientKeys[0];
		const connectionResponse = new DidCommConnectionResponseMessage({
			threadId: connectionRecord.threadId,
			connectionSig: await signData(agentContext, connectionJson, signingKey)
		});
		connectionRecord.did = peerDid;
		await this.updateState(agentContext, connectionRecord, DidCommDidExchangeState.ResponseSent);
		this.logger.debug(`Create message ${DidCommConnectionResponseMessage.type.messageTypeUri} end`, {
			connectionRecord,
			message: connectionResponse
		});
		return {
			connectionRecord,
			message: connectionResponse
		};
	}
	/**
	* Process a received connection response message. This will not accept the connection request
	* or send a connection acknowledgement message. It will only update the existing connection record
	* with all the new information from the connection response message. Use {@link DidCommConnectionService.createTrustPing}
	* after calling this function to create a trust ping message.
	*
	* @param messageContext the message context containing a connection response message
	* @returns updated connection record
	*/
	async processResponse(messageContext, outOfBandRecord) {
		this.ensureWarningLoggedOnce();
		this.logger.debug(`Process message ${DidCommConnectionResponseMessage.type.messageTypeUri} start`, { message: messageContext.message });
		const { connection: connectionRecord, message, recipientKey, senderKey } = messageContext;
		if (!recipientKey || !senderKey) throw new CredoError("Unable to process connection request without senderKey or recipientKey");
		if (!connectionRecord) throw new CredoError("No connection record in message context.");
		connectionRecord.assertState(DidCommDidExchangeState.RequestSent);
		connectionRecord.assertRole(DidCommDidExchangeRole.Requester);
		let connectionJson = null;
		try {
			connectionJson = await unpackAndVerifySignatureDecorator(messageContext.agentContext, message.connectionSig);
		} catch (error) {
			if (error instanceof CredoError) throw new ConnectionProblemReportError(error.message, { problemCode: ConnectionProblemReportReason.ResponseProcessingError });
			throw error;
		}
		const connection = JsonTransformer.fromJSON(connectionJson, DidCommConnection);
		const signerVerkey = message.connectionSig.signer;
		const invitationKey = Kms.PublicJwk.fromFingerprint(outOfBandRecord.getTags().recipientKeyFingerprints[0]);
		if (!invitationKey.is(Kms.Ed25519PublicJwk)) throw new ConnectionProblemReportError(`Expected invitation key to be an Ed25519 key, found ${invitationKey.jwkTypeHumanDescription}`, { problemCode: ConnectionProblemReportReason.ResponseNotAccepted });
		if (signerVerkey !== TypedArrayEncoder.toBase58(invitationKey.publicKey.publicKey)) throw new ConnectionProblemReportError(`Connection object in connection response message is not signed with same key as recipient key in invitation expected='${invitationKey}' received='${signerVerkey}'`, { problemCode: ConnectionProblemReportReason.ResponseNotAccepted });
		if (!connection.didDoc) throw new CredoError("DID Document is missing.");
		const { did: peerDid } = await this.createDid(messageContext.agentContext, {
			role: DidDocumentRole.Received,
			didDoc: connection.didDoc
		});
		connectionRecord.theirDid = peerDid;
		connectionRecord.threadId = message.threadId;
		await this.updateState(messageContext.agentContext, connectionRecord, DidCommDidExchangeState.ResponseReceived);
		return connectionRecord;
	}
	/**
	* Create a trust ping message for the connection with the specified connection id.
	*
	* By default a trust ping message should elicit a response. If this is not desired the
	* `config.responseRequested` property can be set to `false`.
	*
	* @param connectionRecord the connection for which to create a trust ping message
	* @param config the config for the trust ping message
	* @returns outbound message containing trust ping message
	*/
	async createTrustPing(agentContext, connectionRecord, config = {}) {
		connectionRecord.assertState([DidCommDidExchangeState.ResponseReceived, DidCommDidExchangeState.Completed]);
		const trustPing = new DidCommTrustPingMessage(config);
		if (connectionRecord.state !== DidCommDidExchangeState.Completed) await this.updateState(agentContext, connectionRecord, DidCommDidExchangeState.Completed);
		return {
			connectionRecord,
			message: trustPing
		};
	}
	/**
	* Process a received ack message. This will update the state of the connection
	* to Completed if this is not already the case.
	*
	* @param messageContext the message context containing an ack message
	* @returns updated connection record
	*/
	async processAck(messageContext) {
		const { connection, recipientKey } = messageContext;
		if (!connection) throw new CredoError(`Unable to process connection ack: connection for recipient key ${recipientKey?.fingerprint} not found`);
		if (connection.state === DidCommDidExchangeState.ResponseSent && connection.role === DidCommDidExchangeRole.Responder) await this.updateState(messageContext.agentContext, connection, DidCommDidExchangeState.Completed);
		return connection;
	}
	/**
	* Process a received {@link DidCommProblemReportMessage}.
	*
	* @param messageContext The message context containing a connection problem report message
	* @returns connection record associated with the connection problem report message
	*
	*/
	async processProblemReport(messageContext) {
		this.ensureWarningLoggedOnce();
		const { message: connectionProblemReportMessage, recipientKey, senderKey } = messageContext;
		this.logger.debug(`Processing connection problem report for verkey ${recipientKey?.fingerprint}`);
		if (!recipientKey) throw new CredoError("Unable to process connection problem report without recipientKey");
		const ourDidRecord = await this.didRepository.findCreatedDidByRecipientKey(messageContext.agentContext, recipientKey);
		if (!ourDidRecord) throw new CredoError(`Unable to process connection problem report: created did record for recipient key ${recipientKey.fingerprint} not found`);
		const connectionRecord = await this.findByOurDid(messageContext.agentContext, ourDidRecord.did);
		if (!connectionRecord) throw new CredoError(`Unable to process connection problem report: connection for recipient key ${recipientKey.fingerprint} not found`);
		const theirDidRecord = connectionRecord.theirDid && await this.didRepository.findReceivedDid(messageContext.agentContext, connectionRecord.theirDid);
		if (!theirDidRecord) throw new CredoError(`Received did record for did ${connectionRecord.theirDid} not found.`);
		if (senderKey) {
			if (!theirDidRecord?.getTags().recipientKeyFingerprints?.includes(senderKey.fingerprint)) throw new CredoError("Sender key doesn't match key of connection record");
		}
		connectionRecord.errorMessage = `${connectionProblemReportMessage.description.code} : ${connectionProblemReportMessage.description.en}`;
		await this.update(messageContext.agentContext, connectionRecord);
		await this.updateState(messageContext.agentContext, connectionRecord, DidCommDidExchangeState.Abandoned);
		return connectionRecord;
	}
	/**
	* Assert that an inbound message either has a connection associated with it,
	* or has everything correctly set up for connection-less exchange (optionally with out of band)
	*
	* @param messageContext - the inbound message context
	*/
	async assertConnectionOrOutOfBandExchange(messageContext, { lastSentMessage, lastReceivedMessage, expectedConnectionId } = {}) {
		const { connection, message } = messageContext;
		if (expectedConnectionId && !connection) throw new CredoError(`Expected incoming message to be from connection ${expectedConnectionId} but no connection found.`);
		if (expectedConnectionId && connection?.id !== expectedConnectionId) throw new CredoError(`Expected incoming message to be from connection ${expectedConnectionId} but connection is ${connection?.id}.`);
		if (connection) {
			connection.assertReady();
			this.logger.debug(`Processing message with id ${message.id} and connection id ${connection.id}`, { type: message.type });
		} else {
			this.logger.debug(`Processing connection-less message with id ${message.id}`, { type: message.type });
			const recipientKey = messageContext.recipientKey;
			const senderKey = messageContext.senderKey;
			let theirService = messageContext.message?.service?.resolvedDidCommService ?? lastReceivedMessage?.service?.resolvedDidCommService;
			let ourService = lastSentMessage?.service?.resolvedDidCommService;
			const outOfBandRepository = messageContext.agentContext.dependencyManager.resolve(DidCommOutOfBandRepository);
			const outOfBandService = messageContext.agentContext.dependencyManager.resolve(DidCommOutOfBandService);
			const outOfBandRecord = await outOfBandRepository.findSingleByQuery(messageContext.agentContext, { invitationRequestsThreadIds: [message.threadId] });
			if (outOfBandRecord?.role === DidCommOutOfBandRole.Sender) ourService = await outOfBandService.getResolvedServiceForOutOfBandServices(messageContext.agentContext, outOfBandRecord.outOfBandInvitation.getServices(), outOfBandRecord.invitationInlineServiceKeys);
			else if (outOfBandRecord?.role === DidCommOutOfBandRole.Receiver) theirService = await outOfBandService.getResolvedServiceForOutOfBandServices(messageContext.agentContext, outOfBandRecord.outOfBandInvitation.getServices());
			if (!theirService && !outOfBandRecord) throw new CredoError("No service for incoming connection-less message and no associated out of band record found.");
			if (!ourService && (lastReceivedMessage || lastSentMessage)) throw new CredoError("No keys on our side to use for encrypting messages, and previous messages found (in which case our keys MUST also be present).");
			if ((!senderKey || !recipientKey) && (lastSentMessage || lastReceivedMessage)) throw new CredoError("Incoming message must have recipientKey and senderKey (so cannot be AuthCrypt or unpacked) if there are lastSentMessage or lastReceivedMessage.");
			if (recipientKey && ourService) {
				if (!ourService.recipientKeys.some((key) => recipientKey.equals(key))) throw new CredoError(`Recipient key ${recipientKey.fingerprint} not found in our service`);
			}
			if (senderKey && theirService) {
				if (!theirService.recipientKeys.some((key) => senderKey.equals(key))) throw new CredoError(`Sender key ${senderKey.fingerprint} not found in their service.`);
			}
		}
	}
	/**
	* If knownConnectionId is passed, it will compare the incoming connection id with the knownConnectionId, and skip the other validation.
	*
	* If no known connection id is passed, it asserts that the incoming message is in response to an attached request message to an out of band invitation.
	* If is the case, and the state of the out of band record is still await response, the state will be updated to done
	*
	*/
	async matchIncomingMessageToRequestMessageInOutOfBandExchange(messageContext, { expectedConnectionId }) {
		if (expectedConnectionId && messageContext.connection?.id !== expectedConnectionId) throw new CredoError(`Expecting incoming message to have connection ${expectedConnectionId}, but incoming connection is ${messageContext.connection?.id ?? "undefined"}`);
		const outOfBandRepository = messageContext.agentContext.dependencyManager.resolve(DidCommOutOfBandRepository);
		const outOfBandInvitationId = messageContext.message.thread?.parentThreadId;
		const outOfBandRecord = await outOfBandRepository.findSingleByQuery(messageContext.agentContext, {
			invitationId: outOfBandInvitationId,
			role: DidCommOutOfBandRole.Sender,
			invitationRequestsThreadIds: [messageContext.message.threadId]
		});
		if (!outOfBandRecord) throw new CredoError(`No out of band record found for credential request message with thread ${messageContext.message.threadId}, out of band invitation id ${outOfBandInvitationId} and role ${DidCommOutOfBandRole.Sender}`);
		if (outOfBandRecord.metadata.get(DidCommOutOfBandRecordMetadataKeys.LegacyInvitation)?.legacyInvitationType !== DidCommInvitationType.Connectionless && outOfBandRecord.outOfBandInvitation.id !== outOfBandInvitationId) throw new CredoError("Response messages to out of band invitation requests MUST have a parent thread id that matches the out of band invitation id.");
		if (outOfBandRecord.reusable) throw new CredoError("Receiving messages in response to reusable out of band invitations is not supported.");
		if (outOfBandRecord.state === DidCommOutOfBandState.Done) {
			if (!messageContext.connection) throw new CredoError("Can't find connection associated with incoming message, while out of band state is done. State must be await response if no connection has been created");
			if (messageContext.connection.outOfBandId !== outOfBandRecord.id) throw new CredoError("Connection associated with incoming message is not associated with the out of band invitation containing the attached message.");
		} else if (outOfBandRecord.state === DidCommOutOfBandState.AwaitResponse) {
			outOfBandRecord.state = DidCommOutOfBandState.Done;
			await outOfBandRepository.update(messageContext.agentContext, outOfBandRecord);
		} else throw new CredoError(`Out of band record is in incorrect state ${outOfBandRecord.state}`);
	}
	async updateState(agentContext, connectionRecord, newState) {
		const previousState = connectionRecord.state;
		connectionRecord.state = newState;
		await this.connectionRepository.update(agentContext, connectionRecord);
		this.emitStateChangedEvent(agentContext, connectionRecord, previousState);
	}
	emitStateChangedEvent(agentContext, connectionRecord, previousState) {
		this.eventEmitter.emit(agentContext, {
			type: DidCommConnectionEventTypes.DidCommConnectionStateChanged,
			payload: {
				connectionRecord: connectionRecord.clone(),
				previousState
			}
		});
	}
	update(agentContext, connectionRecord) {
		return this.connectionRepository.update(agentContext, connectionRecord);
	}
	/**
	* Retrieve all connections records
	*
	* @returns List containing all connection records
	*/
	getAll(agentContext) {
		return this.connectionRepository.getAll(agentContext);
	}
	/**
	* Retrieve a connection record by id
	*
	* @param connectionId The connection record id
	* @throws {RecordNotFoundError} If no record is found
	* @return The connection record
	*
	*/
	getById(agentContext, connectionId) {
		return this.connectionRepository.getById(agentContext, connectionId);
	}
	/**
	* Find a connection record by id
	*
	* @param connectionId the connection record id
	* @returns The connection record or null if not found
	*/
	findById(agentContext, connectionId) {
		return this.connectionRepository.findById(agentContext, connectionId);
	}
	/**
	* Delete a connection record by id
	*
	* @param connectionId the connection record id
	*/
	async deleteById(agentContext, connectionId) {
		const connectionRecord = await this.getById(agentContext, connectionId);
		return this.connectionRepository.delete(agentContext, connectionRecord);
	}
	async findByDids(agentContext, query) {
		return this.connectionRepository.findByDids(agentContext, query);
	}
	/**
	* Retrieve a connection record by thread id
	*
	* @param threadId The thread id
	* @throws {RecordNotFoundError} If no record is found
	* @throws {RecordDuplicateError} If multiple records are found
	* @returns The connection record
	*/
	async getByThreadId(agentContext, threadId) {
		return this.connectionRepository.getByThreadId(agentContext, threadId);
	}
	async getByRoleAndThreadId(agentContext, role, threadId) {
		return this.connectionRepository.getByRoleAndThreadId(agentContext, role, threadId);
	}
	async findByTheirDid(agentContext, theirDid) {
		return this.connectionRepository.findSingleByQuery(agentContext, { theirDid });
	}
	async findByOurDid(agentContext, ourDid) {
		return this.connectionRepository.findSingleByQuery(agentContext, { did: ourDid });
	}
	async findAllByOutOfBandId(agentContext, outOfBandId) {
		return this.connectionRepository.findByQuery(agentContext, { outOfBandId });
	}
	async findAllByConnectionTypes(agentContext, connectionTypes) {
		return this.connectionRepository.findByQuery(agentContext, { connectionTypes });
	}
	async findByInvitationDid(agentContext, invitationDid) {
		return this.connectionRepository.findByQuery(agentContext, { invitationDid });
	}
	async findByKeys(agentContext, { senderKey, recipientKey }) {
		const theirDidRecord = await this.didRepository.findReceivedDidByRecipientKey(agentContext, senderKey);
		if (theirDidRecord) {
			const ourDidRecord = await this.didRepository.findCreatedDidByRecipientKey(agentContext, recipientKey);
			if (ourDidRecord) {
				const connectionRecord = await this.findByDids(agentContext, {
					ourDid: ourDidRecord.did,
					theirDid: theirDidRecord.did
				});
				if (connectionRecord?.isReady) return connectionRecord;
			}
		}
		this.logger.debug(`No connection record found for encrypted message with recipient key ${recipientKey.fingerprint} and sender key ${senderKey.fingerprint}`);
		return null;
	}
	async findAllByQuery(agentContext, query, queryOptions) {
		return this.connectionRepository.findByQuery(agentContext, query, queryOptions);
	}
	async createConnection(agentContext, options) {
		const connectionRecord = new DidCommConnectionRecord(options);
		await this.connectionRepository.save(agentContext, connectionRecord);
		return connectionRecord;
	}
	async addConnectionType(agentContext, connectionRecord, type) {
		connectionRecord.connectionTypes = [type, ...connectionRecord.connectionTypes || []];
		await this.update(agentContext, connectionRecord);
	}
	async removeConnectionType(agentContext, connectionRecord, type) {
		connectionRecord.connectionTypes = connectionRecord.connectionTypes.filter((value) => value !== type);
		await this.update(agentContext, connectionRecord);
	}
	async getConnectionTypes(connectionRecord) {
		return connectionRecord.connectionTypes || [];
	}
	async createDid(agentContext, { role, didDoc, keys }) {
		if (keys && role !== DidDocumentRole.Created) throw new CredoError(`keys can only be provided for did documents when the role is '${DidDocumentRole.Created}'`);
		const { didDocument, keys: updatedKeys } = convertToNewDidDocument(didDoc, keys);
		if (role === DidDocumentRole.Created) await assertNoCreatedDidExistsForKeys(agentContext, didDocument.recipientKeys);
		const peerDid = didDocumentJsonToNumAlgo1Did(didDocument.toJSON());
		didDocument.id = peerDid;
		const didRecord = new DidRecord({
			did: peerDid,
			role,
			didDocument,
			keys: updatedKeys
		});
		didRecord.metadata.set(DidRecordMetadataKeys.LegacyDid, {
			unqualifiedDid: didDoc.id,
			didDocumentString: JsonTransformer.serialize(didDoc)
		});
		this.logger.debug("Saving DID record", {
			id: didRecord.id,
			did: didRecord.did,
			role: didRecord.role,
			tags: didRecord.getTags(),
			didDocument: "omitted..."
		});
		await this.didRepository.save(agentContext, didRecord);
		this.logger.debug("Did record created.", didRecord);
		return {
			did: peerDid,
			didDocument
		};
	}
	createDidDoc(routing) {
		const recipientKeyBase58 = TypedArrayEncoder.toBase58(routing.recipientKey.publicKey.publicKey);
		const indyDid = utils.indyDidFromPublicKeyBase58(recipientKeyBase58);
		const keys = [{
			didDocumentRelativeKeyId: "#1",
			kmsKeyId: routing.recipientKey.keyId
		}];
		const publicKey = new Ed25119Sig2018({
			id: `${indyDid}#1`,
			controller: indyDid,
			publicKeyBase58: recipientKeyBase58
		});
		const auth = new ReferencedAuthentication(publicKey, authenticationTypes.Ed25519VerificationKey2018);
		const services = routing.endpoints.map((endpoint, index) => new IndyAgentService({
			id: `${indyDid}#IndyAgentService-${index + 1}`,
			serviceEndpoint: endpoint,
			recipientKeys: [recipientKeyBase58],
			routingKeys: routing.routingKeys.map((key) => TypedArrayEncoder.toBase58(key.publicKey.publicKey)),
			priority: index
		}));
		return {
			didDoc: new DidDoc({
				id: indyDid,
				authentication: [auth],
				service: services,
				publicKey: [publicKey]
			}),
			keys
		};
	}
	createDidDocFromOutOfBandDidCommServices(outOfBandRecord) {
		const services = outOfBandRecord.outOfBandInvitation.getInlineServices().map((service) => getResolvedDidcommServiceWithSigningKeyId(service, outOfBandRecord.invitationInlineServiceKeys));
		const [recipientKey] = services[0].recipientKeys;
		const recipientKeyBase58 = TypedArrayEncoder.toBase58(recipientKey.publicKey.publicKey);
		const did = utils.indyDidFromPublicKeyBase58(recipientKeyBase58);
		const publicKey = new Ed25119Sig2018({
			id: `${did}#1`,
			controller: did,
			publicKeyBase58: recipientKeyBase58
		});
		const auth = new ReferencedAuthentication(publicKey, authenticationTypes.Ed25519VerificationKey2018);
		const service = services.map((service, index) => new IndyAgentService({
			id: `${did}#IndyAgentService-${index + 1}`,
			serviceEndpoint: service.serviceEndpoint,
			recipientKeys: [recipientKeyBase58],
			routingKeys: service.routingKeys?.map((publicJwk) => TypedArrayEncoder.toBase58(publicJwk.publicKey.publicKey)),
			priority: index
		}));
		return {
			didDoc: new DidDoc({
				id: did,
				authentication: [auth],
				service,
				publicKey: [publicKey]
			}),
			keys: [{
				didDocumentRelativeKeyId: "#1",
				kmsKeyId: recipientKey.keyId
			}]
		};
	}
	async returnWhenIsConnected(agentContext, connectionId, timeoutMs = 2e4) {
		const isConnected = (connection) => {
			return connection.id === connectionId && connection.state === DidCommDidExchangeState.Completed;
		};
		const observable = this.eventEmitter.observable(DidCommConnectionEventTypes.DidCommConnectionStateChanged);
		const subject = new ReplaySubject(1);
		observable.pipe(filterContextCorrelationId(agentContext.contextCorrelationId), map$1((e) => e.payload.connectionRecord), first$1(isConnected), timeout$1({
			first: timeoutMs,
			meta: "DidCommConnectionService.returnWhenIsConnected"
		})).subscribe(subject);
		const connection = await this.getById(agentContext, connectionId);
		if (isConnected(connection)) subject.next(connection);
		return firstValueFrom(subject);
	}
};
DidCommConnectionService = __decorate([
	injectable(),
	__decorateParam(0, inject(InjectionSymbols.Logger)),
	__decorateMetadata("design:paramtypes", [
		Object,
		typeof (_ref = typeof DidCommConnectionRepository !== "undefined" && DidCommConnectionRepository) === "function" ? _ref : Object,
		typeof (_ref2 = typeof DidRepository !== "undefined" && DidRepository) === "function" ? _ref2 : Object,
		typeof (_ref3 = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _ref3 : Object
	])
], DidCommConnectionService);

//#endregion
export { DidCommConnectionService };
//# sourceMappingURL=DidCommConnectionService.mjs.map