import { DidCommMessage } from "../../../DidCommMessage.mjs";
import { DidCommDidExchangeState } from "../models/DidCommDidExchangeState.mjs";
import { DidCommConnectionType } from "../models/DidCommConnectionType.mjs";
import { DidCommDidExchangeRole } from "../models/DidCommDidExchangeRole.mjs";
import "../models/index.mjs";
import { DidCommAckMessage } from "../../../messages/common/DidCommAckMessage.mjs";
import "../../../messages/index.mjs";
import { DidCommConnectionProblemReportMessage } from "../messages/DidCommConnectionProblemReportMessage.mjs";
import { DidCommConnectionRequestMessage } from "../messages/DidCommConnectionRequestMessage.mjs";
import { DidCommConnectionResponseMessage } from "../messages/DidCommConnectionResponseMessage.mjs";
import { DidCommTrustPingMessage } from "../messages/DidCommTrustPingMessage.mjs";
import "../messages/index.mjs";
import { DidCommOutOfBandRecord } from "../../oob/repository/DidCommOutOfBandRecord.mjs";
import "../../oob/repository/index.mjs";
import { DidCommConnectionRecord, DidCommConnectionRecordProps } from "../repository/DidCommConnectionRecord.mjs";
import { DidCommConnectionRepository } from "../repository/DidCommConnectionRepository.mjs";
import "../repository/index.mjs";
import { DidCommInboundMessageContext } from "../../../models/DidCommInboundMessageContext.mjs";
import { DidCommRouting } from "../../../models/DidCommRouting.mjs";
import "../../../models/index.mjs";
import { AgentContext, DidRepository, EventEmitter, Kms, Logger, Query, QueryOptions } from "@credo-ts/core";

//#region src/modules/connections/services/DidCommConnectionService.d.ts
interface ConnectionRequestParams {
  label: string;
  imageUrl?: string;
  alias?: string;
  routing: DidCommRouting;
  autoAcceptConnection?: boolean;
}
declare class DidCommConnectionService {
  private connectionRepository;
  private didRepository;
  private eventEmitter;
  private logger;
  private hasLoggedWarning;
  constructor(logger: Logger, connectionRepository: DidCommConnectionRepository, didRepository: DidRepository, eventEmitter: EventEmitter);
  private ensureWarningLoggedOnce;
  /**
   * Create a connection request message for a given out-of-band.
   *
   * @param outOfBandRecord out-of-band record for which to create a connection request
   * @param config config for creation of connection request
   * @returns outbound message containing connection request
   */
  createRequest(agentContext: AgentContext, outOfBandRecord: DidCommOutOfBandRecord, config: ConnectionRequestParams): Promise<ConnectionProtocolMsgReturnType<DidCommConnectionRequestMessage>>;
  processRequest(messageContext: DidCommInboundMessageContext<DidCommConnectionRequestMessage>, outOfBandRecord: DidCommOutOfBandRecord): Promise<DidCommConnectionRecord>;
  /**
   * Create a connection response message for the connection with the specified connection id.
   *
   * @param connectionRecord the connection for which to create a connection response
   * @returns outbound message containing connection response
   */
  createResponse(agentContext: AgentContext, connectionRecord: DidCommConnectionRecord, outOfBandRecord: DidCommOutOfBandRecord, routing?: DidCommRouting): Promise<ConnectionProtocolMsgReturnType<DidCommConnectionResponseMessage>>;
  /**
   * Process a received connection response message. This will not accept the connection request
   * or send a connection acknowledgement message. It will only update the existing connection record
   * with all the new information from the connection response message. Use {@link DidCommConnectionService.createTrustPing}
   * after calling this function to create a trust ping message.
   *
   * @param messageContext the message context containing a connection response message
   * @returns updated connection record
   */
  processResponse(messageContext: DidCommInboundMessageContext<DidCommConnectionResponseMessage>, outOfBandRecord: DidCommOutOfBandRecord): Promise<DidCommConnectionRecord>;
  /**
   * Create a trust ping message for the connection with the specified connection id.
   *
   * By default a trust ping message should elicit a response. If this is not desired the
   * `config.responseRequested` property can be set to `false`.
   *
   * @param connectionRecord the connection for which to create a trust ping message
   * @param config the config for the trust ping message
   * @returns outbound message containing trust ping message
   */
  createTrustPing(agentContext: AgentContext, connectionRecord: DidCommConnectionRecord, config?: {
    responseRequested?: boolean;
    comment?: string;
  }): Promise<ConnectionProtocolMsgReturnType<DidCommTrustPingMessage>>;
  /**
   * Process a received ack message. This will update the state of the connection
   * to Completed if this is not already the case.
   *
   * @param messageContext the message context containing an ack message
   * @returns updated connection record
   */
  processAck(messageContext: DidCommInboundMessageContext<DidCommAckMessage>): Promise<DidCommConnectionRecord>;
  /**
   * Process a received {@link DidCommProblemReportMessage}.
   *
   * @param messageContext The message context containing a connection problem report message
   * @returns connection record associated with the connection problem report message
   *
   */
  processProblemReport(messageContext: DidCommInboundMessageContext<DidCommConnectionProblemReportMessage>): Promise<DidCommConnectionRecord>;
  /**
   * Assert that an inbound message either has a connection associated with it,
   * or has everything correctly set up for connection-less exchange (optionally with out of band)
   *
   * @param messageContext - the inbound message context
   */
  assertConnectionOrOutOfBandExchange(messageContext: DidCommInboundMessageContext, {
    lastSentMessage,
    lastReceivedMessage,
    expectedConnectionId
  }?: {
    lastSentMessage?: DidCommMessage | null;
    lastReceivedMessage?: DidCommMessage | null;
    expectedConnectionId?: string;
  }): Promise<void>;
  /**
   * If knownConnectionId is passed, it will compare the incoming connection id with the knownConnectionId, and skip the other validation.
   *
   * If no known connection id is passed, it asserts that the incoming message is in response to an attached request message to an out of band invitation.
   * If is the case, and the state of the out of band record is still await response, the state will be updated to done
   *
   */
  matchIncomingMessageToRequestMessageInOutOfBandExchange(messageContext: DidCommInboundMessageContext, {
    expectedConnectionId
  }: {
    expectedConnectionId?: string;
  }): Promise<void>;
  updateState(agentContext: AgentContext, connectionRecord: DidCommConnectionRecord, newState: DidCommDidExchangeState): Promise<void>;
  private emitStateChangedEvent;
  update(agentContext: AgentContext, connectionRecord: DidCommConnectionRecord): Promise<void>;
  /**
   * Retrieve all connections records
   *
   * @returns List containing all connection records
   */
  getAll(agentContext: AgentContext): Promise<DidCommConnectionRecord[]>;
  /**
   * Retrieve a connection record by id
   *
   * @param connectionId The connection record id
   * @throws {RecordNotFoundError} If no record is found
   * @return The connection record
   *
   */
  getById(agentContext: AgentContext, connectionId: string): Promise<DidCommConnectionRecord>;
  /**
   * Find a connection record by id
   *
   * @param connectionId the connection record id
   * @returns The connection record or null if not found
   */
  findById(agentContext: AgentContext, connectionId: string): Promise<DidCommConnectionRecord | null>;
  /**
   * Delete a connection record by id
   *
   * @param connectionId the connection record id
   */
  deleteById(agentContext: AgentContext, connectionId: string): Promise<void>;
  findByDids(agentContext: AgentContext, query: {
    ourDid: string;
    theirDid: string;
  }): Promise<DidCommConnectionRecord | null>;
  /**
   * Retrieve a connection record by thread id
   *
   * @param threadId The thread id
   * @throws {RecordNotFoundError} If no record is found
   * @throws {RecordDuplicateError} If multiple records are found
   * @returns The connection record
   */
  getByThreadId(agentContext: AgentContext, threadId: string): Promise<DidCommConnectionRecord>;
  getByRoleAndThreadId(agentContext: AgentContext, role: DidCommDidExchangeRole, threadId: string): Promise<DidCommConnectionRecord>;
  findByTheirDid(agentContext: AgentContext, theirDid: string): Promise<DidCommConnectionRecord | null>;
  findByOurDid(agentContext: AgentContext, ourDid: string): Promise<DidCommConnectionRecord | null>;
  findAllByOutOfBandId(agentContext: AgentContext, outOfBandId: string): Promise<DidCommConnectionRecord[]>;
  findAllByConnectionTypes(agentContext: AgentContext, connectionTypes: Array<DidCommConnectionType | string>): Promise<DidCommConnectionRecord[]>;
  findByInvitationDid(agentContext: AgentContext, invitationDid: string): Promise<DidCommConnectionRecord[]>;
  findByKeys(agentContext: AgentContext, {
    senderKey,
    recipientKey
  }: {
    senderKey: Kms.PublicJwk<Kms.Ed25519PublicJwk>;
    recipientKey: Kms.PublicJwk<Kms.Ed25519PublicJwk>;
  }): Promise<DidCommConnectionRecord | null>;
  findAllByQuery(agentContext: AgentContext, query: Query<DidCommConnectionRecord>, queryOptions?: QueryOptions): Promise<DidCommConnectionRecord[]>;
  createConnection(agentContext: AgentContext, options: DidCommConnectionRecordProps): Promise<DidCommConnectionRecord>;
  addConnectionType(agentContext: AgentContext, connectionRecord: DidCommConnectionRecord, type: string): Promise<void>;
  removeConnectionType(agentContext: AgentContext, connectionRecord: DidCommConnectionRecord, type: string): Promise<void>;
  getConnectionTypes(connectionRecord: DidCommConnectionRecord): Promise<string[]>;
  private createDid;
  private createDidDoc;
  private createDidDocFromOutOfBandDidCommServices;
  returnWhenIsConnected(agentContext: AgentContext, connectionId: string, timeoutMs?: number): Promise<DidCommConnectionRecord>;
}
interface ConnectionProtocolMsgReturnType<MessageType extends DidCommMessage> {
  message: MessageType;
  connectionRecord: DidCommConnectionRecord;
}
//#endregion
export { ConnectionProtocolMsgReturnType, ConnectionRequestParams, DidCommConnectionService };
//# sourceMappingURL=DidCommConnectionService.d.mts.map