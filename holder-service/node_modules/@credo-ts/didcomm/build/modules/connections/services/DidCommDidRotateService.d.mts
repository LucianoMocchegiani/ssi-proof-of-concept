import { DidCommDidRotateAckMessage } from "../messages/DidCommDidRotateAckMessage.mjs";
import { DidCommDidRotateMessage } from "../messages/DidCommDidRotateMessage.mjs";
import { DidCommDidRotateProblemReportMessage } from "../messages/DidCommDidRotateProblemReportMessage.mjs";
import { DidCommHangupMessage } from "../messages/DidCommHangupMessage.mjs";
import "../messages/index.mjs";
import { DidCommConnectionRecord } from "../repository/DidCommConnectionRecord.mjs";
import "../repository/index.mjs";
import { DidCommOutboundMessageContext } from "../../../models/DidCommOutboundMessageContext.mjs";
import { DidCommInboundMessageContext } from "../../../models/DidCommInboundMessageContext.mjs";
import { DidCommRouting } from "../../../models/DidCommRouting.mjs";
import "../../../models/index.mjs";
import { AgentContext, DidResolverService, EventEmitter, Logger } from "@credo-ts/core";

//#region src/modules/connections/services/DidCommDidRotateService.d.ts
declare class DidCommDidRotateService {
  private didResolverService;
  private logger;
  private eventEmitter;
  constructor(didResolverService: DidResolverService, logger: Logger, eventEmitter: EventEmitter);
  createRotate(agentContext: AgentContext, options: {
    connection: DidCommConnectionRecord;
    toDid?: string;
    routing?: DidCommRouting;
  }): Promise<DidCommDidRotateMessage>;
  createHangup(agentContext: AgentContext, options: {
    connection: DidCommConnectionRecord;
  }): Promise<DidCommHangupMessage>;
  /**
   * Process a Hangup message and mark connection's theirDid as undefined so it is effectively terminated.
   * Connection Record itself is not deleted (TODO: config parameter to automatically do so)
   *
   * Its previous did will be stored in record in order to be able to recognize any message received
   * afterwards.
   *
   * @param messageContext
   */
  processHangup(messageContext: DidCommInboundMessageContext<DidCommHangupMessage>): Promise<void>;
  /**
   * Process an incoming DID Rotate message and update connection if success. Any acknowledge
   * or problem report will be sent to the prior DID, so the created context will take former
   * connection record data
   *
   * @param paramInboundDidCommMessageContext
   * @param connection
   * @returns
   */
  processRotate(messageContext: DidCommInboundMessageContext<DidCommDidRotateMessage>): Promise<DidCommOutboundMessageContext<DidCommDidRotateProblemReportMessage> | DidCommOutboundMessageContext<DidCommDidRotateAckMessage>>;
  processRotateAck(inboundMessage: DidCommInboundMessageContext<DidCommDidRotateAckMessage>): Promise<void>;
  /**
   * Process a problem report related to did rotate protocol, by simply deleting any temporary metadata.
   *
   * No specific event is thrown other than generic message processing
   *DidCommInboundMessageContext
   * @param messageContext
   */
  processProblemReport(messageContext: DidCommInboundMessageContext<DidCommDidRotateProblemReportMessage>): Promise<void>;
  clearDidRotationData(agentContext: AgentContext, connection: DidCommConnectionRecord): Promise<void>;
  private emitDidRotatedEvent;
}
//#endregion
export { DidCommDidRotateService };
//# sourceMappingURL=DidCommDidRotateService.d.mts.map