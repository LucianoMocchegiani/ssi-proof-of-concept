{"version":3,"file":"DidCommDidRotateService.mjs","names":[],"sources":["../../../../src/modules/connections/services/DidCommDidRotateService.ts"],"sourcesContent":["import type { AgentContext, DidDocument, DidDocumentKey } from '@credo-ts/core'\nimport {\n  CredoError,\n  DidRepository,\n  DidResolverService,\n  DidsApi,\n  EventEmitter,\n  getAlternativeDidsForPeerDid,\n  getNumAlgoFromPeerDid,\n  InjectionSymbols,\n  inject,\n  injectable,\n  isValidPeerDid,\n  type Logger,\n  PeerDidNumAlgo,\n} from '@credo-ts/core'\nimport { AckStatus } from '../../../messages'\nimport type { DidCommInboundMessageContext, DidCommRouting } from '../../../models'\nimport { DidCommOutboundMessageContext } from '../../../models'\nimport { getMediationRecordForDidDocument } from '../../routing/services/helpers'\nimport type { DidCommConnectionDidRotatedEvent } from '../DidCommConnectionEvents'\nimport { DidCommConnectionEventTypes } from '../DidCommConnectionEvents'\nimport { DidCommConnectionsModuleConfig } from '../DidCommConnectionsModuleConfig'\nimport {\n  DidCommDidRotateAckMessage,\n  DidCommDidRotateMessage,\n  DidCommDidRotateProblemReportMessage,\n  DidCommHangupMessage,\n} from '../messages'\nimport type { DidCommConnectionRecord } from '../repository'\nimport { DidCommConnectionMetadataKeys } from '../repository/DidCommConnectionMetadataTypes'\n\nimport { DidCommConnectionService } from './DidCommConnectionService'\nimport { createPeerDidFromServices, routingToServices } from './helpers'\n\n@injectable()\nexport class DidCommDidRotateService {\n  private didResolverService: DidResolverService\n  private logger: Logger\n  private eventEmitter: EventEmitter\n\n  public constructor(\n    didResolverService: DidResolverService,\n    @inject(InjectionSymbols.Logger) logger: Logger,\n    eventEmitter: EventEmitter\n  ) {\n    this.didResolverService = didResolverService\n    this.logger = logger\n    this.eventEmitter = eventEmitter\n  }\n\n  public async createRotate(\n    agentContext: AgentContext,\n    options: { connection: DidCommConnectionRecord; toDid?: string; routing?: DidCommRouting }\n  ) {\n    const { connection, toDid, routing } = options\n\n    const config = agentContext.resolve(DidCommConnectionsModuleConfig)\n    const dids = agentContext.resolve(DidsApi)\n\n    // Do not allow to receive concurrent did rotation flows\n    const didRotateMetadata = connection.metadata.get(DidCommConnectionMetadataKeys.DidRotate)\n\n    if (didRotateMetadata) {\n      throw new CredoError(`There is already an existing opened did rotation flow for connection id ${connection.id}`)\n    }\n\n    let resolvedDid: { keys: DidDocumentKey[] | undefined; didDocument: DidDocument }\n    let mediatorId: string | undefined\n    // If did is specified, make sure we have all key material for it\n    if (toDid) {\n      resolvedDid = await dids.resolveCreatedDidDocumentWithKeys(toDid)\n      mediatorId = (await getMediationRecordForDidDocument(agentContext, resolvedDid.didDocument))?.id\n\n      // Otherwise, create a did:peer based on the provided routing\n    } else {\n      if (!routing) {\n        throw new CredoError('Routing configuration must be defined when rotating to a new peer did')\n      }\n\n      resolvedDid = await createPeerDidFromServices(\n        agentContext,\n        routingToServices(routing),\n        config.peerNumAlgoForDidRotation\n      )\n      mediatorId = routing.mediatorId\n    }\n\n    const message = new DidCommDidRotateMessage({ toDid: resolvedDid.didDocument.id })\n\n    // We set new info into connection metadata for further 'sealing' it once we receive an acknowledge\n    // All messages sent in-between will be using previous connection information\n    connection.metadata.set(DidCommConnectionMetadataKeys.DidRotate, {\n      threadId: message.threadId,\n      did: resolvedDid.didDocument.id,\n      mediatorId,\n    })\n\n    await agentContext.resolve(DidCommConnectionService).update(agentContext, connection)\n\n    return message\n  }\n\n  public async createHangup(agentContext: AgentContext, options: { connection: DidCommConnectionRecord }) {\n    const { connection } = options\n\n    const message = new DidCommHangupMessage({})\n\n    // Remove did to indicate termination status for this connection\n    if (connection.did) {\n      connection.previousDids = [...connection.previousDids, connection.did]\n    }\n\n    connection.did = undefined\n\n    await agentContext.dependencyManager.resolve(DidCommConnectionService).update(agentContext, connection)\n\n    return message\n  }\n\n  /**\n   * Process a Hangup message and mark connection's theirDid as undefined so it is effectively terminated.\n   * Connection Record itself is not deleted (TODO: config parameter to automatically do so)\n   *\n   * Its previous did will be stored in record in order to be able to recognize any message received\n   * afterwards.\n   *\n   * @param messageContext\n   */\n  public async processHangup(messageContext: DidCommInboundMessageContext<DidCommHangupMessage>) {\n    const connection = messageContext.assertReadyConnection()\n    const { agentContext } = messageContext\n\n    if (connection.theirDid) {\n      connection.previousTheirDids = [...connection.previousTheirDids, connection.theirDid]\n    }\n\n    const previousTheirDid = connection.theirDid\n    connection.theirDid = undefined\n\n    await agentContext.dependencyManager.resolve(DidCommConnectionService).update(agentContext, connection)\n    this.emitDidRotatedEvent(agentContext, connection, {\n      previousTheirDid,\n    })\n  }\n\n  /**\n   * Process an incoming DID Rotate message and update connection if success. Any acknowledge\n   * or problem report will be sent to the prior DID, so the created context will take former\n   * connection record data\n   *\n   * @param paramInboundDidCommMessageContext\n   * @param connection\n   * @returns\n   */\n  public async processRotate(messageContext: DidCommInboundMessageContext<DidCommDidRotateMessage>) {\n    const connection = messageContext.assertReadyConnection()\n    const { message, agentContext } = messageContext\n\n    // Check and store their new did\n    const newDid = message.toDid\n\n    // DID Rotation not supported for peer:1 dids, as we need explicit did document information\n    if (isValidPeerDid(newDid) && getNumAlgoFromPeerDid(newDid) === PeerDidNumAlgo.GenesisDoc) {\n      this.logger.error(`Unable to resolve DID Document for '${newDid}`)\n\n      const response = new DidCommDidRotateProblemReportMessage({\n        description: { en: 'DID Method Unsupported', code: 'e.did.method_unsupported' },\n      })\n      return new DidCommOutboundMessageContext(response, { agentContext, connection })\n    }\n\n    const didDocument = (await this.didResolverService.resolve(agentContext, newDid)).didDocument\n\n    // Cannot resolve did\n    if (!didDocument) {\n      this.logger.error(`Unable to resolve DID Document for '${newDid}`)\n\n      const response = new DidCommDidRotateProblemReportMessage({\n        description: { en: 'DID Unresolvable', code: 'e.did.unresolvable' },\n      })\n      return new DidCommOutboundMessageContext(response, { agentContext, connection })\n    }\n\n    // Did is resolved but no compatible DIDComm services found\n    if (!didDocument.didCommServices) {\n      const response = new DidCommDidRotateProblemReportMessage({\n        description: { en: 'DID Document Unsupported', code: 'e.did.doc_unsupported' },\n      })\n      return new DidCommOutboundMessageContext(response, { agentContext, connection })\n    }\n\n    // Send acknowledge to previous did and persist new did. Previous did will be stored in connection record in\n    // order to still accept messages from it\n    const outboundMessageContext = new DidCommOutboundMessageContext(\n      new DidCommDidRotateAckMessage({\n        threadId: message.threadId,\n        status: AckStatus.OK,\n      }),\n      { agentContext, connection: connection.clone() }\n    )\n\n    // Store received did and update connection for further message processing\n    await agentContext.dependencyManager.resolve(DidRepository).storeReceivedDid(agentContext, {\n      did: didDocument.id,\n      didDocument,\n      tags: {\n        // For did:peer, store any alternative dids (like short form did:peer:4),\n        // it may have in order to relate any message referencing it\n        alternativeDids: isValidPeerDid(didDocument.id) ? getAlternativeDidsForPeerDid(didDocument.id) : undefined,\n      },\n    })\n\n    if (connection.theirDid) {\n      connection.previousTheirDids = [...connection.previousTheirDids, connection.theirDid]\n    }\n\n    const previousTheirDid = connection.theirDid\n    connection.theirDid = newDid\n\n    await agentContext.dependencyManager.resolve(DidCommConnectionService).update(agentContext, connection)\n    this.emitDidRotatedEvent(agentContext, connection, {\n      previousTheirDid,\n    })\n\n    return outboundMessageContext\n  }\n\n  public async processRotateAck(inboundMessage: DidCommInboundMessageContext<DidCommDidRotateAckMessage>) {\n    const { agentContext, message } = inboundMessage\n\n    const connection = inboundMessage.assertReadyConnection()\n\n    // Update connection info based on metadata set when creating the rotate message\n    const didRotateMetadata = connection.metadata.get(DidCommConnectionMetadataKeys.DidRotate)\n\n    if (!didRotateMetadata) {\n      throw new CredoError(`No did rotation data found for connection with id '${connection.id}'`)\n    }\n\n    if (didRotateMetadata.threadId !== message.threadId) {\n      throw new CredoError(\n        `Existing did rotation flow thread id '${didRotateMetadata.threadId} does not match incoming message'`\n      )\n    }\n\n    // Store previous did in order to still accept out-of-order messages that arrived later using it\n    if (connection.did) connection.previousDids = [...connection.previousDids, connection.did]\n\n    const previousOurDid = connection.did\n    connection.did = didRotateMetadata.did\n    connection.mediatorId = didRotateMetadata.mediatorId\n    connection.metadata.delete(DidCommConnectionMetadataKeys.DidRotate)\n\n    await agentContext.dependencyManager.resolve(DidCommConnectionService).update(agentContext, connection)\n    this.emitDidRotatedEvent(agentContext, connection, {\n      previousOurDid,\n    })\n  }\n\n  /**\n   * Process a problem report related to did rotate protocol, by simply deleting any temporary metadata.\n   *\n   * No specific event is thrown other than generic message processing\n   *DidCommInboundMessageContext\n   * @param messageContext\n   */\n  public async processProblemReport(\n    messageContext: DidCommInboundMessageContext<DidCommDidRotateProblemReportMessage>\n  ): Promise<void> {\n    const { message, agentContext } = messageContext\n\n    const connection = messageContext.assertReadyConnection()\n\n    this.logger.debug(`Processing problem report with id ${message.id}`)\n\n    // Delete any existing did rotation metadata in order to 'reset' the connection\n    const didRotateMetadata = connection.metadata.get(DidCommConnectionMetadataKeys.DidRotate)\n\n    if (!didRotateMetadata) {\n      throw new CredoError(`No did rotation data found for connection with id '${connection.id}'`)\n    }\n\n    connection.metadata.delete(DidCommConnectionMetadataKeys.DidRotate)\n\n    await agentContext.dependencyManager.resolve(DidCommConnectionService).update(agentContext, connection)\n  }\n\n  public async clearDidRotationData(agentContext: AgentContext, connection: DidCommConnectionRecord) {\n    const didRotateMetadata = connection.metadata.get(DidCommConnectionMetadataKeys.DidRotate)\n\n    if (!didRotateMetadata) {\n      throw new CredoError(`No did rotation data found for connection with id '${connection.id}'`)\n    }\n\n    connection.metadata.delete(DidCommConnectionMetadataKeys.DidRotate)\n\n    await agentContext.dependencyManager.resolve(DidCommConnectionService).update(agentContext, connection)\n  }\n\n  private emitDidRotatedEvent(\n    agentContext: AgentContext,\n    connectionRecord: DidCommConnectionRecord,\n    { previousOurDid, previousTheirDid }: { previousOurDid?: string; previousTheirDid?: string }\n  ) {\n    this.eventEmitter.emit<DidCommConnectionDidRotatedEvent>(agentContext, {\n      type: DidCommConnectionEventTypes.DidCommConnectionDidRotated,\n      payload: {\n        // Connection record in event should be static\n        connectionRecord: connectionRecord.clone(),\n\n        ourDid:\n          previousOurDid && connectionRecord.did\n            ? {\n                from: previousOurDid,\n                to: connectionRecord.did,\n              }\n            : undefined,\n\n        theirDid:\n          previousTheirDid && connectionRecord.theirDid\n            ? {\n                from: previousTheirDid,\n                to: connectionRecord.theirDid,\n              }\n            : undefined,\n      },\n    })\n  }\n}\n"],"mappings":"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"}