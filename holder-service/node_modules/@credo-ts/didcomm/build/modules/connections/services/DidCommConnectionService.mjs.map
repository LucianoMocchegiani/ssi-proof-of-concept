{"version":3,"file":"DidCommConnectionService.mjs","names":["map","first","timeout"],"sources":["../../../../src/modules/connections/services/DidCommConnectionService.ts"],"sourcesContent":["import type { AgentContext, DidDocumentKey, Query, QueryOptions } from '@credo-ts/core'\nimport {\n  CredoError,\n  DidDocumentRole,\n  DidRecord,\n  DidRecordMetadataKeys,\n  DidRepository,\n  DidsApi,\n  didDocumentJsonToNumAlgo1Did,\n  EventEmitter,\n  filterContextCorrelationId,\n  IndyAgentService,\n  InjectionSymbols,\n  inject,\n  injectable,\n  JsonTransformer,\n  Kms,\n  type Logger,\n  parseDid,\n  TypedArrayEncoder,\n  utils,\n} from '@credo-ts/core'\nimport { firstValueFrom, ReplaySubject } from 'rxjs'\nimport { first, map, timeout } from 'rxjs/operators'\nimport type { DidCommMessage } from '../../../DidCommMessage'\nimport { signData, unpackAndVerifySignatureDecorator } from '../../../decorators/signature/SignatureDecoratorUtils'\nimport type { DidCommAckMessage } from '../../../messages'\nimport type { DidCommInboundMessageContext, DidCommRouting } from '../../../models'\nimport { DidCommOutOfBandService } from '../../oob/DidCommOutOfBandService'\nimport { DidCommOutOfBandRole } from '../../oob/domain/DidCommOutOfBandRole'\nimport { DidCommOutOfBandState } from '../../oob/domain/DidCommOutOfBandState'\nimport { DidCommInvitationType } from '../../oob/messages'\nimport type { DidCommOutOfBandRecord } from '../../oob/repository'\nimport { DidCommOutOfBandRepository } from '../../oob/repository'\nimport { DidCommOutOfBandRecordMetadataKeys } from '../../oob/repository/outOfBandRecordMetadataTypes'\nimport type { DidCommConnectionStateChangedEvent } from '../DidCommConnectionEvents'\nimport { DidCommConnectionEventTypes } from '../DidCommConnectionEvents'\nimport { ConnectionProblemReportError, ConnectionProblemReportReason } from '../errors'\nimport type { DidCommConnectionProblemReportMessage } from '../messages'\nimport { DidCommConnectionRequestMessage, DidCommConnectionResponseMessage, DidCommTrustPingMessage } from '../messages'\nimport type { DidCommConnectionType } from '../models'\nimport {\n  authenticationTypes,\n  DidCommConnection,\n  DidCommDidExchangeRole,\n  DidCommDidExchangeState,\n  DidCommHandshakeProtocol,\n  DidDoc,\n  Ed25119Sig2018,\n  ReferencedAuthentication,\n} from '../models'\nimport type { DidCommConnectionRecordProps } from '../repository'\nimport { DidCommConnectionRecord, DidCommConnectionRepository } from '../repository'\n\nimport {\n  assertNoCreatedDidExistsForKeys,\n  convertToNewDidDocument,\n  getResolvedDidcommServiceWithSigningKeyId,\n} from './helpers'\n\nexport interface ConnectionRequestParams {\n  label: string\n  imageUrl?: string\n  alias?: string\n  routing: DidCommRouting\n  autoAcceptConnection?: boolean\n}\n\n@injectable()\nexport class DidCommConnectionService {\n  private connectionRepository: DidCommConnectionRepository\n  private didRepository: DidRepository\n  private eventEmitter: EventEmitter\n  private logger: Logger\n\n  private hasLoggedWarning = false\n\n  public constructor(\n    @inject(InjectionSymbols.Logger) logger: Logger,\n    connectionRepository: DidCommConnectionRepository,\n    didRepository: DidRepository,\n    eventEmitter: EventEmitter\n  ) {\n    this.connectionRepository = connectionRepository\n    this.didRepository = didRepository\n    this.eventEmitter = eventEmitter\n    this.logger = logger\n  }\n\n  private ensureWarningLoggedOnce() {\n    if (this.hasLoggedWarning) return\n\n    this.logger.debug(\n      'The v1 connection protocol is deprecated and will be removed in version 0.7 of Credo. You should upgrade to the did exchange protocol instead.'\n    )\n    this.hasLoggedWarning = true\n  }\n\n  /**\n   * Create a connection request message for a given out-of-band.\n   *\n   * @param outOfBandRecord out-of-band record for which to create a connection request\n   * @param config config for creation of connection request\n   * @returns outbound message containing connection request\n   */\n  public async createRequest(\n    agentContext: AgentContext,\n    outOfBandRecord: DidCommOutOfBandRecord,\n    config: ConnectionRequestParams\n  ): Promise<ConnectionProtocolMsgReturnType<DidCommConnectionRequestMessage>> {\n    this.ensureWarningLoggedOnce()\n    this.logger.debug(`Create message ${DidCommConnectionRequestMessage.type.messageTypeUri} start`, outOfBandRecord)\n    outOfBandRecord.assertRole(DidCommOutOfBandRole.Receiver)\n    outOfBandRecord.assertState(DidCommOutOfBandState.PrepareResponse)\n\n    // TODO check there is no connection record for particular oob record\n\n    const { outOfBandInvitation } = outOfBandRecord\n\n    const { mediatorId } = config.routing\n    const { didDoc, keys } = this.createDidDoc(config.routing)\n\n    // TODO: We should store only one did that we'll use to send the request message with success.\n    // We take just the first one for now.\n    const [invitationDid] = outOfBandInvitation.invitationDids\n\n    const { did: peerDid } = await this.createDid(agentContext, {\n      role: DidDocumentRole.Created,\n      didDoc,\n      keys,\n    })\n\n    const { label, imageUrl } = config\n\n    const connectionRequest = new DidCommConnectionRequestMessage({\n      label,\n      did: didDoc.id,\n      didDoc,\n      imageUrl,\n    })\n\n    connectionRequest.setThread({\n      threadId: connectionRequest.threadId,\n      parentThreadId: outOfBandRecord.outOfBandInvitation.id,\n    })\n\n    const connectionRecord = await this.createConnection(agentContext, {\n      protocol: DidCommHandshakeProtocol.Connections,\n      role: DidCommDidExchangeRole.Requester,\n      state: DidCommDidExchangeState.InvitationReceived,\n      theirLabel: outOfBandInvitation.label,\n      alias: config?.alias,\n      did: peerDid,\n      mediatorId,\n      autoAcceptConnection: config?.autoAcceptConnection,\n      outOfBandId: outOfBandRecord.id,\n      invitationDid,\n      imageUrl: outOfBandInvitation.imageUrl,\n      threadId: connectionRequest.threadId,\n    })\n\n    await this.updateState(agentContext, connectionRecord, DidCommDidExchangeState.RequestSent)\n\n    return {\n      connectionRecord,\n      message: connectionRequest,\n    }\n  }\n\n  public async processRequest(\n    messageContext: DidCommInboundMessageContext<DidCommConnectionRequestMessage>,\n    outOfBandRecord: DidCommOutOfBandRecord\n  ): Promise<DidCommConnectionRecord> {\n    this.ensureWarningLoggedOnce()\n    this.logger.debug(`Process message ${DidCommConnectionRequestMessage.type.messageTypeUri} start`, {\n      message: messageContext.message,\n    })\n    outOfBandRecord.assertRole(DidCommOutOfBandRole.Sender)\n    outOfBandRecord.assertState(DidCommOutOfBandState.AwaitResponse)\n\n    // TODO check there is no connection record for particular oob record\n\n    const { message } = messageContext\n    if (!message.connection.didDoc) {\n      throw new ConnectionProblemReportError('Public DIDs are not supported yet', {\n        problemCode: ConnectionProblemReportReason.RequestNotAccepted,\n      })\n    }\n\n    const { did: peerDid } = await this.createDid(messageContext.agentContext, {\n      role: DidDocumentRole.Received,\n      didDoc: message.connection.didDoc,\n    })\n\n    const connectionRecord = await this.createConnection(messageContext.agentContext, {\n      protocol: DidCommHandshakeProtocol.Connections,\n      role: DidCommDidExchangeRole.Responder,\n      state: DidCommDidExchangeState.RequestReceived,\n      alias: outOfBandRecord.alias,\n      theirLabel: message.label,\n      imageUrl: message.imageUrl,\n      outOfBandId: outOfBandRecord.id,\n      theirDid: peerDid,\n      threadId: message.threadId,\n      mediatorId: outOfBandRecord.mediatorId,\n      autoAcceptConnection: outOfBandRecord.autoAcceptConnection,\n    })\n\n    await this.connectionRepository.update(messageContext.agentContext, connectionRecord)\n    this.emitStateChangedEvent(messageContext.agentContext, connectionRecord, null)\n\n    this.logger.debug(`Process message ${DidCommConnectionRequestMessage.type.messageTypeUri} end`, connectionRecord)\n    return connectionRecord\n  }\n\n  /**\n   * Create a connection response message for the connection with the specified connection id.\n   *\n   * @param connectionRecord the connection for which to create a connection response\n   * @returns outbound message containing connection response\n   */\n  public async createResponse(\n    agentContext: AgentContext,\n    connectionRecord: DidCommConnectionRecord,\n    outOfBandRecord: DidCommOutOfBandRecord,\n    routing?: DidCommRouting\n  ): Promise<ConnectionProtocolMsgReturnType<DidCommConnectionResponseMessage>> {\n    this.ensureWarningLoggedOnce()\n    this.logger.debug(`Create message ${DidCommConnectionResponseMessage.type.messageTypeUri} start`, connectionRecord)\n    connectionRecord.assertState(DidCommDidExchangeState.RequestReceived)\n    connectionRecord.assertRole(DidCommDidExchangeRole.Responder)\n\n    let didDoc: DidDoc\n    let keys: DidDocumentKey[]\n    if (routing) {\n      const result = this.createDidDoc(routing)\n      didDoc = result.didDoc\n      keys = result.keys\n    } else if (outOfBandRecord.outOfBandInvitation.getInlineServices().length > 0) {\n      const result = this.createDidDocFromOutOfBandDidCommServices(outOfBandRecord)\n      didDoc = result.didDoc\n      keys = result.keys\n    } else {\n      // We don't support using a did from the OOB invitation services currently, in this case we always pass routing to this method\n      throw new CredoError(\n        'No routing provided, and no inline services found in out of band invitation. When using did services in out of band invitation, make sure to provide routing information for rotation.'\n      )\n    }\n\n    const { did: peerDid } = await this.createDid(agentContext, {\n      role: DidDocumentRole.Created,\n      didDoc,\n      keys,\n    })\n\n    const connection = new DidCommConnection({\n      did: didDoc.id,\n      didDoc,\n    })\n\n    const connectionJson = JsonTransformer.toJSON(connection)\n\n    if (!connectionRecord.threadId) {\n      throw new CredoError(`Connection record with id ${connectionRecord.id} does not have a thread id`)\n    }\n\n    let signingKey: Kms.PublicJwk<Kms.Ed25519PublicJwk>\n    const firstService = outOfBandRecord.outOfBandInvitation.getServices()[0]\n    if (typeof firstService === 'string') {\n      const dids = agentContext.resolve(DidsApi)\n      const resolved = await dids.resolveCreatedDidDocumentWithKeys(parseDid(firstService).did)\n\n      const recipientKeys = resolved.didDocument.getRecipientKeysWithVerificationMethod({ mapX25519ToEd25519: true })\n      if (recipientKeys.length === 0) {\n        throw new CredoError(`Unable to extract signing key for connection response from did '${firstService}'`)\n      }\n\n      signingKey = recipientKeys[0].publicJwk\n      // TOOD: we probably need an util: addKeyIdToVerificationMethodKey\n      signingKey.keyId =\n        resolved.keys?.find(({ didDocumentRelativeKeyId }) =>\n          recipientKeys[0].verificationMethod.id.endsWith(didDocumentRelativeKeyId)\n        )?.kmsKeyId ?? signingKey.legacyKeyId\n    } else {\n      const service = getResolvedDidcommServiceWithSigningKeyId(\n        firstService,\n        outOfBandRecord.invitationInlineServiceKeys\n      )\n      signingKey = service.recipientKeys[0]\n    }\n\n    const connectionResponse = new DidCommConnectionResponseMessage({\n      threadId: connectionRecord.threadId,\n      connectionSig: await signData(agentContext, connectionJson, signingKey),\n    })\n\n    connectionRecord.did = peerDid\n    await this.updateState(agentContext, connectionRecord, DidCommDidExchangeState.ResponseSent)\n\n    this.logger.debug(`Create message ${DidCommConnectionResponseMessage.type.messageTypeUri} end`, {\n      connectionRecord,\n      message: connectionResponse,\n    })\n    return {\n      connectionRecord,\n      message: connectionResponse,\n    }\n  }\n\n  /**\n   * Process a received connection response message. This will not accept the connection request\n   * or send a connection acknowledgement message. It will only update the existing connection record\n   * with all the new information from the connection response message. Use {@link DidCommConnectionService.createTrustPing}\n   * after calling this function to create a trust ping message.\n   *\n   * @param messageContext the message context containing a connection response message\n   * @returns updated connection record\n   */\n  public async processResponse(\n    messageContext: DidCommInboundMessageContext<DidCommConnectionResponseMessage>,\n    outOfBandRecord: DidCommOutOfBandRecord\n  ): Promise<DidCommConnectionRecord> {\n    this.ensureWarningLoggedOnce()\n    this.logger.debug(`Process message ${DidCommConnectionResponseMessage.type.messageTypeUri} start`, {\n      message: messageContext.message,\n    })\n    const { connection: connectionRecord, message, recipientKey, senderKey } = messageContext\n\n    if (!recipientKey || !senderKey) {\n      throw new CredoError('Unable to process connection request without senderKey or recipientKey')\n    }\n\n    if (!connectionRecord) {\n      throw new CredoError('No connection record in message context.')\n    }\n\n    connectionRecord.assertState(DidCommDidExchangeState.RequestSent)\n    connectionRecord.assertRole(DidCommDidExchangeRole.Requester)\n\n    let connectionJson = null\n    try {\n      connectionJson = await unpackAndVerifySignatureDecorator(messageContext.agentContext, message.connectionSig)\n    } catch (error) {\n      if (error instanceof CredoError) {\n        throw new ConnectionProblemReportError(error.message, {\n          problemCode: ConnectionProblemReportReason.ResponseProcessingError,\n        })\n      }\n      throw error\n    }\n\n    const connection = JsonTransformer.fromJSON(connectionJson, DidCommConnection)\n\n    // Per the Connection RFC we must check if the key used to sign the connection~sig is the same key\n    // as the recipient key(s) in the connection invitation message\n    const signerVerkey = message.connectionSig.signer\n\n    const invitationKey = Kms.PublicJwk.fromFingerprint(outOfBandRecord.getTags().recipientKeyFingerprints[0])\n    if (!invitationKey.is(Kms.Ed25519PublicJwk)) {\n      throw new ConnectionProblemReportError(\n        `Expected invitation key to be an Ed25519 key, found ${invitationKey.jwkTypeHumanDescription}`,\n        { problemCode: ConnectionProblemReportReason.ResponseNotAccepted }\n      )\n    }\n\n    const invitationKeyBase58 = TypedArrayEncoder.toBase58(invitationKey.publicKey.publicKey)\n\n    if (signerVerkey !== invitationKeyBase58) {\n      throw new ConnectionProblemReportError(\n        `Connection object in connection response message is not signed with same key as recipient key in invitation expected='${invitationKey}' received='${signerVerkey}'`,\n        { problemCode: ConnectionProblemReportReason.ResponseNotAccepted }\n      )\n    }\n\n    if (!connection.didDoc) {\n      throw new CredoError('DID Document is missing.')\n    }\n\n    const { did: peerDid } = await this.createDid(messageContext.agentContext, {\n      role: DidDocumentRole.Received,\n      didDoc: connection.didDoc,\n    })\n\n    connectionRecord.theirDid = peerDid\n    connectionRecord.threadId = message.threadId\n\n    await this.updateState(messageContext.agentContext, connectionRecord, DidCommDidExchangeState.ResponseReceived)\n    return connectionRecord\n  }\n\n  /**\n   * Create a trust ping message for the connection with the specified connection id.\n   *\n   * By default a trust ping message should elicit a response. If this is not desired the\n   * `config.responseRequested` property can be set to `false`.\n   *\n   * @param connectionRecord the connection for which to create a trust ping message\n   * @param config the config for the trust ping message\n   * @returns outbound message containing trust ping message\n   */\n  public async createTrustPing(\n    agentContext: AgentContext,\n    connectionRecord: DidCommConnectionRecord,\n    config: { responseRequested?: boolean; comment?: string } = {}\n  ): Promise<ConnectionProtocolMsgReturnType<DidCommTrustPingMessage>> {\n    connectionRecord.assertState([DidCommDidExchangeState.ResponseReceived, DidCommDidExchangeState.Completed])\n\n    // TODO:\n    //  - create ack message\n    //  - maybe this shouldn't be in the connection service?\n    const trustPing = new DidCommTrustPingMessage(config)\n\n    // Only update connection record and emit an event if the state is not already 'Complete'\n    if (connectionRecord.state !== DidCommDidExchangeState.Completed) {\n      await this.updateState(agentContext, connectionRecord, DidCommDidExchangeState.Completed)\n    }\n\n    return {\n      connectionRecord,\n      message: trustPing,\n    }\n  }\n\n  /**\n   * Process a received ack message. This will update the state of the connection\n   * to Completed if this is not already the case.\n   *\n   * @param messageContext the message context containing an ack message\n   * @returns updated connection record\n   */\n  public async processAck(\n    messageContext: DidCommInboundMessageContext<DidCommAckMessage>\n  ): Promise<DidCommConnectionRecord> {\n    const { connection, recipientKey } = messageContext\n\n    if (!connection) {\n      throw new CredoError(\n        `Unable to process connection ack: connection for recipient key ${recipientKey?.fingerprint} not found`\n      )\n    }\n\n    // TODO: This is better addressed in a middleware of some kind because\n    // any message can transition the state to complete, not just an ack or trust ping\n    if (\n      connection.state === DidCommDidExchangeState.ResponseSent &&\n      connection.role === DidCommDidExchangeRole.Responder\n    ) {\n      await this.updateState(messageContext.agentContext, connection, DidCommDidExchangeState.Completed)\n    }\n\n    return connection\n  }\n\n  /**\n   * Process a received {@link DidCommProblemReportMessage}.\n   *\n   * @param messageContext The message context containing a connection problem report message\n   * @returns connection record associated with the connection problem report message\n   *\n   */\n  public async processProblemReport(\n    messageContext: DidCommInboundMessageContext<DidCommConnectionProblemReportMessage>\n  ): Promise<DidCommConnectionRecord> {\n    this.ensureWarningLoggedOnce()\n    const { message: connectionProblemReportMessage, recipientKey, senderKey } = messageContext\n\n    this.logger.debug(`Processing connection problem report for verkey ${recipientKey?.fingerprint}`)\n\n    if (!recipientKey) {\n      throw new CredoError('Unable to process connection problem report without recipientKey')\n    }\n\n    const ourDidRecord = await this.didRepository.findCreatedDidByRecipientKey(\n      messageContext.agentContext,\n      recipientKey\n    )\n    if (!ourDidRecord) {\n      throw new CredoError(\n        `Unable to process connection problem report: created did record for recipient key ${recipientKey.fingerprint} not found`\n      )\n    }\n\n    const connectionRecord = await this.findByOurDid(messageContext.agentContext, ourDidRecord.did)\n    if (!connectionRecord) {\n      throw new CredoError(\n        `Unable to process connection problem report: connection for recipient key ${recipientKey.fingerprint} not found`\n      )\n    }\n\n    const theirDidRecord =\n      connectionRecord.theirDid &&\n      (await this.didRepository.findReceivedDid(messageContext.agentContext, connectionRecord.theirDid))\n    if (!theirDidRecord) {\n      throw new CredoError(`Received did record for did ${connectionRecord.theirDid} not found.`)\n    }\n\n    if (senderKey) {\n      if (!theirDidRecord?.getTags().recipientKeyFingerprints?.includes(senderKey.fingerprint)) {\n        throw new CredoError(\"Sender key doesn't match key of connection record\")\n      }\n    }\n\n    connectionRecord.errorMessage = `${connectionProblemReportMessage.description.code} : ${connectionProblemReportMessage.description.en}`\n    await this.update(messageContext.agentContext, connectionRecord)\n\n    // Marking connection as abandoned in case of problem report from issuer agent\n    // TODO: Can be conditionally abandoned - Like if another user is scanning already used connection invite where issuer will send invite-already-used problem code.\n    await this.updateState(messageContext.agentContext, connectionRecord, DidCommDidExchangeState.Abandoned)\n\n    return connectionRecord\n  }\n\n  /**\n   * Assert that an inbound message either has a connection associated with it,\n   * or has everything correctly set up for connection-less exchange (optionally with out of band)\n   *\n   * @param messageContext - the inbound message context\n   */\n  public async assertConnectionOrOutOfBandExchange(\n    messageContext: DidCommInboundMessageContext,\n    {\n      lastSentMessage,\n      lastReceivedMessage,\n      expectedConnectionId,\n    }: {\n      lastSentMessage?: DidCommMessage | null\n      lastReceivedMessage?: DidCommMessage | null\n      expectedConnectionId?: string\n    } = {}\n  ) {\n    const { connection, message } = messageContext\n\n    if (expectedConnectionId && !connection) {\n      throw new CredoError(\n        `Expected incoming message to be from connection ${expectedConnectionId} but no connection found.`\n      )\n    }\n    if (expectedConnectionId && connection?.id !== expectedConnectionId) {\n      throw new CredoError(\n        `Expected incoming message to be from connection ${expectedConnectionId} but connection is ${connection?.id}.`\n      )\n    }\n\n    // Check if we have a ready connection. Verification is already done somewhere else. Return\n    if (connection) {\n      connection.assertReady()\n      this.logger.debug(`Processing message with id ${message.id} and connection id ${connection.id}`, {\n        type: message.type,\n      })\n    } else {\n      this.logger.debug(`Processing connection-less message with id ${message.id}`, {\n        type: message.type,\n      })\n\n      const recipientKey = messageContext.recipientKey\n      const senderKey = messageContext.senderKey\n\n      // set theirService to the value of lastReceivedMessage.service\n      let theirService =\n        messageContext.message?.service?.resolvedDidCommService ?? lastReceivedMessage?.service?.resolvedDidCommService\n      let ourService = lastSentMessage?.service?.resolvedDidCommService\n\n      // FIXME: we should remove support for the flow where no out of band record is used.\n      // Users have had enough time to update to the OOB API which supports legacy connectionsless\n      // invitations as well\n      // 1. check if there's an oob record associated.\n      const outOfBandRepository = messageContext.agentContext.dependencyManager.resolve(DidCommOutOfBandRepository)\n      const outOfBandService = messageContext.agentContext.dependencyManager.resolve(DidCommOutOfBandService)\n      const outOfBandRecord = await outOfBandRepository.findSingleByQuery(messageContext.agentContext, {\n        invitationRequestsThreadIds: [message.threadId],\n      })\n\n      // If we have an out of band record, we can extract the service for our/the other party from the oob record\n      if (outOfBandRecord?.role === DidCommOutOfBandRole.Sender) {\n        ourService = await outOfBandService.getResolvedServiceForOutOfBandServices(\n          messageContext.agentContext,\n          outOfBandRecord.outOfBandInvitation.getServices(),\n          outOfBandRecord.invitationInlineServiceKeys\n        )\n      } else if (outOfBandRecord?.role === DidCommOutOfBandRole.Receiver) {\n        theirService = await outOfBandService.getResolvedServiceForOutOfBandServices(\n          messageContext.agentContext,\n          outOfBandRecord.outOfBandInvitation.getServices()\n        )\n      }\n\n      // theirService can be null when we receive an oob invitation and process the message.\n      // In this case there MUST be an oob record, otherwise there is no way for us to reply\n      // to the message\n      if (!theirService && !outOfBandRecord) {\n        throw new CredoError(\n          'No service for incoming connection-less message and no associated out of band record found.'\n        )\n      }\n\n      // ourService can be null when we receive an oob invitation or legacy connectionless message and process the message.\n      // In this case lastSentMessage and lastReceivedMessage MUST be null, because there shouldn't be any previous exchange\n      if (!ourService && (lastReceivedMessage || lastSentMessage)) {\n        throw new CredoError(\n          'No keys on our side to use for encrypting messages, and previous messages found (in which case our keys MUST also be present).'\n        )\n      }\n\n      // If the message is unpacked or AuthCrypt, there cannot be any previous exchange (this must be the first message).\n      // All exchange after the first unpacked oob exchange MUST be encrypted.\n      if ((!senderKey || !recipientKey) && (lastSentMessage || lastReceivedMessage)) {\n        throw new CredoError(\n          'Incoming message must have recipientKey and senderKey (so cannot be AuthCrypt or unpacked) if there are lastSentMessage or lastReceivedMessage.'\n        )\n      }\n\n      // Check if recipientKey is in ourService\n      if (recipientKey && ourService) {\n        const recipientKeyFound = ourService.recipientKeys.some((key) => recipientKey.equals(key))\n        if (!recipientKeyFound) {\n          throw new CredoError(`Recipient key ${recipientKey.fingerprint} not found in our service`)\n        }\n      }\n\n      // Check if senderKey is in theirService\n      if (senderKey && theirService) {\n        const senderKeyFound = theirService.recipientKeys.some((key) => senderKey.equals(key))\n        if (!senderKeyFound) {\n          throw new CredoError(`Sender key ${senderKey.fingerprint} not found in their service.`)\n        }\n      }\n    }\n  }\n\n  /**\n   * If knownConnectionId is passed, it will compare the incoming connection id with the knownConnectionId, and skip the other validation.\n   *\n   * If no known connection id is passed, it asserts that the incoming message is in response to an attached request message to an out of band invitation.\n   * If is the case, and the state of the out of band record is still await response, the state will be updated to done\n   *\n   */\n  public async matchIncomingMessageToRequestMessageInOutOfBandExchange(\n    messageContext: DidCommInboundMessageContext,\n    { expectedConnectionId }: { expectedConnectionId?: string }\n  ) {\n    if (expectedConnectionId && messageContext.connection?.id !== expectedConnectionId) {\n      throw new CredoError(\n        `Expecting incoming message to have connection ${expectedConnectionId}, but incoming connection is ${\n          messageContext.connection?.id ?? 'undefined'\n        }`\n      )\n    }\n\n    const outOfBandRepository = messageContext.agentContext.dependencyManager.resolve(DidCommOutOfBandRepository)\n    const outOfBandInvitationId = messageContext.message.thread?.parentThreadId\n\n    // Find the out of band record that is associated with this request\n    const outOfBandRecord = await outOfBandRepository.findSingleByQuery(messageContext.agentContext, {\n      invitationId: outOfBandInvitationId,\n      role: DidCommOutOfBandRole.Sender,\n      invitationRequestsThreadIds: [messageContext.message.threadId],\n    })\n\n    // There is no out of band record\n    if (!outOfBandRecord) {\n      throw new CredoError(\n        `No out of band record found for credential request message with thread ${messageContext.message.threadId}, out of band invitation id ${outOfBandInvitationId} and role ${DidCommOutOfBandRole.Sender}`\n      )\n    }\n\n    const legacyInvitationMetadata = outOfBandRecord.metadata.get(DidCommOutOfBandRecordMetadataKeys.LegacyInvitation)\n\n    // If the original invitation was a legacy connectionless invitation, it's okay if the message does not have a pthid.\n    if (\n      legacyInvitationMetadata?.legacyInvitationType !== DidCommInvitationType.Connectionless &&\n      outOfBandRecord.outOfBandInvitation.id !== outOfBandInvitationId\n    ) {\n      throw new CredoError(\n        'Response messages to out of band invitation requests MUST have a parent thread id that matches the out of band invitation id.'\n      )\n    }\n\n    // This should not happen, as it is not allowed to create reusable out of band invitations with attached messages\n    // But should that implementation change, we at least cover it here.\n    if (outOfBandRecord.reusable) {\n      throw new CredoError('Receiving messages in response to reusable out of band invitations is not supported.')\n    }\n\n    if (outOfBandRecord.state === DidCommOutOfBandState.Done) {\n      if (!messageContext.connection) {\n        throw new CredoError(\n          \"Can't find connection associated with incoming message, while out of band state is done. State must be await response if no connection has been created\"\n        )\n      }\n      if (messageContext.connection.outOfBandId !== outOfBandRecord.id) {\n        throw new CredoError(\n          'Connection associated with incoming message is not associated with the out of band invitation containing the attached message.'\n        )\n      }\n\n      // We're good to go. Connection was created and points to the correct out of band record. And the message is in response to an attached request message from the oob invitation.\n    } else if (outOfBandRecord.state === DidCommOutOfBandState.AwaitResponse) {\n      // We're good to go. Waiting for a response. And the message is in response to an attached request message from the oob invitation.\n\n      // Now that we have received the first response message to our out of band invitation, we mark the out of band record as done\n      outOfBandRecord.state = DidCommOutOfBandState.Done\n      await outOfBandRepository.update(messageContext.agentContext, outOfBandRecord)\n    } else {\n      throw new CredoError(`Out of band record is in incorrect state ${outOfBandRecord.state}`)\n    }\n  }\n\n  public async updateState(\n    agentContext: AgentContext,\n    connectionRecord: DidCommConnectionRecord,\n    newState: DidCommDidExchangeState\n  ) {\n    const previousState = connectionRecord.state\n    connectionRecord.state = newState\n    await this.connectionRepository.update(agentContext, connectionRecord)\n\n    this.emitStateChangedEvent(agentContext, connectionRecord, previousState)\n  }\n\n  private emitStateChangedEvent(\n    agentContext: AgentContext,\n    connectionRecord: DidCommConnectionRecord,\n    previousState: DidCommDidExchangeState | null\n  ) {\n    this.eventEmitter.emit<DidCommConnectionStateChangedEvent>(agentContext, {\n      type: DidCommConnectionEventTypes.DidCommConnectionStateChanged,\n      payload: {\n        // Connection record in event should be static\n        connectionRecord: connectionRecord.clone(),\n        previousState,\n      },\n    })\n  }\n\n  public update(agentContext: AgentContext, connectionRecord: DidCommConnectionRecord) {\n    return this.connectionRepository.update(agentContext, connectionRecord)\n  }\n\n  /**\n   * Retrieve all connections records\n   *\n   * @returns List containing all connection records\n   */\n  public getAll(agentContext: AgentContext) {\n    return this.connectionRepository.getAll(agentContext)\n  }\n\n  /**\n   * Retrieve a connection record by id\n   *\n   * @param connectionId The connection record id\n   * @throws {RecordNotFoundError} If no record is found\n   * @return The connection record\n   *\n   */\n  public getById(agentContext: AgentContext, connectionId: string): Promise<DidCommConnectionRecord> {\n    return this.connectionRepository.getById(agentContext, connectionId)\n  }\n\n  /**\n   * Find a connection record by id\n   *\n   * @param connectionId the connection record id\n   * @returns The connection record or null if not found\n   */\n  public findById(agentContext: AgentContext, connectionId: string): Promise<DidCommConnectionRecord | null> {\n    return this.connectionRepository.findById(agentContext, connectionId)\n  }\n\n  /**\n   * Delete a connection record by id\n   *\n   * @param connectionId the connection record id\n   */\n  public async deleteById(agentContext: AgentContext, connectionId: string) {\n    const connectionRecord = await this.getById(agentContext, connectionId)\n    return this.connectionRepository.delete(agentContext, connectionRecord)\n  }\n\n  public async findByDids(agentContext: AgentContext, query: { ourDid: string; theirDid: string }) {\n    return this.connectionRepository.findByDids(agentContext, query)\n  }\n\n  /**\n   * Retrieve a connection record by thread id\n   *\n   * @param threadId The thread id\n   * @throws {RecordNotFoundError} If no record is found\n   * @throws {RecordDuplicateError} If multiple records are found\n   * @returns The connection record\n   */\n  public async getByThreadId(agentContext: AgentContext, threadId: string): Promise<DidCommConnectionRecord> {\n    return this.connectionRepository.getByThreadId(agentContext, threadId)\n  }\n\n  public async getByRoleAndThreadId(agentContext: AgentContext, role: DidCommDidExchangeRole, threadId: string) {\n    return this.connectionRepository.getByRoleAndThreadId(agentContext, role, threadId)\n  }\n\n  public async findByTheirDid(agentContext: AgentContext, theirDid: string): Promise<DidCommConnectionRecord | null> {\n    return this.connectionRepository.findSingleByQuery(agentContext, { theirDid })\n  }\n\n  public async findByOurDid(agentContext: AgentContext, ourDid: string): Promise<DidCommConnectionRecord | null> {\n    return this.connectionRepository.findSingleByQuery(agentContext, { did: ourDid })\n  }\n\n  public async findAllByOutOfBandId(agentContext: AgentContext, outOfBandId: string) {\n    return this.connectionRepository.findByQuery(agentContext, { outOfBandId })\n  }\n\n  public async findAllByConnectionTypes(\n    agentContext: AgentContext,\n    connectionTypes: Array<DidCommConnectionType | string>\n  ) {\n    return this.connectionRepository.findByQuery(agentContext, { connectionTypes })\n  }\n\n  public async findByInvitationDid(agentContext: AgentContext, invitationDid: string) {\n    return this.connectionRepository.findByQuery(agentContext, { invitationDid })\n  }\n\n  public async findByKeys(\n    agentContext: AgentContext,\n    {\n      senderKey,\n      recipientKey,\n    }: { senderKey: Kms.PublicJwk<Kms.Ed25519PublicJwk>; recipientKey: Kms.PublicJwk<Kms.Ed25519PublicJwk> }\n  ) {\n    const theirDidRecord = await this.didRepository.findReceivedDidByRecipientKey(agentContext, senderKey)\n    if (theirDidRecord) {\n      const ourDidRecord = await this.didRepository.findCreatedDidByRecipientKey(agentContext, recipientKey)\n      if (ourDidRecord) {\n        const connectionRecord = await this.findByDids(agentContext, {\n          ourDid: ourDidRecord.did,\n          theirDid: theirDidRecord.did,\n        })\n        if (connectionRecord?.isReady) return connectionRecord\n      }\n    }\n\n    this.logger.debug(\n      `No connection record found for encrypted message with recipient key ${recipientKey.fingerprint} and sender key ${senderKey.fingerprint}`\n    )\n\n    return null\n  }\n\n  public async findAllByQuery(\n    agentContext: AgentContext,\n    query: Query<DidCommConnectionRecord>,\n    queryOptions?: QueryOptions\n  ): Promise<DidCommConnectionRecord[]> {\n    return this.connectionRepository.findByQuery(agentContext, query, queryOptions)\n  }\n\n  public async createConnection(\n    agentContext: AgentContext,\n    options: DidCommConnectionRecordProps\n  ): Promise<DidCommConnectionRecord> {\n    const connectionRecord = new DidCommConnectionRecord(options)\n    await this.connectionRepository.save(agentContext, connectionRecord)\n    return connectionRecord\n  }\n\n  public async addConnectionType(agentContext: AgentContext, connectionRecord: DidCommConnectionRecord, type: string) {\n    const connectionTypes = connectionRecord.connectionTypes || []\n    connectionRecord.connectionTypes = [type, ...connectionTypes]\n    await this.update(agentContext, connectionRecord)\n  }\n\n  public async removeConnectionType(\n    agentContext: AgentContext,\n    connectionRecord: DidCommConnectionRecord,\n    type: string\n  ) {\n    connectionRecord.connectionTypes = connectionRecord.connectionTypes.filter((value) => value !== type)\n    await this.update(agentContext, connectionRecord)\n  }\n\n  public async getConnectionTypes(connectionRecord: DidCommConnectionRecord) {\n    return connectionRecord.connectionTypes || []\n  }\n\n  private async createDid(\n    agentContext: AgentContext,\n    { role, didDoc, keys }: { role: DidDocumentRole; didDoc: DidDoc; keys?: DidDocumentKey[] }\n  ) {\n    if (keys && role !== DidDocumentRole.Created) {\n      throw new CredoError(`keys can only be provided for did documents when the role is '${DidDocumentRole.Created}'`)\n    }\n\n    // Convert the legacy did doc to a new did document\n    const { didDocument, keys: updatedKeys } = convertToNewDidDocument(didDoc, keys)\n\n    // Assert that the keys we are going to use for creating a did document haven't already been used in another did document\n    if (role === DidDocumentRole.Created) {\n      await assertNoCreatedDidExistsForKeys(agentContext, didDocument.recipientKeys)\n    }\n\n    const peerDid = didDocumentJsonToNumAlgo1Did(didDocument.toJSON())\n    didDocument.id = peerDid\n    const didRecord = new DidRecord({\n      did: peerDid,\n      role,\n      didDocument,\n      keys: updatedKeys,\n    })\n\n    // Store the unqualified did with the legacy did document in the metadata\n    // Can be removed at a later stage if we know for sure we don't need it anymore\n    didRecord.metadata.set(DidRecordMetadataKeys.LegacyDid, {\n      unqualifiedDid: didDoc.id,\n      didDocumentString: JsonTransformer.serialize(didDoc),\n    })\n\n    this.logger.debug('Saving DID record', {\n      id: didRecord.id,\n      did: didRecord.did,\n      role: didRecord.role,\n      tags: didRecord.getTags(),\n      didDocument: 'omitted...',\n    })\n\n    await this.didRepository.save(agentContext, didRecord)\n    this.logger.debug('Did record created.', didRecord)\n    return { did: peerDid, didDocument }\n  }\n\n  private createDidDoc(routing: DidCommRouting) {\n    const recipientKeyBase58 = TypedArrayEncoder.toBase58(routing.recipientKey.publicKey.publicKey)\n    const indyDid = utils.indyDidFromPublicKeyBase58(recipientKeyBase58)\n\n    const keys: DidDocumentKey[] = [\n      {\n        didDocumentRelativeKeyId: '#1',\n        kmsKeyId: routing.recipientKey.keyId,\n      },\n    ]\n\n    const publicKey = new Ed25119Sig2018({\n      id: `${indyDid}#1`,\n      controller: indyDid,\n      publicKeyBase58: recipientKeyBase58,\n    })\n\n    const auth = new ReferencedAuthentication(publicKey, authenticationTypes.Ed25519VerificationKey2018)\n\n    // IndyAgentService is old service type\n    const services = routing.endpoints.map(\n      (endpoint, index) =>\n        new IndyAgentService({\n          id: `${indyDid}#IndyAgentService-${index + 1}`,\n          serviceEndpoint: endpoint,\n          recipientKeys: [recipientKeyBase58],\n          routingKeys: routing.routingKeys.map((key) => TypedArrayEncoder.toBase58(key.publicKey.publicKey)),\n          // Order of endpoint determines priority\n          priority: index,\n        })\n    )\n\n    return {\n      didDoc: new DidDoc({\n        id: indyDid,\n        authentication: [auth],\n        service: services,\n        publicKey: [publicKey],\n      }),\n      keys,\n    }\n  }\n\n  private createDidDocFromOutOfBandDidCommServices(outOfBandRecord: DidCommOutOfBandRecord) {\n    const services = outOfBandRecord.outOfBandInvitation\n      .getInlineServices()\n      .map((service) => getResolvedDidcommServiceWithSigningKeyId(service, outOfBandRecord.invitationInlineServiceKeys))\n\n    const [recipientKey] = services[0].recipientKeys\n    const recipientKeyBase58 = TypedArrayEncoder.toBase58(recipientKey.publicKey.publicKey)\n    const did = utils.indyDidFromPublicKeyBase58(recipientKeyBase58)\n\n    const publicKey = new Ed25119Sig2018({\n      id: `${did}#1`,\n      controller: did,\n      publicKeyBase58: recipientKeyBase58,\n    })\n\n    const auth = new ReferencedAuthentication(publicKey, authenticationTypes.Ed25519VerificationKey2018)\n\n    // IndyAgentService is old service type\n    const service = services.map(\n      (service, index) =>\n        new IndyAgentService({\n          id: `${did}#IndyAgentService-${index + 1}`,\n          serviceEndpoint: service.serviceEndpoint,\n          recipientKeys: [recipientKeyBase58],\n          routingKeys: service.routingKeys?.map((publicJwk) =>\n            TypedArrayEncoder.toBase58(publicJwk.publicKey.publicKey)\n          ),\n          priority: index,\n        })\n    )\n\n    return {\n      didDoc: new DidDoc({\n        id: did,\n        authentication: [auth],\n        service,\n        publicKey: [publicKey],\n      }),\n      keys: [{ didDocumentRelativeKeyId: '#1', kmsKeyId: recipientKey.keyId }] satisfies DidDocumentKey[],\n    }\n  }\n\n  public async returnWhenIsConnected(\n    agentContext: AgentContext,\n    connectionId: string,\n    timeoutMs = 20000\n  ): Promise<DidCommConnectionRecord> {\n    const isConnected = (connection: DidCommConnectionRecord) => {\n      return connection.id === connectionId && connection.state === DidCommDidExchangeState.Completed\n    }\n\n    const observable = this.eventEmitter.observable<DidCommConnectionStateChangedEvent>(\n      DidCommConnectionEventTypes.DidCommConnectionStateChanged\n    )\n    const subject = new ReplaySubject<DidCommConnectionRecord>(1)\n\n    observable\n      .pipe(\n        filterContextCorrelationId(agentContext.contextCorrelationId),\n        map((e) => e.payload.connectionRecord),\n        first(isConnected), // Do not wait for longer than specified timeout\n        timeout({\n          first: timeoutMs,\n          meta: 'DidCommConnectionService.returnWhenIsConnected',\n        })\n      )\n      .subscribe(subject)\n\n    const connection = await this.getById(agentContext, connectionId)\n    if (isConnected(connection)) {\n      subject.next(connection)\n    }\n\n    return firstValueFrom(subject)\n  }\n}\n\nexport interface ConnectionProtocolMsgReturnType<MessageType extends DidCommMessage> {\n  message: MessageType\n  connectionRecord: DidCommConnectionRecord\n}\n"],"mappings":"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"}