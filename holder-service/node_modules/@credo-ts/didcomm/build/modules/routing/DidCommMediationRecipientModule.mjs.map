{"version":3,"file":"DidCommMediationRecipientModule.mjs","names":[],"sources":["../../../src/modules/routing/DidCommMediationRecipientModule.ts"],"sourcesContent":["import type { AgentContext, DependencyManager, Module } from '@credo-ts/core'\nimport { CredoError } from '@credo-ts/core'\nimport { DidCommFeatureRegistry } from '../../DidCommFeatureRegistry'\nimport { DidCommMessageHandlerRegistry } from '../../DidCommMessageHandlerRegistry'\nimport { DidCommProtocol } from '../../models'\nimport { DidCommConnectionsApi } from '../connections'\nimport { DidCommOutOfBandApi } from '../oob'\nimport { DidCommMediationRecipientApi } from './DidCommMediationRecipientApi'\nimport type { DidCommMediationRecipientModuleConfigOptions } from './DidCommMediationRecipientModuleConfig'\nimport { DidCommMediationRecipientModuleConfig } from './DidCommMediationRecipientModuleConfig'\nimport {\n  DidCommKeylistUpdateResponseHandler,\n  DidCommMediationDenyHandler,\n  DidCommMediationGrantHandler,\n} from './handlers'\nimport { DidCommMediationRole } from './models'\nimport { DidCommMediationRepository } from './repository'\nimport { DidCommMediationRecipientService, DidCommRoutingService } from './services'\n\nexport class DidCommMediationRecipientModule implements Module {\n  public readonly config: DidCommMediationRecipientModuleConfig\n  public readonly api = DidCommMediationRecipientApi\n\n  public constructor(config?: DidCommMediationRecipientModuleConfigOptions) {\n    this.config = new DidCommMediationRecipientModuleConfig(config)\n  }\n\n  /**\n   * Registers the dependencies of the mediator recipient module on the dependency manager.\n   */\n  public register(dependencyManager: DependencyManager) {\n    // Config\n    dependencyManager.registerInstance(DidCommMediationRecipientModuleConfig, this.config)\n\n    // Services\n    dependencyManager.registerSingleton(DidCommMediationRecipientService)\n    dependencyManager.registerSingleton(DidCommRoutingService)\n\n    // Repositories\n    dependencyManager.registerSingleton(DidCommMediationRepository)\n  }\n\n  public async initialize(agentContext: AgentContext): Promise<void> {\n    const featureRegistry = agentContext.dependencyManager.resolve(DidCommFeatureRegistry)\n    const messageHandlerRegistry = agentContext.resolve(DidCommMessageHandlerRegistry)\n    const mediationRecipientService = agentContext.resolve(DidCommMediationRecipientService)\n\n    messageHandlerRegistry.registerMessageHandler(new DidCommKeylistUpdateResponseHandler(mediationRecipientService))\n    messageHandlerRegistry.registerMessageHandler(new DidCommMediationGrantHandler(mediationRecipientService))\n    messageHandlerRegistry.registerMessageHandler(new DidCommMediationDenyHandler(mediationRecipientService))\n\n    featureRegistry.register(\n      new DidCommProtocol({\n        id: 'https://didcomm.org/coordinate-mediation/1.0',\n        roles: [DidCommMediationRole.Recipient],\n      })\n    )\n  }\n\n  public async onCloseContext(agentContext: AgentContext): Promise<void> {\n    // Q: Can we also just call stop for non-defult context?\n    if (!agentContext.isRootAgentContext) return\n\n    const mediationRecipientApi = agentContext.dependencyManager.resolve(DidCommMediationRecipientApi)\n    await mediationRecipientApi.stopMessagePickup()\n  }\n\n  public async onInitializeContext(agentContext: AgentContext): Promise<void> {\n    // We only support mediation config for the root agent context\n    if (!agentContext.isRootAgentContext) return\n\n    const mediationRecipientApi = agentContext.dependencyManager.resolve(DidCommMediationRecipientApi)\n\n    // Connect to mediator through provided invitation if provided in config\n    // Also requests mediation ans sets as default mediator\n    if (this.config.mediatorInvitationUrl) {\n      agentContext.config.logger.debug('Provision mediation with invitation', {\n        mediatorInvitationUrl: this.config.mediatorInvitationUrl,\n      })\n      const mediationConnection = await this.getMediationConnection(agentContext, this.config.mediatorInvitationUrl)\n      await mediationRecipientApi.provision(mediationConnection)\n    }\n\n    // Poll for messages from mediator\n    const defaultMediator = await mediationRecipientApi.findDefaultMediator()\n    if (defaultMediator) {\n      mediationRecipientApi.initiateMessagePickup(defaultMediator).catch((error) => {\n        agentContext.config.logger.warn(`Error initiating message pickup with mediator ${defaultMediator.id}`, {\n          error,\n        })\n      })\n    }\n  }\n\n  protected async getMediationConnection(agentContext: AgentContext, mediatorInvitationUrl: string) {\n    const oobApi = agentContext.dependencyManager.resolve(DidCommOutOfBandApi)\n    const connectionsApi = agentContext.dependencyManager.resolve(DidCommConnectionsApi)\n    const mediationRecipientApi = agentContext.dependencyManager.resolve(DidCommMediationRecipientApi)\n\n    const outOfBandInvitation = await oobApi.parseInvitation(mediatorInvitationUrl)\n    const outOfBandRecord = await oobApi.findByReceivedInvitationId(outOfBandInvitation.id)\n    const [connection] = outOfBandRecord ? await connectionsApi.findAllByOutOfBandId(outOfBandRecord.id) : []\n\n    if (!connection) {\n      agentContext.config.logger.debug('Mediation connection does not exist, creating connection')\n      // We don't want to use the current default mediator when connecting to another mediator\n      const routing = await mediationRecipientApi.getRouting({ useDefaultMediator: false })\n\n      agentContext.config.logger.debug('Routing created', routing)\n      const { connectionRecord: newConnection } = await oobApi.receiveInvitation(outOfBandInvitation, {\n        label: '',\n        routing,\n      })\n      agentContext.config.logger.debug('Mediation invitation processed', { outOfBandInvitation })\n\n      if (!newConnection) {\n        throw new CredoError('No connection record to provision mediation.')\n      }\n\n      return connectionsApi.returnWhenIsConnected(newConnection.id)\n    }\n\n    if (!connection.isReady) {\n      return connectionsApi.returnWhenIsConnected(connection.id)\n    }\n\n    return connection\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAmBA,IAAa,kCAAb,MAA+D;CAI7D,AAAO,YAAY,QAAuD;OAF1D,MAAM;AAGpB,OAAK,SAAS,IAAI,sCAAsC,OAAO;;;;;CAMjE,AAAO,SAAS,mBAAsC;AAEpD,oBAAkB,iBAAiB,uCAAuC,KAAK,OAAO;AAGtF,oBAAkB,kBAAkB,iCAAiC;AACrE,oBAAkB,kBAAkB,sBAAsB;AAG1D,oBAAkB,kBAAkB,2BAA2B;;CAGjE,MAAa,WAAW,cAA2C;EACjE,MAAM,kBAAkB,aAAa,kBAAkB,QAAQ,uBAAuB;EACtF,MAAM,yBAAyB,aAAa,QAAQ,8BAA8B;EAClF,MAAM,4BAA4B,aAAa,QAAQ,iCAAiC;AAExF,yBAAuB,uBAAuB,IAAI,oCAAoC,0BAA0B,CAAC;AACjH,yBAAuB,uBAAuB,IAAI,6BAA6B,0BAA0B,CAAC;AAC1G,yBAAuB,uBAAuB,IAAI,4BAA4B,0BAA0B,CAAC;AAEzG,kBAAgB,SACd,IAAI,gBAAgB;GAClB,IAAI;GACJ,OAAO,CAAC,qBAAqB,UAAU;GACxC,CAAC,CACH;;CAGH,MAAa,eAAe,cAA2C;AAErE,MAAI,CAAC,aAAa,mBAAoB;AAGtC,QAD8B,aAAa,kBAAkB,QAAQ,6BAA6B,CACtE,mBAAmB;;CAGjD,MAAa,oBAAoB,cAA2C;AAE1E,MAAI,CAAC,aAAa,mBAAoB;EAEtC,MAAM,wBAAwB,aAAa,kBAAkB,QAAQ,6BAA6B;AAIlG,MAAI,KAAK,OAAO,uBAAuB;AACrC,gBAAa,OAAO,OAAO,MAAM,uCAAuC,EACtE,uBAAuB,KAAK,OAAO,uBACpC,CAAC;GACF,MAAM,sBAAsB,MAAM,KAAK,uBAAuB,cAAc,KAAK,OAAO,sBAAsB;AAC9G,SAAM,sBAAsB,UAAU,oBAAoB;;EAI5D,MAAM,kBAAkB,MAAM,sBAAsB,qBAAqB;AACzE,MAAI,gBACF,uBAAsB,sBAAsB,gBAAgB,CAAC,OAAO,UAAU;AAC5E,gBAAa,OAAO,OAAO,KAAK,iDAAiD,gBAAgB,MAAM,EACrG,OACD,CAAC;IACF;;CAIN,MAAgB,uBAAuB,cAA4B,uBAA+B;EAChG,MAAM,SAAS,aAAa,kBAAkB,QAAQ,oBAAoB;EAC1E,MAAM,iBAAiB,aAAa,kBAAkB,QAAQ,sBAAsB;EACpF,MAAM,wBAAwB,aAAa,kBAAkB,QAAQ,6BAA6B;EAElG,MAAM,sBAAsB,MAAM,OAAO,gBAAgB,sBAAsB;EAC/E,MAAM,kBAAkB,MAAM,OAAO,2BAA2B,oBAAoB,GAAG;EACvF,MAAM,CAAC,cAAc,kBAAkB,MAAM,eAAe,qBAAqB,gBAAgB,GAAG,GAAG,EAAE;AAEzG,MAAI,CAAC,YAAY;AACf,gBAAa,OAAO,OAAO,MAAM,2DAA2D;GAE5F,MAAM,UAAU,MAAM,sBAAsB,WAAW,EAAE,oBAAoB,OAAO,CAAC;AAErF,gBAAa,OAAO,OAAO,MAAM,mBAAmB,QAAQ;GAC5D,MAAM,EAAE,kBAAkB,kBAAkB,MAAM,OAAO,kBAAkB,qBAAqB;IAC9F,OAAO;IACP;IACD,CAAC;AACF,gBAAa,OAAO,OAAO,MAAM,kCAAkC,EAAE,qBAAqB,CAAC;AAE3F,OAAI,CAAC,cACH,OAAM,IAAI,WAAW,+CAA+C;AAGtE,UAAO,eAAe,sBAAsB,cAAc,GAAG;;AAG/D,MAAI,CAAC,WAAW,QACd,QAAO,eAAe,sBAAsB,WAAW,GAAG;AAG5D,SAAO"}