{"version":3,"file":"DidCommMediatorService.mjs","names":[],"sources":["../../../../src/modules/routing/services/DidCommMediatorService.ts"],"sourcesContent":["import type { AgentContext, Query, QueryOptions } from '@credo-ts/core'\nimport {\n  CredoError,\n  DidKey,\n  didKeyToVerkey,\n  EventEmitter,\n  InjectionSymbols,\n  inject,\n  injectable,\n  isDidKey,\n  Kms,\n  type Logger,\n  RecordDuplicateError,\n  TypedArrayEncoder,\n  verkeyToDidKey,\n} from '@credo-ts/core'\nimport { DidCommMessageSender } from '../../../DidCommMessageSender'\nimport { DidCommModuleConfig } from '../../../DidCommModuleConfig'\nimport type { DidCommInboundMessageContext } from '../../../models'\nimport type { DidCommConnectionRecord } from '../../connections/repository'\nimport { DidCommConnectionMetadataKeys } from '../../connections/repository/DidCommConnectionMetadataTypes'\nimport { DidCommConnectionService } from '../../connections/services'\nimport { DidCommMessagePickupApi } from '../../message-pickup'\nimport { DidCommMessagePickupSessionRole } from '../../message-pickup/DidCommMessagePickupSession'\nimport { DidCommMediatorModuleConfig } from '../DidCommMediatorModuleConfig'\nimport { DidCommMessageForwardingStrategy } from '../DidCommMessageForwardingStrategy'\nimport type { DidCommMediationStateChangedEvent } from '../DidCommRoutingEvents'\nimport { DidCommRoutingEventTypes } from '../DidCommRoutingEvents'\nimport type { DidCommForwardMessage, DidCommMediationRequestMessage } from '../messages'\nimport {\n  DidCommKeylistUpdateAction,\n  DidCommKeylistUpdated,\n  DidCommKeylistUpdateMessage,\n  DidCommKeylistUpdateResponseMessage,\n  DidCommKeylistUpdateResult,\n  DidCommMediationGrantMessage,\n} from '../messages'\nimport { DidCommMediationRole } from '../models/DidCommMediationRole'\nimport { DidCommMediationState } from '../models/DidCommMediationState'\nimport { DidCommMediatorRoutingRecord } from '../repository'\nimport { DidCommMediationRecord } from '../repository/DidCommMediationRecord'\nimport { DidCommMediationRepository } from '../repository/DidCommMediationRepository'\nimport { DidCommMediatorRoutingRepository } from '../repository/DidCommMediatorRoutingRepository'\n\n@injectable()\nexport class DidCommMediatorService {\n  private logger: Logger\n  private mediationRepository: DidCommMediationRepository\n  private mediatorRoutingRepository: DidCommMediatorRoutingRepository\n  private eventEmitter: EventEmitter\n  private connectionService: DidCommConnectionService\n\n  public constructor(\n    mediationRepository: DidCommMediationRepository,\n    mediatorRoutingRepository: DidCommMediatorRoutingRepository,\n    eventEmitter: EventEmitter,\n    @inject(InjectionSymbols.Logger) logger: Logger,\n    connectionService: DidCommConnectionService\n  ) {\n    this.mediationRepository = mediationRepository\n    this.mediatorRoutingRepository = mediatorRoutingRepository\n    this.eventEmitter = eventEmitter\n    this.logger = logger\n    this.connectionService = connectionService\n  }\n\n  private async getRoutingKeys(agentContext: AgentContext) {\n    const mediatorRoutingRecord = await this.findMediatorRoutingRecord(agentContext)\n\n    if (mediatorRoutingRecord) {\n      // Return the routing keys\n      this.logger.debug(`Returning mediator routing keys ${mediatorRoutingRecord.routingKeys}`)\n      return mediatorRoutingRecord.routingKeysWithKeyId\n    }\n\n    throw new CredoError('Mediator has not been initialized yet.')\n  }\n\n  public async processForwardMessage(\n    messageContext: DidCommInboundMessageContext<DidCommForwardMessage>\n  ): Promise<void> {\n    const { message, agentContext } = messageContext\n\n    const messagePickupApi = agentContext.resolve(DidCommMessagePickupApi)\n\n    // TODO: update to class-validator validation\n    if (!message.to) {\n      throw new CredoError('Invalid Message: Missing required attribute \"to\"')\n    }\n\n    const mediationRecord = await this.mediationRepository.getSingleByRecipientKey(agentContext, message.to)\n\n    // Assert mediation record is ready to be used\n    mediationRecord.assertReady()\n    mediationRecord.assertRole(DidCommMediationRole.Mediator)\n\n    const connection = await this.connectionService.getById(agentContext, mediationRecord.connectionId)\n    connection.assertReady()\n\n    const messageForwardingStrategy =\n      agentContext.dependencyManager.resolve(DidCommMediatorModuleConfig).messageForwardingStrategy\n    const messageSender = agentContext.dependencyManager.resolve(DidCommMessageSender)\n\n    switch (messageForwardingStrategy) {\n      case DidCommMessageForwardingStrategy.QueueOnly:\n        await messagePickupApi.queueMessage({\n          connectionId: mediationRecord.connectionId,\n          recipientDids: [verkeyToDidKey(message.to)],\n          message: message.message,\n        })\n        break\n      case DidCommMessageForwardingStrategy.QueueAndLiveModeDelivery: {\n        await messagePickupApi.queueMessage({\n          connectionId: mediationRecord.connectionId,\n          recipientDids: [verkeyToDidKey(message.to)],\n          message: message.message,\n        })\n        const session = await messagePickupApi.getLiveModeSession({\n          connectionId: mediationRecord.connectionId,\n          role: DidCommMessagePickupSessionRole.MessageHolder,\n        })\n        if (session) {\n          await messagePickupApi.deliverMessagesFromQueue({\n            pickupSessionId: session.id,\n            recipientDid: verkeyToDidKey(message.to),\n          })\n        }\n        break\n      }\n      case DidCommMessageForwardingStrategy.DirectDelivery:\n        // The message inside the forward message is packed so we just send the packed\n        // message to the connection associated with it\n        await messageSender.sendPackage(agentContext, {\n          connection,\n          recipientKey: verkeyToDidKey(message.to),\n          encryptedMessage: message.message,\n        })\n    }\n  }\n\n  public async processKeylistUpdateRequest(messageContext: DidCommInboundMessageContext<DidCommKeylistUpdateMessage>) {\n    // Assert Ready connection\n    const connection = messageContext.assertReadyConnection()\n\n    const { message } = messageContext\n    const keylist: DidCommKeylistUpdated[] = []\n\n    const mediationRecord = await this.mediationRepository.getByConnectionId(messageContext.agentContext, connection.id)\n\n    mediationRecord.assertReady()\n    mediationRecord.assertRole(DidCommMediationRole.Mediator)\n\n    // Update connection metadata to use their key format in further protocol messages\n    const connectionUsesDidKey = message.updates.some((update) => isDidKey(update.recipientKey))\n    await this.updateUseDidKeysFlag(\n      messageContext.agentContext,\n      connection,\n      DidCommKeylistUpdateMessage.type.protocolUri,\n      connectionUsesDidKey\n    )\n\n    for (const update of message.updates) {\n      const updated = new DidCommKeylistUpdated({\n        action: update.action,\n        recipientKey: update.recipientKey,\n        result: DidCommKeylistUpdateResult.NoChange,\n      })\n\n      // According to RFC 0211 key should be a did key, but base58 encoded verkey was used before\n      // RFC was accepted. This converts the key to a public key base58 if it is a did key.\n      const publicKeyBase58 = didKeyToVerkey(update.recipientKey)\n\n      if (update.action === DidCommKeylistUpdateAction.add) {\n        mediationRecord.addRecipientKey(publicKeyBase58)\n        updated.result = DidCommKeylistUpdateResult.Success\n\n        keylist.push(updated)\n      } else if (update.action === DidCommKeylistUpdateAction.remove) {\n        const success = mediationRecord.removeRecipientKey(publicKeyBase58)\n        updated.result = success ? DidCommKeylistUpdateResult.Success : DidCommKeylistUpdateResult.NoChange\n        keylist.push(updated)\n      }\n    }\n\n    await this.mediationRepository.update(messageContext.agentContext, mediationRecord)\n\n    return new DidCommKeylistUpdateResponseMessage({ keylist, threadId: message.threadId })\n  }\n\n  public async createGrantMediationMessage(agentContext: AgentContext, mediationRecord: DidCommMediationRecord) {\n    // Assert\n    mediationRecord.assertState(DidCommMediationState.Requested)\n    mediationRecord.assertRole(DidCommMediationRole.Mediator)\n\n    await this.updateState(agentContext, mediationRecord, DidCommMediationState.Granted)\n\n    // Use our useDidKey configuration, as this is the first interaction for this protocol\n    const didcommConfig = agentContext.dependencyManager.resolve(DidCommModuleConfig)\n    const useDidKey = didcommConfig.useDidKeyInProtocols\n\n    const routingKeys = (await this.getRoutingKeys(agentContext)).map((routingKey) =>\n      useDidKey ? new DidKey(routingKey).did : TypedArrayEncoder.toBase58(routingKey.publicKey.publicKey)\n    )\n\n    const message = new DidCommMediationGrantMessage({\n      endpoint: didcommConfig.endpoints[0],\n      routingKeys,\n      threadId: mediationRecord.threadId,\n    })\n\n    return { mediationRecord, message }\n  }\n\n  public async processMediationRequest(messageContext: DidCommInboundMessageContext<DidCommMediationRequestMessage>) {\n    // Assert ready connection\n    const connection = messageContext.assertReadyConnection()\n\n    const mediationRecord = new DidCommMediationRecord({\n      connectionId: connection.id,\n      role: DidCommMediationRole.Mediator,\n      state: DidCommMediationState.Requested,\n      threadId: messageContext.message.threadId,\n    })\n\n    await this.mediationRepository.save(messageContext.agentContext, mediationRecord)\n    this.emitStateChangedEvent(messageContext.agentContext, mediationRecord, null)\n\n    return mediationRecord\n  }\n\n  public async findById(agentContext: AgentContext, mediatorRecordId: string): Promise<DidCommMediationRecord | null> {\n    return this.mediationRepository.findById(agentContext, mediatorRecordId)\n  }\n\n  public async getById(agentContext: AgentContext, mediatorRecordId: string): Promise<DidCommMediationRecord> {\n    return this.mediationRepository.getById(agentContext, mediatorRecordId)\n  }\n\n  public async getAll(agentContext: AgentContext): Promise<DidCommMediationRecord[]> {\n    return await this.mediationRepository.getAll(agentContext)\n  }\n\n  public async findMediatorRoutingRecord(agentContext: AgentContext): Promise<DidCommMediatorRoutingRecord | null> {\n    const routingRecord = await this.mediatorRoutingRepository.findById(\n      agentContext,\n      this.mediatorRoutingRepository.MEDIATOR_ROUTING_RECORD_ID\n    )\n\n    return routingRecord\n  }\n\n  public async createMediatorRoutingRecord(agentContext: AgentContext): Promise<DidCommMediatorRoutingRecord | null> {\n    const kms = agentContext.resolve(Kms.KeyManagementApi)\n    const didcommConfig = agentContext.resolve(DidCommModuleConfig)\n\n    const routingKey = await kms.createKey({\n      type: {\n        kty: 'OKP',\n        crv: 'Ed25519',\n      },\n    })\n    const publicJwk = Kms.PublicJwk.fromPublicJwk(routingKey.publicJwk)\n\n    const routingRecord = new DidCommMediatorRoutingRecord({\n      id: this.mediatorRoutingRepository.MEDIATOR_ROUTING_RECORD_ID,\n      routingKeys: [\n        {\n          routingKeyFingerprint: publicJwk.fingerprint,\n          kmsKeyId: routingKey.keyId,\n        },\n      ],\n    })\n\n    try {\n      await this.mediatorRoutingRepository.save(agentContext, routingRecord)\n      this.eventEmitter.emit(agentContext, {\n        type: DidCommRoutingEventTypes.RoutingCreatedEvent,\n        payload: {\n          routing: {\n            endpoints: didcommConfig.endpoints,\n            routingKeys: [],\n            recipientKey: routingKey,\n          },\n        },\n      })\n    } catch (error) {\n      // This addresses some race conditions issues where we first check if the record exists\n      // then we create one if it doesn't, but another process has created one in the meantime\n      // Although not the most elegant solution, it addresses the issues\n      if (error instanceof RecordDuplicateError) {\n        // the record already exists, which is our intended end state\n        // we can ignore this error and fetch the existing record\n        return this.mediatorRoutingRepository.getById(\n          agentContext,\n          this.mediatorRoutingRepository.MEDIATOR_ROUTING_RECORD_ID\n        )\n      }\n      throw error\n    }\n\n    return routingRecord\n  }\n\n  public async findAllByQuery(\n    agentContext: AgentContext,\n    query: Query<DidCommMediationRecord>,\n    queryOptions?: QueryOptions\n  ): Promise<DidCommMediationRecord[]> {\n    return await this.mediationRepository.findByQuery(agentContext, query, queryOptions)\n  }\n\n  private async updateState(\n    agentContext: AgentContext,\n    mediationRecord: DidCommMediationRecord,\n    newState: DidCommMediationState\n  ) {\n    const previousState = mediationRecord.state\n\n    mediationRecord.state = newState\n\n    await this.mediationRepository.update(agentContext, mediationRecord)\n\n    this.emitStateChangedEvent(agentContext, mediationRecord, previousState)\n  }\n\n  private emitStateChangedEvent(\n    agentContext: AgentContext,\n    mediationRecord: DidCommMediationRecord,\n    previousState: DidCommMediationState | null\n  ) {\n    this.eventEmitter.emit<DidCommMediationStateChangedEvent>(agentContext, {\n      type: DidCommRoutingEventTypes.MediationStateChanged,\n      payload: {\n        mediationRecord: mediationRecord.clone(),\n        previousState,\n      },\n    })\n  }\n\n  private async updateUseDidKeysFlag(\n    agentContext: AgentContext,\n    connection: DidCommConnectionRecord,\n    protocolUri: string,\n    connectionUsesDidKey: boolean\n  ) {\n    const useDidKeysForProtocol = connection.metadata.get(DidCommConnectionMetadataKeys.UseDidKeysForProtocol) ?? {}\n    useDidKeysForProtocol[protocolUri] = connectionUsesDidKey\n    connection.metadata.set(DidCommConnectionMetadataKeys.UseDidKeysForProtocol, useDidKeysForProtocol)\n    await this.connectionService.update(agentContext, connection)\n  }\n}\n"],"mappings":"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"}