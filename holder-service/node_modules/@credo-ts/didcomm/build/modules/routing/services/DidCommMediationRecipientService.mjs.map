{"version":3,"file":"DidCommMediationRecipientService.mjs","names":["filter","first","timeout"],"sources":["../../../../src/modules/routing/services/DidCommMediationRecipientService.ts"],"sourcesContent":["import {\n  AgentContext,\n  CredoError,\n  DidKey,\n  didKeyToVerkey,\n  EventEmitter,\n  filterContextCorrelationId,\n  injectable,\n  isDidKey,\n  Kms,\n  type Query,\n  type QueryOptions,\n  TypedArrayEncoder,\n} from '@credo-ts/core'\nimport { firstValueFrom, ReplaySubject } from 'rxjs'\nimport { filter, first, timeout } from 'rxjs/operators'\nimport type { DidCommMessage } from '../../../DidCommMessage'\nimport { DidCommMessageSender } from '../../../DidCommMessageSender'\nimport { DidCommModuleConfig } from '../../../DidCommModuleConfig'\nimport type { DidCommInboundMessageContext, DidCommRouting } from '../../../models'\nimport { DidCommOutboundMessageContext } from '../../../models'\nimport { DidCommConnectionType } from '../../connections/models/DidCommConnectionType'\nimport type { DidCommConnectionRecord } from '../../connections/repository'\nimport { DidCommConnectionMetadataKeys } from '../../connections/repository/DidCommConnectionMetadataTypes'\nimport { DidCommConnectionService } from '../../connections/services/DidCommConnectionService'\nimport type { DidCommKeylistUpdatedEvent, DidCommMediationStateChangedEvent } from '../DidCommRoutingEvents'\nimport { DidCommRoutingEventTypes } from '../DidCommRoutingEvents'\nimport type { DidCommMediationDenyMessage } from '../messages'\nimport {\n  DidCommKeylistUpdateAction,\n  DidCommKeylistUpdateResponseMessage,\n  DidCommMediationGrantMessage,\n  DidCommMediationRequestMessage,\n} from '../messages'\nimport { DidCommKeylistUpdate, DidCommKeylistUpdateMessage } from '../messages/DidCommKeylistUpdateMessage'\nimport { DidCommMediationRole, DidCommMediationState } from '../models'\nimport { DidCommMediationRecord } from '../repository/DidCommMediationRecord'\nimport { DidCommMediationRepository } from '../repository/DidCommMediationRepository'\nimport type { GetRoutingOptions, RemoveRoutingOptions } from './DidCommRoutingService'\n\n@injectable()\nexport class DidCommMediationRecipientService {\n  private mediationRepository: DidCommMediationRepository\n  private eventEmitter: EventEmitter\n  private connectionService: DidCommConnectionService\n  private messageSender: DidCommMessageSender\n\n  public constructor(\n    connectionService: DidCommConnectionService,\n    messageSender: DidCommMessageSender,\n    mediatorRepository: DidCommMediationRepository,\n    eventEmitter: EventEmitter\n  ) {\n    this.mediationRepository = mediatorRepository\n    this.eventEmitter = eventEmitter\n    this.connectionService = connectionService\n    this.messageSender = messageSender\n  }\n\n  public async createRequest(\n    agentContext: AgentContext,\n    connection: DidCommConnectionRecord\n  ): Promise<MediationProtocolMsgReturnType<DidCommMediationRequestMessage>> {\n    const message = new DidCommMediationRequestMessage({})\n\n    const mediationRecord = new DidCommMediationRecord({\n      threadId: message.threadId,\n      state: DidCommMediationState.Requested,\n      role: DidCommMediationRole.Recipient,\n      connectionId: connection.id,\n    })\n\n    await this.connectionService.addConnectionType(agentContext, connection, DidCommConnectionType.Mediator)\n\n    await this.mediationRepository.save(agentContext, mediationRecord)\n    this.emitStateChangedEvent(agentContext, mediationRecord, null)\n\n    return { mediationRecord, message }\n  }\n\n  public async processMediationGrant(messageContext: DidCommInboundMessageContext<DidCommMediationGrantMessage>) {\n    // Assert ready connection\n    const connection = messageContext.assertReadyConnection()\n\n    // Mediation record must already exists to be updated to granted status\n    const mediationRecord = await this.mediationRepository.getByConnectionId(messageContext.agentContext, connection.id)\n\n    // Assert\n    mediationRecord.assertState(DidCommMediationState.Requested)\n    mediationRecord.assertRole(DidCommMediationRole.Recipient)\n\n    // Update record\n    mediationRecord.endpoint = messageContext.message.endpoint\n\n    // Update connection metadata to use their key format in further protocol messages\n    const connectionUsesDidKey = messageContext.message.routingKeys.some(isDidKey)\n    await this.updateUseDidKeysFlag(\n      messageContext.agentContext,\n      connection,\n      DidCommMediationGrantMessage.type.protocolUri,\n      connectionUsesDidKey\n    )\n\n    // According to RFC 0211 keys should be a did key, but base58 encoded verkey was used before\n    // RFC was accepted. This converts the key to a public key base58 if it is a did key.\n    mediationRecord.routingKeys = messageContext.message.routingKeys.map(didKeyToVerkey)\n    return await this.updateState(messageContext.agentContext, mediationRecord, DidCommMediationState.Granted)\n  }\n\n  public async processKeylistUpdateResults(\n    messageContext: DidCommInboundMessageContext<DidCommKeylistUpdateResponseMessage>\n  ) {\n    // Assert ready connection\n    const connection = messageContext.assertReadyConnection()\n\n    const mediationRecord = await this.mediationRepository.getByConnectionId(messageContext.agentContext, connection.id)\n\n    // Assert\n    mediationRecord.assertReady()\n    mediationRecord.assertRole(DidCommMediationRole.Recipient)\n\n    const keylist = messageContext.message.updated\n\n    // Update connection metadata to use their key format in further protocol messages\n    const connectionUsesDidKey = keylist.some((key) => isDidKey(key.recipientKey))\n    await this.updateUseDidKeysFlag(\n      messageContext.agentContext,\n      connection,\n      DidCommKeylistUpdateResponseMessage.type.protocolUri,\n      connectionUsesDidKey\n    )\n\n    // update keylist in mediationRecord\n    for (const update of keylist) {\n      if (update.action === DidCommKeylistUpdateAction.add) {\n        mediationRecord.addRecipientKey(didKeyToVerkey(update.recipientKey))\n      } else if (update.action === DidCommKeylistUpdateAction.remove) {\n        mediationRecord.removeRecipientKey(didKeyToVerkey(update.recipientKey))\n      }\n    }\n\n    await this.mediationRepository.update(messageContext.agentContext, mediationRecord)\n    this.eventEmitter.emit<DidCommKeylistUpdatedEvent>(messageContext.agentContext, {\n      type: DidCommRoutingEventTypes.RecipientKeylistUpdated,\n      payload: {\n        mediationRecord,\n        keylist,\n      },\n    })\n  }\n\n  public async keylistUpdateAndAwait(\n    agentContext: AgentContext,\n    mediationRecord: DidCommMediationRecord,\n    updates: { recipientKey: Kms.PublicJwk<Kms.Ed25519PublicJwk>; action: DidCommKeylistUpdateAction }[],\n    timeoutMs = 15000 // TODO: this should be a configurable value in agent config\n  ): Promise<DidCommMediationRecord> {\n    const connection = await this.connectionService.getById(agentContext, mediationRecord.connectionId)\n\n    // Use our useDidKey configuration unless we know the key formatting other party is using\n    const didcommConfig = agentContext.dependencyManager.resolve(DidCommModuleConfig)\n\n    let useDidKey = didcommConfig.useDidKeyInProtocols\n\n    const useDidKeysConnectionMetadata = connection.metadata.get(DidCommConnectionMetadataKeys.UseDidKeysForProtocol)\n    if (useDidKeysConnectionMetadata) {\n      useDidKey = useDidKeysConnectionMetadata[DidCommKeylistUpdateMessage.type.protocolUri] ?? useDidKey\n    }\n\n    const message = this.createKeylistUpdateMessage(\n      updates.map(\n        (item) =>\n          new DidCommKeylistUpdate({\n            action: item.action,\n            recipientKey: useDidKey\n              ? new DidKey(item.recipientKey).did\n              : TypedArrayEncoder.toBase58(item.recipientKey.publicKey.publicKey),\n          })\n      )\n    )\n\n    mediationRecord.assertReady()\n    mediationRecord.assertRole(DidCommMediationRole.Recipient)\n\n    // Create observable for event\n    const observable = this.eventEmitter.observable<DidCommKeylistUpdatedEvent>(\n      DidCommRoutingEventTypes.RecipientKeylistUpdated\n    )\n    const subject = new ReplaySubject<DidCommKeylistUpdatedEvent>(1)\n\n    // Apply required filters to observable stream and create promise to subscribe to observable\n    observable\n      .pipe(\n        filterContextCorrelationId(agentContext.contextCorrelationId),\n        // Only take event for current mediation record\n        filter((event) => mediationRecord.id === event.payload.mediationRecord.id),\n        // Only wait for first event that matches the criteria\n        first(),\n        // Do not wait for longer than specified timeout\n        timeout({\n          first: timeoutMs,\n          meta: 'DidCommMediationRecipientService.keylistUpdateAndAwait',\n        })\n      )\n      .subscribe(subject)\n\n    const outboundMessageContext = new DidCommOutboundMessageContext(message, { agentContext, connection })\n    await this.messageSender.sendMessage(outboundMessageContext)\n\n    const keylistUpdate = await firstValueFrom(subject)\n    return keylistUpdate.payload.mediationRecord\n  }\n\n  public createKeylistUpdateMessage(updates: DidCommKeylistUpdate[]): DidCommKeylistUpdateMessage {\n    const keylistUpdateMessage = new DidCommKeylistUpdateMessage({\n      updates,\n    })\n    return keylistUpdateMessage\n  }\n\n  public async addMediationRouting(\n    agentContext: AgentContext,\n    routing: DidCommRouting,\n    { mediatorId, useDefaultMediator = true }: GetRoutingOptions = {}\n  ): Promise<DidCommRouting> {\n    let mediationRecord: DidCommMediationRecord | null = null\n\n    if (mediatorId) {\n      mediationRecord = await this.getById(agentContext, mediatorId)\n    } else if (useDefaultMediator) {\n      // If no mediatorId is provided, and useDefaultMediator is true (default)\n      // We use the default mediator if available\n      mediationRecord = await this.findDefaultMediator(agentContext)\n    }\n\n    // Return early if no mediation record\n    if (!mediationRecord) return routing\n\n    // new did has been created and mediator needs to be updated with the public key.\n    mediationRecord = await this.keylistUpdateAndAwait(agentContext, mediationRecord, [\n      {\n        recipientKey: routing.recipientKey,\n        action: DidCommKeylistUpdateAction.add,\n      },\n    ])\n\n    return {\n      ...routing,\n      mediatorId: mediationRecord.id,\n      endpoints: mediationRecord.endpoint ? [mediationRecord.endpoint] : routing.endpoints,\n      routingKeys: mediationRecord.routingKeys.map((key) =>\n        Kms.PublicJwk.fromPublicKey({ kty: 'OKP', crv: 'Ed25519', publicKey: TypedArrayEncoder.fromBase58(key) })\n      ),\n    }\n  }\n\n  public async removeMediationRouting(\n    agentContext: AgentContext,\n    { recipientKeys, mediatorId }: RemoveRoutingOptions\n  ): Promise<void> {\n    const mediationRecord = await this.getById(agentContext, mediatorId)\n\n    if (!mediationRecord) {\n      throw new CredoError('No mediation record to remove routing from has been found')\n    }\n\n    await this.keylistUpdateAndAwait(\n      agentContext,\n      mediationRecord,\n      recipientKeys.map((item) => {\n        return {\n          recipientKey: item,\n          action: DidCommKeylistUpdateAction.remove,\n        }\n      })\n    )\n  }\n\n  public async processMediationDeny(messageContext: DidCommInboundMessageContext<DidCommMediationDenyMessage>) {\n    const connection = messageContext.assertReadyConnection()\n\n    // Mediation record already exists\n    const mediationRecord = await this.findByConnectionId(messageContext.agentContext, connection.id)\n\n    if (!mediationRecord) {\n      throw new Error(`No mediation has been requested for this connection id: ${connection.id}`)\n    }\n\n    // Assert\n    mediationRecord.assertRole(DidCommMediationRole.Recipient)\n    mediationRecord.assertState(DidCommMediationState.Requested)\n\n    // Update record\n    await this.updateState(messageContext.agentContext, mediationRecord, DidCommMediationState.Denied)\n\n    return mediationRecord\n  }\n\n  /**\n   * Update the record to a new state and emit an state changed event. Also updates the record\n   * in storage.\n   *\n   * @param MediationRecord The proof record to update the state for\n   * @param newState The state to update to\n   *\n   */\n  private async updateState(\n    agentContext: AgentContext,\n    mediationRecord: DidCommMediationRecord,\n    newState: DidCommMediationState\n  ) {\n    const previousState = mediationRecord.state\n    mediationRecord.state = newState\n    await this.mediationRepository.update(agentContext, mediationRecord)\n\n    this.emitStateChangedEvent(agentContext, mediationRecord, previousState)\n    return mediationRecord\n  }\n\n  private emitStateChangedEvent(\n    agentContext: AgentContext,\n    mediationRecord: DidCommMediationRecord,\n    previousState: DidCommMediationState | null\n  ) {\n    this.eventEmitter.emit<DidCommMediationStateChangedEvent>(agentContext, {\n      type: DidCommRoutingEventTypes.MediationStateChanged,\n      payload: {\n        mediationRecord: mediationRecord.clone(),\n        previousState,\n      },\n    })\n  }\n\n  public async getById(agentContext: AgentContext, id: string): Promise<DidCommMediationRecord> {\n    return this.mediationRepository.getById(agentContext, id)\n  }\n\n  public async findByConnectionId(\n    agentContext: AgentContext,\n    connectionId: string\n  ): Promise<DidCommMediationRecord | null> {\n    return this.mediationRepository.findSingleByQuery(agentContext, { connectionId })\n  }\n\n  public async getMediators(agentContext: AgentContext): Promise<DidCommMediationRecord[]> {\n    return this.mediationRepository.getAll(agentContext)\n  }\n\n  public async findAllMediatorsByQuery(\n    agentContext: AgentContext,\n    query: Query<DidCommMediationRecord>,\n    queryOptions?: QueryOptions\n  ): Promise<DidCommMediationRecord[]> {\n    return await this.mediationRepository.findByQuery(agentContext, query, queryOptions)\n  }\n\n  public async findDefaultMediator(agentContext: AgentContext): Promise<DidCommMediationRecord | null> {\n    return this.mediationRepository.findSingleByQuery(agentContext, { default: true })\n  }\n\n  public async discoverMediation(\n    agentContext: AgentContext,\n    mediatorId?: string\n  ): Promise<DidCommMediationRecord | undefined> {\n    // If mediatorId is passed, always use it (and error if it is not found)\n    if (mediatorId) {\n      return this.mediationRepository.getById(agentContext, mediatorId)\n    }\n\n    const defaultMediator = await this.findDefaultMediator(agentContext)\n    if (defaultMediator) {\n      if (defaultMediator.state !== DidCommMediationState.Granted) {\n        throw new CredoError(\n          `Mediation State for ${defaultMediator.id} is not granted, but is set as default mediator!`\n        )\n      }\n\n      return defaultMediator\n    }\n  }\n\n  public async setDefaultMediator(agentContext: AgentContext, mediator: DidCommMediationRecord) {\n    const mediationRecords = await this.mediationRepository.findByQuery(agentContext, { default: true })\n\n    for (const record of mediationRecords) {\n      record.setTag('default', false)\n      await this.mediationRepository.update(agentContext, record)\n    }\n\n    // Set record coming in tag to true and then update.\n    mediator.setTag('default', true)\n    await this.mediationRepository.update(agentContext, mediator)\n  }\n\n  public async clearDefaultMediator(agentContext: AgentContext) {\n    const mediationRecord = await this.findDefaultMediator(agentContext)\n\n    if (mediationRecord) {\n      mediationRecord.setTag('default', false)\n      await this.mediationRepository.update(agentContext, mediationRecord)\n    }\n  }\n\n  private async updateUseDidKeysFlag(\n    agentContext: AgentContext,\n    connection: DidCommConnectionRecord,\n    protocolUri: string,\n    connectionUsesDidKey: boolean\n  ) {\n    const useDidKeysForProtocol = connection.metadata.get(DidCommConnectionMetadataKeys.UseDidKeysForProtocol) ?? {}\n    useDidKeysForProtocol[protocolUri] = connectionUsesDidKey\n    connection.metadata.set(DidCommConnectionMetadataKeys.UseDidKeysForProtocol, useDidKeysForProtocol)\n    await this.connectionService.update(agentContext, connection)\n  }\n}\n\nexport interface MediationProtocolMsgReturnType<MessageType extends DidCommMessage> {\n  message: MessageType\n  mediationRecord: DidCommMediationRecord\n}\n"],"mappings":"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"}