{"version":3,"file":"DidCommMediationRecipientApi.mjs","names":["takeUntil","filter","interval","first","timeout"],"sources":["../../../src/modules/routing/DidCommMediationRecipientApi.ts"],"sourcesContent":["import {\n  AgentContext,\n  CredoError,\n  DidDocument,\n  DidsApi,\n  EventEmitter,\n  filterContextCorrelationId,\n  InjectionSymbols,\n  inject,\n  injectable,\n  type Logger,\n  verkeyToDidKey,\n} from '@credo-ts/core'\nimport { firstValueFrom, interval, merge, ReplaySubject, Subject, timer } from 'rxjs'\nimport { delayWhen, filter, first, takeUntil, tap, throttleTime, timeout } from 'rxjs/operators'\nimport { DidCommMessageSender } from '../../DidCommMessageSender'\nimport { DidCommModuleConfig } from '../../DidCommModuleConfig'\nimport { DidCommOutboundMessageContext } from '../../models'\nimport type { DidCommOutboundWebSocketClosedEvent, DidCommOutboundWebSocketOpenedEvent } from '../../transport'\nimport { DidCommTransportEventTypes } from '../../transport'\nimport type { DidCommConnectionRecord } from '../connections/repository'\nimport { DidCommConnectionMetadataKeys } from '../connections/repository/DidCommConnectionMetadataTypes'\nimport { DidCommConnectionService } from '../connections/services'\nimport { DidCommDiscoverFeaturesApi } from '../discover-features'\nimport { DidCommMessagePickupApi } from '../message-pickup/DidCommMessagePickupApi'\nimport { DidCommBatchPickupMessage } from '../message-pickup/protocol/v1'\nimport { DidCommStatusV2Message } from '../message-pickup/protocol/v2'\nimport { DidCommMediationRecipientModuleConfig } from './DidCommMediationRecipientModuleConfig'\nimport { DidCommMediatorPickupStrategy } from './DidCommMediatorPickupStrategy'\nimport type { DidCommMediationStateChangedEvent } from './DidCommRoutingEvents'\nimport { DidCommRoutingEventTypes } from './DidCommRoutingEvents'\nimport { DidCommKeylistUpdate, DidCommKeylistUpdateAction, DidCommKeylistUpdateMessage } from './messages'\nimport { DidCommMediationState } from './models/DidCommMediationState'\nimport type { DidCommMediationRecord } from './repository'\nimport { DidCommMediationRepository } from './repository'\nimport { DidCommMediationRecipientService } from './services/DidCommMediationRecipientService'\nimport type { GetRoutingOptions } from './services/DidCommRoutingService'\nimport { DidCommRoutingService } from './services/DidCommRoutingService'\n\n@injectable()\nexport class DidCommMediationRecipientApi {\n  public config: DidCommMediationRecipientModuleConfig\n\n  private mediationRecipientService: DidCommMediationRecipientService\n  private connectionService: DidCommConnectionService\n  private dids: DidsApi\n  private messageSender: DidCommMessageSender\n  private eventEmitter: EventEmitter\n  private logger: Logger\n  private discoverFeaturesApi: DidCommDiscoverFeaturesApi\n  private messagePickupApi: DidCommMessagePickupApi\n  private mediationRepository: DidCommMediationRepository\n  private routingService: DidCommRoutingService\n  private agentContext: AgentContext\n  private stop$: Subject<boolean>\n\n  // stopMessagePickup$ is used for stop message pickup signal\n  private readonly stopMessagePickup$ = new Subject<boolean>()\n\n  public constructor(\n    mediationRecipientService: DidCommMediationRecipientService,\n    connectionService: DidCommConnectionService,\n    dids: DidsApi,\n    messageSender: DidCommMessageSender,\n    eventEmitter: EventEmitter,\n    discoverFeaturesApi: DidCommDiscoverFeaturesApi,\n    messagePickupApi: DidCommMessagePickupApi,\n    mediationRepository: DidCommMediationRepository,\n    routingService: DidCommRoutingService,\n    @inject(InjectionSymbols.Logger) logger: Logger,\n    agentContext: AgentContext,\n    @inject(InjectionSymbols.Stop$) stop$: Subject<boolean>,\n    mediationRecipientModuleConfig: DidCommMediationRecipientModuleConfig\n  ) {\n    this.connectionService = connectionService\n    this.dids = dids\n    this.mediationRecipientService = mediationRecipientService\n    this.messageSender = messageSender\n    this.eventEmitter = eventEmitter\n    this.logger = logger\n    this.discoverFeaturesApi = discoverFeaturesApi\n    this.messagePickupApi = messagePickupApi\n    this.mediationRepository = mediationRepository\n    this.routingService = routingService\n    this.agentContext = agentContext\n    this.stop$ = stop$\n    this.config = mediationRecipientModuleConfig\n  }\n\n  private async sendMessage(\n    outboundMessageContext: DidCommOutboundMessageContext,\n    pickupStrategy?: DidCommMediatorPickupStrategy\n  ) {\n    const mediatorPickupStrategy = pickupStrategy ?? this.config.mediatorPickupStrategy\n    const transportPriority =\n      mediatorPickupStrategy === DidCommMediatorPickupStrategy.Implicit\n        ? { schemes: ['wss', 'ws'], restrictive: true }\n        : undefined\n\n    await this.messageSender.sendMessage(outboundMessageContext, {\n      transportPriority,\n      // TODO: add keepAlive: true to enforce through the public api\n      // we need to keep the socket alive. It already works this way, but would\n      // be good to make more explicit from the public facing API.\n      // This would also make it easier to change the internal API later on.\n      // keepAlive: true,\n    })\n  }\n\n  /**\n   * Implicit mode consists simply on initiating a long-lived session to a mediator and wait for the\n   * messages to arrive automatically.\n   *\n   * In order to do initiate this session, we open a suitable connection (using WebSocket transport) and\n   * send a Trust Ping message.\n   *\n   * @param mediator\n   */\n  private async initiateImplicitMode(mediator: DidCommMediationRecord) {\n    const connection = await this.connectionService.getById(this.agentContext, mediator.connectionId)\n    const { message, connectionRecord } = await this.connectionService.createTrustPing(this.agentContext, connection, {\n      responseRequested: false,\n    })\n\n    const websocketSchemes = ['ws', 'wss']\n    const didDocument = connectionRecord.theirDid && (await this.dids.resolveDidDocument(connectionRecord.theirDid))\n    const services = (didDocument as DidDocument)?.didCommServices || []\n    const hasWebSocketTransport = services?.some((s) => websocketSchemes.includes(s.protocolScheme))\n\n    if (!hasWebSocketTransport) {\n      throw new CredoError('Cannot open websocket to connection without websocket service endpoint')\n    }\n\n    await this.messageSender.sendMessage(\n      new DidCommOutboundMessageContext(message, { agentContext: this.agentContext, connection: connectionRecord }),\n      {\n        transportPriority: {\n          schemes: websocketSchemes,\n          restrictive: true,\n          // TODO: add keepAlive: true to enforce through the public api\n          // we need to keep the socket alive. It already works this way, but would\n          // be good to make more explicit from the public facing API.\n          // This would also make it easier to change the internal API later on.\n          // keepAlive: true,\n        },\n      }\n    )\n  }\n\n  /**\n   * Keep track of a persistent transport session with a mediator, trying to reconnect to it as\n   * soon as it is disconnected, using a recursive back-off strategy\n   *\n   * @param mediator mediation record\n   * @param pickupStrategy chosen pick up strategy (should be Implicit or PickUp in Live Mode)\n   */\n  private async monitorMediatorWebSocketEvents(\n    mediator: DidCommMediationRecord,\n    pickupStrategy: DidCommMediatorPickupStrategy\n  ) {\n    const { baseMediatorReconnectionIntervalMs, maximumMediatorReconnectionIntervalMs } = this.config\n    let interval = baseMediatorReconnectionIntervalMs\n\n    const stopConditions$ = merge(this.stop$, this.stopMessagePickup$).pipe()\n\n    // Reset back off interval when the websocket is successfully opened again\n    this.eventEmitter\n      .observable<DidCommOutboundWebSocketOpenedEvent>(DidCommTransportEventTypes.DidCommOutboundWebSocketOpenedEvent)\n      .pipe(\n        // Stop when the agent shuts down or stop message pickup signal is received\n        takeUntil(stopConditions$),\n        filter((e) => e.payload.connectionId === mediator.connectionId)\n      )\n      .subscribe(() => {\n        interval = baseMediatorReconnectionIntervalMs\n      })\n\n    // FIXME: this won't work for tenant agents created by the tenants module as the agent context session\n    // could be closed. I'm not sure we want to support this as you probably don't want different tenants opening\n    // various websocket connections to mediators. However we should look at throwing an error or making sure\n    // it is not possible to use the mediation module with tenant agents.\n\n    // Listens to Outbound websocket closed events and will reopen the websocket connection\n    // in a recursive back off strategy if it matches the following criteria:\n    // - Agent is not shutdown\n    // - Socket was for current mediator connection id\n    this.eventEmitter\n      .observable<DidCommOutboundWebSocketClosedEvent>(DidCommTransportEventTypes.DidCommOutboundWebSocketClosedEvent)\n      .pipe(\n        // Stop when the agent shuts down or stop message pickup signal is received\n        takeUntil(stopConditions$),\n        filter((e) => e.payload.connectionId === mediator.connectionId),\n        // Make sure we're not reconnecting multiple times\n        throttleTime(interval),\n        // Wait for interval time before reconnecting\n        delayWhen(() => timer(interval)),\n        // Increase the interval (recursive back-off)\n        tap(() => {\n          interval = Math.min(interval * 2, maximumMediatorReconnectionIntervalMs)\n        })\n      )\n      .subscribe({\n        next: async () => {\n          this.logger.debug(\n            `Websocket connection to mediator with connectionId '${mediator.connectionId}' is closed, attempting to reconnect...`\n          )\n          try {\n            if (pickupStrategy === DidCommMediatorPickupStrategy.PickUpV2LiveMode) {\n              // Start Pickup v2 protocol in live mode (retrieve any queued message before)\n              await this.messagePickupApi.pickupMessages({\n                connectionId: mediator.connectionId,\n                protocolVersion: 'v2',\n                awaitCompletion: true,\n              })\n\n              await this.messagePickupApi.setLiveDeliveryMode({\n                connectionId: mediator.connectionId,\n                liveDelivery: true,\n                protocolVersion: 'v2',\n              })\n            } else {\n              await this.initiateImplicitMode(mediator)\n            }\n          } catch (error) {\n            this.logger.warn('Unable to re-open websocket connection to mediator', { error })\n          }\n        },\n        complete: () => this.logger.info(`Stopping pickup of messages from mediator '${mediator.id}'`),\n      })\n  }\n\n  /**\n   * Start a Message Pickup flow with a registered Mediator.\n   *\n   * @param mediator optional {MediationRecord} corresponding to the mediator to pick messages from. It will use\n   * default mediator otherwise\n   * @param pickupStrategy optional {DidCommMediatorPickupStrategy} to use in the loop. It will use Agent's default\n   * strategy or attempt to find it by Discover Features otherwise\n   * @returns\n   */\n  public async initiateMessagePickup(\n    mediator?: DidCommMediationRecord,\n    pickupStrategy?: DidCommMediatorPickupStrategy\n  ) {\n    const { mediatorPollingInterval } = this.config\n    const mediatorRecord = mediator ?? (await this.findDefaultMediator())\n    if (!mediatorRecord) {\n      throw new CredoError('There is no mediator to pickup messages from')\n    }\n\n    const mediatorPickupStrategy = pickupStrategy ?? (await this.getPickupStrategyForMediator(mediatorRecord))\n    const mediatorConnection = await this.connectionService.getById(this.agentContext, mediatorRecord.connectionId)\n\n    switch (mediatorPickupStrategy) {\n      case DidCommMediatorPickupStrategy.PickUpV1:\n      case DidCommMediatorPickupStrategy.PickUpV2: {\n        const stopConditions$ = merge(this.stop$, this.stopMessagePickup$).pipe()\n        // PickUpV1/PickUpV2 means polling every X seconds with batch message\n        const protocolVersion = mediatorPickupStrategy === DidCommMediatorPickupStrategy.PickUpV2 ? 'v2' : 'v1'\n\n        this.logger.info(\n          `Starting explicit pickup of messages from mediator '${mediatorRecord.id}' using ${protocolVersion}`\n        )\n        const subscription = interval(mediatorPollingInterval)\n          .pipe(takeUntil(stopConditions$))\n          .subscribe({\n            next: async () => {\n              await this.messagePickupApi.pickupMessages({\n                connectionId: mediatorConnection.id,\n                batchSize: this.config.maximumMessagePickup,\n                protocolVersion,\n              })\n            },\n            complete: () => this.logger.info(`Stopping pickup of messages from mediator '${mediatorRecord.id}'`),\n          })\n        return subscription\n      }\n      case DidCommMediatorPickupStrategy.PickUpV2LiveMode:\n        // PickUp V2 in Live Mode will retrieve queued messages and then set up live delivery mode\n        this.logger.info(`Starting Live Mode pickup of messages from mediator '${mediatorRecord.id}'`)\n        await this.monitorMediatorWebSocketEvents(mediatorRecord, mediatorPickupStrategy)\n\n        await this.messagePickupApi.pickupMessages({\n          connectionId: mediatorConnection.id,\n          protocolVersion: 'v2',\n          awaitCompletion: true,\n        })\n\n        await this.messagePickupApi.setLiveDeliveryMode({\n          connectionId: mediatorConnection.id,\n          liveDelivery: true,\n          protocolVersion: 'v2',\n        })\n\n        break\n      case DidCommMediatorPickupStrategy.Implicit:\n        // Implicit means sending ping once and keeping connection open. This requires a long-lived transport\n        // such as WebSockets to work\n        this.logger.info(`Starting implicit pickup of messages from mediator '${mediatorRecord.id}'`)\n        await this.monitorMediatorWebSocketEvents(mediatorRecord, mediatorPickupStrategy)\n        await this.initiateImplicitMode(mediatorRecord)\n        break\n      default:\n        this.logger.info(`Skipping pickup of messages from mediator '${mediatorRecord.id}' due to pickup strategy none`)\n    }\n  }\n\n  /**\n   * Terminate all ongoing Message Pickup loops\n   */\n  public async stopMessagePickup() {\n    this.stopMessagePickup$.next(true)\n  }\n\n  private async getPickupStrategyForMediator(mediator: DidCommMediationRecord) {\n    let mediatorPickupStrategy = mediator.pickupStrategy ?? this.config.mediatorPickupStrategy\n\n    // If mediator pickup strategy is not configured we try to query if batch pickup\n    // is supported through the discover features protocol\n    if (!mediatorPickupStrategy) {\n      const discloseForPickupV2 = await this.discoverFeaturesApi.queryFeatures({\n        connectionId: mediator.connectionId,\n        protocolVersion: 'v1',\n        queries: [{ featureType: 'protocol', match: DidCommStatusV2Message.type.protocolUri }],\n        awaitDisclosures: true,\n      })\n\n      if (discloseForPickupV2.features?.find((item) => item.id === DidCommStatusV2Message.type.protocolUri)) {\n        mediatorPickupStrategy = DidCommMediatorPickupStrategy.PickUpV2\n      } else {\n        const discloseForPickupV1 = await this.discoverFeaturesApi.queryFeatures({\n          connectionId: mediator.connectionId,\n          protocolVersion: 'v1',\n          queries: [{ featureType: 'protocol', match: DidCommBatchPickupMessage.type.protocolUri }],\n          awaitDisclosures: true,\n        })\n        // Use explicit pickup strategy\n        mediatorPickupStrategy = discloseForPickupV1.features?.find(\n          (item) => item.id === DidCommBatchPickupMessage.type.protocolUri\n        )\n          ? DidCommMediatorPickupStrategy.PickUpV1\n          : DidCommMediatorPickupStrategy.Implicit\n      }\n\n      // Store the result so it can be reused next time\n      mediator.pickupStrategy = mediatorPickupStrategy\n      await this.mediationRepository.update(this.agentContext, mediator)\n    }\n\n    return mediatorPickupStrategy\n  }\n\n  public async discoverMediation() {\n    return this.mediationRecipientService.discoverMediation(this.agentContext)\n  }\n\n  public async setDefaultMediator(mediatorRecord: DidCommMediationRecord) {\n    return this.mediationRecipientService.setDefaultMediator(this.agentContext, mediatorRecord)\n  }\n\n  public async requestMediation(connection: DidCommConnectionRecord): Promise<DidCommMediationRecord> {\n    const { mediationRecord, message } = await this.mediationRecipientService.createRequest(\n      this.agentContext,\n      connection\n    )\n    const outboundMessage = new DidCommOutboundMessageContext(message, {\n      agentContext: this.agentContext,\n      connection: connection,\n    })\n\n    await this.sendMessage(outboundMessage)\n    return mediationRecord\n  }\n\n  public async notifyKeylistUpdate(\n    connection: DidCommConnectionRecord,\n    verkey: string,\n    action?: DidCommKeylistUpdateAction\n  ) {\n    // Use our useDidKey configuration unless we know the key formatting other party is using\n    const didcommConfig = this.agentContext.dependencyManager.resolve(DidCommModuleConfig)\n    let useDidKey = didcommConfig.useDidKeyInProtocols\n\n    const useDidKeysConnectionMetadata = connection.metadata.get(DidCommConnectionMetadataKeys.UseDidKeysForProtocol)\n    if (useDidKeysConnectionMetadata) {\n      useDidKey = useDidKeysConnectionMetadata[DidCommKeylistUpdateMessage.type.protocolUri] ?? useDidKey\n    }\n\n    const message = this.mediationRecipientService.createKeylistUpdateMessage([\n      new DidCommKeylistUpdate({\n        action: action ?? DidCommKeylistUpdateAction.add,\n        recipientKey: useDidKey ? verkeyToDidKey(verkey) : verkey,\n      }),\n    ])\n\n    const outboundMessageContext = new DidCommOutboundMessageContext(message, {\n      agentContext: this.agentContext,\n      connection,\n    })\n    await this.sendMessage(outboundMessageContext)\n  }\n\n  public async findByConnectionId(connectionId: string) {\n    return await this.mediationRecipientService.findByConnectionId(this.agentContext, connectionId)\n  }\n\n  public async getMediators() {\n    return await this.mediationRecipientService.getMediators(this.agentContext)\n  }\n\n  public async findDefaultMediator(): Promise<DidCommMediationRecord | null> {\n    return this.mediationRecipientService.findDefaultMediator(this.agentContext)\n  }\n\n  public async findDefaultMediatorConnection(): Promise<DidCommConnectionRecord | null> {\n    const mediatorRecord = await this.findDefaultMediator()\n\n    if (mediatorRecord) {\n      return this.connectionService.getById(this.agentContext, mediatorRecord.connectionId)\n    }\n\n    return null\n  }\n\n  public async requestAndAwaitGrant(\n    connection: DidCommConnectionRecord,\n    timeoutMs = 10000\n  ): Promise<DidCommMediationRecord> {\n    const { mediationRecord, message } = await this.mediationRecipientService.createRequest(\n      this.agentContext,\n      connection\n    )\n\n    // Create observable for event\n    const observable = this.eventEmitter.observable<DidCommMediationStateChangedEvent>(\n      DidCommRoutingEventTypes.MediationStateChanged\n    )\n    const subject = new ReplaySubject<DidCommMediationStateChangedEvent>(1)\n\n    // Apply required filters to observable stream subscribe to replay subject\n    observable\n      .pipe(\n        filterContextCorrelationId(this.agentContext.contextCorrelationId),\n        // Only take event for current mediation record\n        filter((event) => event.payload.mediationRecord.id === mediationRecord.id),\n        // Only take event for previous state requested, current state granted\n        filter((event) => event.payload.previousState === DidCommMediationState.Requested),\n        filter((event) => event.payload.mediationRecord.state === DidCommMediationState.Granted),\n        // Only wait for first event that matches the criteria\n        first(),\n        // Do not wait for longer than specified timeout\n        timeout({\n          first: timeoutMs,\n          meta: 'MediationRecipientApi.requestAndAwaitGrant',\n        })\n      )\n      .subscribe(subject)\n\n    // Send mediation request message\n    const outboundMessageContext = new DidCommOutboundMessageContext(message, {\n      agentContext: this.agentContext,\n      connection: connection,\n      associatedRecord: mediationRecord,\n    })\n    await this.sendMessage(outboundMessageContext)\n\n    const event = await firstValueFrom(subject)\n    return event.payload.mediationRecord\n  }\n\n  /**\n   * Requests mediation for a given connection and sets that as default mediator.\n   *\n   * @param connection connection record which will be used for mediation\n   * @returns mediation record\n   */\n  // TODO: we should rename this method, to something that is more descriptive\n  public async provision(connection: DidCommConnectionRecord) {\n    this.logger.debug('Connection completed, requesting mediation')\n\n    let mediation = await this.findByConnectionId(connection.id)\n    if (!mediation) {\n      this.logger.info(`Requesting mediation for connection ${connection.id}`)\n      mediation = await this.requestAndAwaitGrant(connection, 60000) // TODO: put timeout as a config parameter\n      this.logger.debug('Mediation granted, setting as default mediator')\n      await this.setDefaultMediator(mediation)\n      this.logger.debug('Default mediator set')\n    } else {\n      this.logger.debug(`Mediator invitation has already been ${mediation.isReady ? 'granted' : 'requested'}`)\n    }\n\n    return mediation\n  }\n\n  public async getRouting(options: GetRoutingOptions) {\n    return this.routingService.getRouting(this.agentContext, options)\n  }\n}\n"],"mappings":"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"}