import { DidCommAttachment, DidCommAttachmentData } from "../../../../decorators/attachment/DidCommAttachment.mjs";
import { DidCommProofFormatSpec } from "../../models/DidCommProofFormatSpec.mjs";
import "../../models/index.mjs";
import { ANONCREDS_DATA_INTEGRITY_CRYPTOSUITE, AnonCredsDataIntegrityServiceSymbol, ClaimFormat, CredoError, DifPresentationExchangeService, DifPresentationExchangeSubmissionLocation, JsonTransformer, Kms, MdocDeviceResponse, TypedArrayEncoder, W3cCredentialService, W3cJsonLdVerifiablePresentation, W3cJwtVerifiablePresentation, X509ModuleConfig, deepEquality, extractX509CertificatesFromJwt } from "@credo-ts/core";

//#region src/modules/proofs/formats/dif-presentation-exchange/DidCommDifPresentationExchangeProofFormatService.ts
const PRESENTATION_EXCHANGE_PRESENTATION_PROPOSAL = "dif/presentation-exchange/definitions@v1.0";
const PRESENTATION_EXCHANGE_PRESENTATION_REQUEST = "dif/presentation-exchange/definitions@v1.0";
const PRESENTATION_EXCHANGE_PRESENTATION = "dif/presentation-exchange/submission@v1.0";
var DidCommDifPresentationExchangeProofFormatService = class {
	constructor() {
		this.formatKey = "presentationExchange";
	}
	presentationExchangeService(agentContext) {
		return agentContext.dependencyManager.resolve(DifPresentationExchangeService);
	}
	supportsFormat(formatIdentifier) {
		return [
			PRESENTATION_EXCHANGE_PRESENTATION_PROPOSAL,
			PRESENTATION_EXCHANGE_PRESENTATION_REQUEST,
			PRESENTATION_EXCHANGE_PRESENTATION
		].includes(formatIdentifier);
	}
	async createProposal(agentContext, { proofFormats, attachmentId }) {
		const ps = this.presentationExchangeService(agentContext);
		const pexFormat = proofFormats.presentationExchange;
		if (!pexFormat) throw new CredoError("Missing Presentation Exchange format in create proposal attachment format");
		const { presentationDefinition } = pexFormat;
		ps.validatePresentationDefinition(presentationDefinition);
		const format = new DidCommProofFormatSpec({
			format: PRESENTATION_EXCHANGE_PRESENTATION_PROPOSAL,
			attachmentId
		});
		return {
			format,
			attachment: this.getFormatData(presentationDefinition, format.attachmentId)
		};
	}
	async processProposal(agentContext, { attachment }) {
		const ps = this.presentationExchangeService(agentContext);
		const proposal = attachment.getDataAsJson();
		ps.validatePresentationDefinition(proposal);
	}
	async acceptProposal(agentContext, { attachmentId, proposalAttachment, proofFormats }) {
		const ps = this.presentationExchangeService(agentContext);
		const presentationExchangeFormat = proofFormats?.presentationExchange;
		const format = new DidCommProofFormatSpec({
			format: PRESENTATION_EXCHANGE_PRESENTATION_REQUEST,
			attachmentId
		});
		const presentationDefinition = proposalAttachment.getDataAsJson();
		ps.validatePresentationDefinition(presentationDefinition);
		const kms = agentContext.resolve(Kms.KeyManagementApi);
		return {
			format,
			attachment: this.getFormatData({
				presentation_definition: presentationDefinition,
				options: {
					challenge: presentationExchangeFormat?.options?.challenge ?? TypedArrayEncoder.toBase64URL(kms.randomBytes({ length: 32 })),
					domain: presentationExchangeFormat?.options?.domain
				}
			}, format.attachmentId)
		};
	}
	async createRequest(agentContext, { attachmentId, proofFormats }) {
		const ps = this.presentationExchangeService(agentContext);
		const presentationExchangeFormat = proofFormats.presentationExchange;
		if (!presentationExchangeFormat) throw Error("Missing presentation exchange format in create request attachment format");
		const { presentationDefinition, options } = presentationExchangeFormat;
		ps.validatePresentationDefinition(presentationDefinition);
		const format = new DidCommProofFormatSpec({
			format: PRESENTATION_EXCHANGE_PRESENTATION_REQUEST,
			attachmentId
		});
		const kms = agentContext.resolve(Kms.KeyManagementApi);
		return {
			attachment: this.getFormatData({
				presentation_definition: presentationDefinition,
				options: {
					challenge: options?.challenge ?? TypedArrayEncoder.toBase64URL(kms.randomBytes({ length: 32 })),
					domain: options?.domain
				}
			}, format.attachmentId),
			format
		};
	}
	async processRequest(agentContext, { attachment }) {
		const ps = this.presentationExchangeService(agentContext);
		const { presentation_definition: presentationDefinition } = attachment.getDataAsJson();
		ps.validatePresentationDefinition(presentationDefinition);
	}
	async acceptRequest(agentContext, { attachmentId, requestAttachment, proofFormats }) {
		const ps = this.presentationExchangeService(agentContext);
		const format = new DidCommProofFormatSpec({
			format: PRESENTATION_EXCHANGE_PRESENTATION,
			attachmentId
		});
		const { presentation_definition: presentationDefinition, options } = requestAttachment.getDataAsJson();
		let credentials;
		if (proofFormats?.presentationExchange?.credentials) credentials = proofFormats.presentationExchange.credentials;
		else {
			const credentialsForRequest = await ps.getCredentialsForRequest(agentContext, presentationDefinition);
			credentials = ps.selectCredentialsForRequest(credentialsForRequest);
		}
		const kms = agentContext.resolve(Kms.KeyManagementApi);
		const presentation = await ps.createPresentation(agentContext, {
			presentationDefinition,
			credentialsForInputDescriptor: credentials,
			challenge: options?.challenge ?? TypedArrayEncoder.toBase64URL(kms.randomBytes({ length: 32 })),
			domain: options?.domain
		});
		if (!presentation) throw new CredoError("Failed to create presentation for request.");
		if (presentation.verifiablePresentations.length > 1) throw new CredoError("Invalid amount of verifiable presentations. Only one is allowed.");
		if (presentation.presentationSubmissionLocation === DifPresentationExchangeSubmissionLocation.EXTERNAL) throw new CredoError("External presentation submission is not supported.");
		const firstPresentation = presentation.verifiablePresentations[0];
		const encodedFirstPresentation = firstPresentation instanceof W3cJwtVerifiablePresentation || firstPresentation instanceof W3cJsonLdVerifiablePresentation ? firstPresentation.encoded : firstPresentation instanceof MdocDeviceResponse ? firstPresentation.base64Url : firstPresentation?.compact;
		return {
			attachment: this.getFormatData(encodedFirstPresentation, format.attachmentId),
			format
		};
	}
	shouldVerifyUsingAnonCredsDataIntegrity(presentation, presentationSubmission) {
		if (presentation.claimFormat !== ClaimFormat.LdpVp) return false;
		if (!presentationSubmission.descriptor_map.every((descriptor) => descriptor.format === ClaimFormat.DiVp)) return false;
		return presentation.dataIntegrityCryptosuites.includes(ANONCREDS_DATA_INTEGRITY_CRYPTOSUITE);
	}
	async processPresentation(agentContext, { requestAttachment, attachment, proofRecord }) {
		const ps = this.presentationExchangeService(agentContext);
		const w3cCredentialService = agentContext.dependencyManager.resolve(W3cCredentialService);
		const request = requestAttachment.getDataAsJson();
		const presentation = attachment.getDataAsJson();
		let parsedPresentation;
		let jsonPresentation;
		if (typeof presentation === "string" && presentation.includes("~")) throw new CredoError("Received SD-JWT VC in PEX proof format. This is not supported yet.");
		if (typeof presentation === "string") {
			parsedPresentation = W3cJwtVerifiablePresentation.fromSerializedJwt(presentation);
			jsonPresentation = parsedPresentation.presentation.toJSON();
		} else {
			parsedPresentation = JsonTransformer.fromJSON(presentation, W3cJsonLdVerifiablePresentation);
			jsonPresentation = parsedPresentation.toJSON();
		}
		if (!jsonPresentation.presentation_submission) {
			agentContext.config.logger.error("Received presentation in PEX proof format without presentation submission. This should not happen.");
			return false;
		}
		if (!request.options?.challenge) {
			agentContext.config.logger.error("Received presentation in PEX proof format without challenge. This should not happen.");
			return false;
		}
		try {
			ps.validatePresentationDefinition(request.presentation_definition);
			ps.validatePresentationSubmission(jsonPresentation.presentation_submission);
			ps.validatePresentation(request.presentation_definition, parsedPresentation);
			let verificationResult;
			if (parsedPresentation.claimFormat === ClaimFormat.JwtVp) {
				const x509Config = agentContext.dependencyManager.resolve(X509ModuleConfig);
				const certificateChain = extractX509CertificatesFromJwt(parsedPresentation.jwt);
				let trustedCertificates;
				if (certificateChain && x509Config.getTrustedCertificatesForVerification) trustedCertificates = await x509Config.getTrustedCertificatesForVerification?.(agentContext, {
					certificateChain,
					verification: {
						type: "credential",
						credential: parsedPresentation,
						didcommProofRecordId: proofRecord.id
					}
				});
				if (!trustedCertificates) trustedCertificates = x509Config.trustedCertificates ?? [];
				verificationResult = await w3cCredentialService.verifyPresentation(agentContext, {
					presentation: parsedPresentation,
					challenge: request.options.challenge,
					domain: request.options.domain
				});
			} else if (parsedPresentation.claimFormat === ClaimFormat.LdpVp) if (this.shouldVerifyUsingAnonCredsDataIntegrity(parsedPresentation, jsonPresentation.presentation_submission)) verificationResult = {
				isValid: await agentContext.dependencyManager.resolve(AnonCredsDataIntegrityServiceSymbol).verifyPresentation(agentContext, {
					presentation: parsedPresentation,
					presentationDefinition: request.presentation_definition,
					presentationSubmission: jsonPresentation.presentation_submission,
					challenge: request.options.challenge
				}),
				validations: {},
				error: {
					name: "DataIntegrityError",
					message: "Verifying the Data Integrity Proof failed. An unknown error occurred."
				}
			};
			else verificationResult = await w3cCredentialService.verifyPresentation(agentContext, {
				presentation: parsedPresentation,
				challenge: request.options.challenge,
				domain: request.options.domain
			});
			else {
				agentContext.config.logger.error(`Received presentation in PEX proof format with unsupported format ${parsedPresentation.claimFormat}.`);
				return false;
			}
			if (!verificationResult.isValid) {
				agentContext.config.logger.error(`Received presentation in PEX proof format that could not be verified: ${verificationResult.error}`, { verificationResult });
				return false;
			}
			return true;
		} catch (e) {
			agentContext.config.logger.error(`Failed to verify presentation in PEX proof format service: ${e.message}`, { cause: e });
			return false;
		}
	}
	async getCredentialsForRequest(agentContext, { requestAttachment }) {
		const ps = this.presentationExchangeService(agentContext);
		const { presentation_definition: presentationDefinition } = requestAttachment.getDataAsJson();
		ps.validatePresentationDefinition(presentationDefinition);
		return await ps.getCredentialsForRequest(agentContext, presentationDefinition);
	}
	async selectCredentialsForRequest(agentContext, { requestAttachment }) {
		const ps = this.presentationExchangeService(agentContext);
		const { presentation_definition: presentationDefinition } = requestAttachment.getDataAsJson();
		const credentialsForRequest = await ps.getCredentialsForRequest(agentContext, presentationDefinition);
		return { credentials: ps.selectCredentialsForRequest(credentialsForRequest) };
	}
	async shouldAutoRespondToProposal(_agentContext, { requestAttachment, proposalAttachment }) {
		const proposalData = proposalAttachment.getDataAsJson();
		return deepEquality(requestAttachment.getDataAsJson().presentation_definition, proposalData);
	}
	async shouldAutoRespondToRequest(_agentContext, { requestAttachment, proposalAttachment }) {
		const proposalData = proposalAttachment.getDataAsJson();
		return deepEquality(requestAttachment.getDataAsJson().presentation_definition, proposalData);
	}
	/**
	*
	* The presentation is already verified in processPresentation, so we can just return true here.
	* It's only an ack, so it's just that we received the presentation.
	*
	*/
	async shouldAutoRespondToPresentation(_agentContext, _options) {
		return true;
	}
	getFormatData(data, id) {
		return new DidCommAttachment({
			id,
			mimeType: "application/json",
			data: new DidCommAttachmentData({ json: data })
		});
	}
};

//#endregion
export { DidCommDifPresentationExchangeProofFormatService };
//# sourceMappingURL=DidCommDifPresentationExchangeProofFormatService.mjs.map