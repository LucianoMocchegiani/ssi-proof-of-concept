import { DidCommAttachment } from "../../../decorators/attachment/DidCommAttachment.mjs";
import { DidCommProofFormatSpec } from "../models/DidCommProofFormatSpec.mjs";
import { DidCommProofExchangeRecord } from "../repository/DidCommProofExchangeRecord.mjs";
import { DidCommProofFormat, DidCommProofFormatCredentialForRequestPayload, DidCommProofFormatPayload } from "./DidCommProofFormat.mjs";
import { DidCommProofFormatService } from "./DidCommProofFormatService.mjs";

//#region src/modules/proofs/formats/DidCommProofFormatServiceOptions.d.ts
declare namespace DidCommProofFormatServiceOptions_d_exports {
  export { DidCommFormatCreateRequestOptions, DidCommProofFormatAcceptProposalOptions, DidCommProofFormatAcceptRequestOptions, DidCommProofFormatAutoRespondPresentationOptions, DidCommProofFormatAutoRespondProposalOptions, DidCommProofFormatAutoRespondRequestOptions, DidCommProofFormatCreateProposalOptions, DidCommProofFormatCreateReturn, DidCommProofFormatGetCredentialsForRequestOptions, DidCommProofFormatGetCredentialsForRequestReturn, DidCommProofFormatProcessOptions, DidCommProofFormatProcessPresentationOptions, DidCommProofFormatSelectCredentialsForRequestOptions, DidCommProofFormatSelectCredentialsForRequestReturn, ExtractProofFormat, ExtractProofFormats };
}
/**
 * Infer the {@link DidCommProofFormat} based on a {@link DidCommProofFormatService}.
 *
 * It does this by extracting the `ProofFormat` generic from the `ProofFormatService`.
 *
 * @example
 * ```
 * // TheProofFormat is now equal to IndyProofFormat
 * type TheProofFormat = ExtractProofFormat<IndyProofFormatService>
 * ```
 *
 * Because the `IndyProofFormatService` is defined as follows:
 * ```
 * class IndyProofFormatService implements ProofFormatService<IndyProofFormat> {
 * }
 * ```
 */
type ExtractProofFormat<Type> = Type extends DidCommProofFormatService<infer ProofFormat> ? ProofFormat : never;
/**
 * Infer an array of {@link DidCommProofFormat} types based on an array of {@link DidCommProofFormatService} types.
 *
 * This is based on {@link ExtractProofFormat}, but allows to handle arrays.
 */
type ExtractProofFormats<PFs extends DidCommProofFormatService[]> = { [PF in keyof PFs]: ExtractProofFormat<PFs[PF]> };
/**
 * Base return type for all methods that create an attachment format.
 *
 * It requires an attachment and a format to be returned.
 */
interface DidCommProofFormatCreateReturn {
  format: DidCommProofFormatSpec;
  attachment: DidCommAttachment;
}
/**
 * Base type for all proof process methods.
 */
interface DidCommProofFormatProcessOptions {
  attachment: DidCommAttachment;
  proofRecord: DidCommProofExchangeRecord;
}
interface DidCommProofFormatProcessPresentationOptions extends DidCommProofFormatProcessOptions {
  requestAttachment: DidCommAttachment;
}
interface DidCommProofFormatCreateProposalOptions<PF extends DidCommProofFormat> {
  proofRecord: DidCommProofExchangeRecord;
  proofFormats: DidCommProofFormatPayload<[PF], 'createProposal'>;
  attachmentId?: string;
}
interface DidCommProofFormatAcceptProposalOptions<PF extends DidCommProofFormat> {
  proofRecord: DidCommProofExchangeRecord;
  proofFormats?: DidCommProofFormatPayload<[PF], 'acceptProposal'>;
  attachmentId?: string;
  proposalAttachment: DidCommAttachment;
}
interface DidCommFormatCreateRequestOptions<PF extends DidCommProofFormat> {
  proofRecord: DidCommProofExchangeRecord;
  proofFormats: DidCommProofFormatPayload<[PF], 'createRequest'>;
  attachmentId?: string;
}
interface DidCommProofFormatAcceptRequestOptions<PF extends DidCommProofFormat> {
  proofRecord: DidCommProofExchangeRecord;
  proofFormats?: DidCommProofFormatPayload<[PF], 'acceptRequest'>;
  attachmentId?: string;
  requestAttachment: DidCommAttachment;
  proposalAttachment?: DidCommAttachment;
}
interface DidCommProofFormatGetCredentialsForRequestOptions<PF extends DidCommProofFormat> {
  proofRecord: DidCommProofExchangeRecord;
  proofFormats?: DidCommProofFormatCredentialForRequestPayload<[PF], 'getCredentialsForRequest', 'input'>;
  requestAttachment: DidCommAttachment;
  proposalAttachment?: DidCommAttachment;
}
type DidCommProofFormatGetCredentialsForRequestReturn<PF extends DidCommProofFormat> = PF['proofFormats']['getCredentialsForRequest']['output'];
interface DidCommProofFormatSelectCredentialsForRequestOptions<PF extends DidCommProofFormat> {
  proofRecord: DidCommProofExchangeRecord;
  proofFormats?: DidCommProofFormatCredentialForRequestPayload<[PF], 'selectCredentialsForRequest', 'input'>;
  requestAttachment: DidCommAttachment;
  proposalAttachment?: DidCommAttachment;
}
type DidCommProofFormatSelectCredentialsForRequestReturn<PF extends DidCommProofFormat> = PF['proofFormats']['selectCredentialsForRequest']['output'];
interface DidCommProofFormatAutoRespondProposalOptions {
  proofRecord: DidCommProofExchangeRecord;
  proposalAttachment: DidCommAttachment;
  requestAttachment: DidCommAttachment;
}
interface DidCommProofFormatAutoRespondRequestOptions {
  proofRecord: DidCommProofExchangeRecord;
  requestAttachment: DidCommAttachment;
  proposalAttachment: DidCommAttachment;
}
interface DidCommProofFormatAutoRespondPresentationOptions {
  proofRecord: DidCommProofExchangeRecord;
  proposalAttachment?: DidCommAttachment;
  requestAttachment: DidCommAttachment;
  presentationAttachment: DidCommAttachment;
}
//#endregion
export { DidCommFormatCreateRequestOptions, DidCommProofFormatAcceptProposalOptions, DidCommProofFormatAcceptRequestOptions, DidCommProofFormatAutoRespondPresentationOptions, DidCommProofFormatAutoRespondProposalOptions, DidCommProofFormatAutoRespondRequestOptions, DidCommProofFormatCreateProposalOptions, DidCommProofFormatCreateReturn, DidCommProofFormatGetCredentialsForRequestOptions, DidCommProofFormatGetCredentialsForRequestReturn, DidCommProofFormatProcessOptions, DidCommProofFormatProcessPresentationOptions, DidCommProofFormatSelectCredentialsForRequestOptions, DidCommProofFormatSelectCredentialsForRequestReturn, DidCommProofFormatServiceOptions_d_exports, ExtractProofFormat, ExtractProofFormats };
//# sourceMappingURL=DidCommProofFormatServiceOptions.d.mts.map