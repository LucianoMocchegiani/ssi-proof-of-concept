{"version":3,"file":"DidCommDifPresentationExchangeProofFormatService.mjs","names":[],"sources":["../../../../../src/modules/proofs/formats/dif-presentation-exchange/DidCommDifPresentationExchangeProofFormatService.ts"],"sourcesContent":["import type {\n  AgentContext,\n  DifPexInputDescriptorToCredentials,\n  DifPresentationExchangeSubmission,\n  IAnonCredsDataIntegrityService,\n  JsonValue,\n  W3cJsonPresentation,\n  W3cVerifiablePresentation,\n  W3cVerifyPresentationResult,\n} from '@credo-ts/core'\nimport {\n  ANONCREDS_DATA_INTEGRITY_CRYPTOSUITE,\n  AnonCredsDataIntegrityServiceSymbol,\n  ClaimFormat,\n  CredoError,\n  DifPresentationExchangeService,\n  DifPresentationExchangeSubmissionLocation,\n  deepEquality,\n  extractX509CertificatesFromJwt,\n  JsonTransformer,\n  Kms,\n  MdocDeviceResponse,\n  TypedArrayEncoder,\n  W3cCredentialService,\n  W3cJsonLdVerifiablePresentation,\n  W3cJwtVerifiablePresentation,\n  X509ModuleConfig,\n} from '@credo-ts/core'\nimport { DidCommAttachment, DidCommAttachmentData } from '../../../../decorators/attachment/DidCommAttachment'\nimport { DidCommProofFormatSpec } from '../../models'\nimport type { DidCommProofFormatService } from '../DidCommProofFormatService'\nimport type {\n  DidCommFormatCreateRequestOptions,\n  DidCommProofFormatAcceptProposalOptions,\n  DidCommProofFormatAcceptRequestOptions,\n  DidCommProofFormatAutoRespondPresentationOptions,\n  DidCommProofFormatAutoRespondProposalOptions,\n  DidCommProofFormatAutoRespondRequestOptions,\n  DidCommProofFormatCreateProposalOptions,\n  DidCommProofFormatCreateReturn,\n  DidCommProofFormatGetCredentialsForRequestOptions,\n  DidCommProofFormatProcessOptions,\n  DidCommProofFormatProcessPresentationOptions,\n  DidCommProofFormatSelectCredentialsForRequestOptions,\n} from '../DidCommProofFormatServiceOptions'\nimport type {\n  DidCommDifPresentationExchangeProofFormat,\n  DifPresentationExchangePresentation,\n  DifPresentationExchangeProposal,\n  DifPresentationExchangeRequest,\n} from './DidCommDifPresentationExchangeProofFormat'\n\nconst PRESENTATION_EXCHANGE_PRESENTATION_PROPOSAL = 'dif/presentation-exchange/definitions@v1.0'\nconst PRESENTATION_EXCHANGE_PRESENTATION_REQUEST = 'dif/presentation-exchange/definitions@v1.0'\nconst PRESENTATION_EXCHANGE_PRESENTATION = 'dif/presentation-exchange/submission@v1.0'\n\nexport class DidCommDifPresentationExchangeProofFormatService\n  implements DidCommProofFormatService<DidCommDifPresentationExchangeProofFormat>\n{\n  public readonly formatKey = 'presentationExchange' as const\n\n  private presentationExchangeService(agentContext: AgentContext) {\n    return agentContext.dependencyManager.resolve(DifPresentationExchangeService)\n  }\n\n  public supportsFormat(formatIdentifier: string): boolean {\n    return [\n      PRESENTATION_EXCHANGE_PRESENTATION_PROPOSAL,\n      PRESENTATION_EXCHANGE_PRESENTATION_REQUEST,\n      PRESENTATION_EXCHANGE_PRESENTATION,\n    ].includes(formatIdentifier)\n  }\n\n  public async createProposal(\n    agentContext: AgentContext,\n    { proofFormats, attachmentId }: DidCommProofFormatCreateProposalOptions<DidCommDifPresentationExchangeProofFormat>\n  ): Promise<DidCommProofFormatCreateReturn> {\n    const ps = this.presentationExchangeService(agentContext)\n\n    const pexFormat = proofFormats.presentationExchange\n    if (!pexFormat) {\n      throw new CredoError('Missing Presentation Exchange format in create proposal attachment format')\n    }\n\n    const { presentationDefinition } = pexFormat\n\n    ps.validatePresentationDefinition(presentationDefinition)\n\n    const format = new DidCommProofFormatSpec({ format: PRESENTATION_EXCHANGE_PRESENTATION_PROPOSAL, attachmentId })\n\n    const attachment = this.getFormatData(presentationDefinition, format.attachmentId)\n\n    return { format, attachment }\n  }\n\n  public async processProposal(\n    agentContext: AgentContext,\n    { attachment }: DidCommProofFormatProcessOptions\n  ): Promise<void> {\n    const ps = this.presentationExchangeService(agentContext)\n    const proposal = attachment.getDataAsJson<DifPresentationExchangeProposal>()\n    ps.validatePresentationDefinition(proposal)\n  }\n\n  public async acceptProposal(\n    agentContext: AgentContext,\n    {\n      attachmentId,\n      proposalAttachment,\n      proofFormats,\n    }: DidCommProofFormatAcceptProposalOptions<DidCommDifPresentationExchangeProofFormat>\n  ): Promise<DidCommProofFormatCreateReturn> {\n    const ps = this.presentationExchangeService(agentContext)\n\n    const presentationExchangeFormat = proofFormats?.presentationExchange\n\n    const format = new DidCommProofFormatSpec({\n      format: PRESENTATION_EXCHANGE_PRESENTATION_REQUEST,\n      attachmentId,\n    })\n\n    const presentationDefinition = proposalAttachment.getDataAsJson<DifPresentationExchangeProposal>()\n    ps.validatePresentationDefinition(presentationDefinition)\n\n    const kms = agentContext.resolve(Kms.KeyManagementApi)\n    const attachment = this.getFormatData(\n      {\n        presentation_definition: presentationDefinition,\n        options: {\n          // NOTE: we always want to include a challenge to prevent replay attacks\n          challenge:\n            presentationExchangeFormat?.options?.challenge ??\n            TypedArrayEncoder.toBase64URL(kms.randomBytes({ length: 32 })),\n          domain: presentationExchangeFormat?.options?.domain,\n        },\n      } satisfies DifPresentationExchangeRequest,\n      format.attachmentId\n    )\n\n    return { format, attachment }\n  }\n\n  public async createRequest(\n    agentContext: AgentContext,\n    { attachmentId, proofFormats }: DidCommFormatCreateRequestOptions<DidCommDifPresentationExchangeProofFormat>\n  ): Promise<DidCommProofFormatCreateReturn> {\n    const ps = this.presentationExchangeService(agentContext)\n\n    const presentationExchangeFormat = proofFormats.presentationExchange\n    if (!presentationExchangeFormat) {\n      throw Error('Missing presentation exchange format in create request attachment format')\n    }\n\n    const { presentationDefinition, options } = presentationExchangeFormat\n\n    ps.validatePresentationDefinition(presentationDefinition)\n\n    const format = new DidCommProofFormatSpec({\n      format: PRESENTATION_EXCHANGE_PRESENTATION_REQUEST,\n      attachmentId,\n    })\n\n    const kms = agentContext.resolve(Kms.KeyManagementApi)\n    const attachment = this.getFormatData(\n      {\n        presentation_definition: presentationDefinition,\n        options: {\n          // NOTE: we always want to include a challenge to prevent replay attacks\n          challenge: options?.challenge ?? TypedArrayEncoder.toBase64URL(kms.randomBytes({ length: 32 })),\n          domain: options?.domain,\n        },\n      } satisfies DifPresentationExchangeRequest,\n      format.attachmentId\n    )\n\n    return { attachment, format }\n  }\n\n  public async processRequest(\n    agentContext: AgentContext,\n    { attachment }: DidCommProofFormatProcessOptions\n  ): Promise<void> {\n    const ps = this.presentationExchangeService(agentContext)\n    const { presentation_definition: presentationDefinition } =\n      attachment.getDataAsJson<DifPresentationExchangeRequest>()\n    ps.validatePresentationDefinition(presentationDefinition)\n  }\n\n  public async acceptRequest(\n    agentContext: AgentContext,\n    {\n      attachmentId,\n      requestAttachment,\n      proofFormats,\n    }: DidCommProofFormatAcceptRequestOptions<DidCommDifPresentationExchangeProofFormat>\n  ): Promise<DidCommProofFormatCreateReturn> {\n    const ps = this.presentationExchangeService(agentContext)\n\n    const format = new DidCommProofFormatSpec({\n      format: PRESENTATION_EXCHANGE_PRESENTATION,\n      attachmentId,\n    })\n\n    const { presentation_definition: presentationDefinition, options } =\n      requestAttachment.getDataAsJson<DifPresentationExchangeRequest>()\n\n    let credentials: DifPexInputDescriptorToCredentials\n    if (proofFormats?.presentationExchange?.credentials) {\n      credentials = proofFormats.presentationExchange.credentials\n    } else {\n      const credentialsForRequest = await ps.getCredentialsForRequest(agentContext, presentationDefinition)\n      credentials = ps.selectCredentialsForRequest(credentialsForRequest)\n    }\n\n    const kms = agentContext.resolve(Kms.KeyManagementApi)\n    const presentation = await ps.createPresentation(agentContext, {\n      presentationDefinition,\n      credentialsForInputDescriptor: credentials,\n      challenge: options?.challenge ?? TypedArrayEncoder.toBase64URL(kms.randomBytes({ length: 32 })),\n      domain: options?.domain,\n    })\n\n    if (!presentation) {\n      throw new CredoError('Failed to create presentation for request.')\n    }\n\n    if (presentation.verifiablePresentations.length > 1) {\n      throw new CredoError('Invalid amount of verifiable presentations. Only one is allowed.')\n    }\n\n    if (presentation.presentationSubmissionLocation === DifPresentationExchangeSubmissionLocation.EXTERNAL) {\n      throw new CredoError('External presentation submission is not supported.')\n    }\n\n    const firstPresentation = presentation.verifiablePresentations[0]\n\n    // TODO: they should all have `encoded` property so it's easy to use the resulting VP\n    const encodedFirstPresentation =\n      firstPresentation instanceof W3cJwtVerifiablePresentation ||\n      firstPresentation instanceof W3cJsonLdVerifiablePresentation\n        ? firstPresentation.encoded\n        : firstPresentation instanceof MdocDeviceResponse\n          ? firstPresentation.base64Url\n          : firstPresentation?.compact\n    const attachment = this.getFormatData(encodedFirstPresentation, format.attachmentId)\n\n    return { attachment, format }\n  }\n\n  private shouldVerifyUsingAnonCredsDataIntegrity(\n    presentation: W3cVerifiablePresentation,\n    presentationSubmission: DifPresentationExchangeSubmission\n  ) {\n    if (presentation.claimFormat !== ClaimFormat.LdpVp) return false\n    const descriptorMap = presentationSubmission.descriptor_map\n\n    const verifyUsingDataIntegrity = descriptorMap.every((descriptor) => descriptor.format === ClaimFormat.DiVp)\n    if (!verifyUsingDataIntegrity) return false\n\n    return presentation.dataIntegrityCryptosuites.includes(ANONCREDS_DATA_INTEGRITY_CRYPTOSUITE)\n  }\n\n  public async processPresentation(\n    agentContext: AgentContext,\n    { requestAttachment, attachment, proofRecord }: DidCommProofFormatProcessPresentationOptions\n  ): Promise<boolean> {\n    const ps = this.presentationExchangeService(agentContext)\n    const w3cCredentialService = agentContext.dependencyManager.resolve(W3cCredentialService)\n\n    const request = requestAttachment.getDataAsJson<DifPresentationExchangeRequest>()\n    const presentation = attachment.getDataAsJson<DifPresentationExchangePresentation>()\n    let parsedPresentation: W3cVerifiablePresentation\n    let jsonPresentation: W3cJsonPresentation\n\n    // TODO: we should probably move this transformation logic into the VC module, so it\n    // can be reused in Credo when we need to go from encoded -> parsed\n    if (typeof presentation === 'string' && presentation.includes('~')) {\n      // NOTE: we need to define in the PEX RFC where to put the presentation_submission\n      throw new CredoError('Received SD-JWT VC in PEX proof format. This is not supported yet.')\n    }\n    if (typeof presentation === 'string') {\n      // If it's a string, we expect it to be a JWT VP\n      parsedPresentation = W3cJwtVerifiablePresentation.fromSerializedJwt(presentation)\n      jsonPresentation = parsedPresentation.presentation.toJSON()\n    } else {\n      // Otherwise we expect it to be a JSON-LD VP\n      parsedPresentation = JsonTransformer.fromJSON(presentation, W3cJsonLdVerifiablePresentation)\n      jsonPresentation = parsedPresentation.toJSON()\n    }\n\n    if (!jsonPresentation.presentation_submission) {\n      agentContext.config.logger.error(\n        'Received presentation in PEX proof format without presentation submission. This should not happen.'\n      )\n      return false\n    }\n\n    if (!request.options?.challenge) {\n      agentContext.config.logger.error(\n        'Received presentation in PEX proof format without challenge. This should not happen.'\n      )\n      return false\n    }\n\n    try {\n      ps.validatePresentationDefinition(request.presentation_definition)\n      ps.validatePresentationSubmission(jsonPresentation.presentation_submission)\n      ps.validatePresentation(request.presentation_definition, parsedPresentation)\n\n      let verificationResult: W3cVerifyPresentationResult\n\n      // FIXME: for some reason it won't accept the input if it doesn't know\n      // whether it's a JWT or JSON-LD VP even though the input is the same.\n      // Not sure how to fix\n      if (parsedPresentation.claimFormat === ClaimFormat.JwtVp) {\n        const x509Config = agentContext.dependencyManager.resolve(X509ModuleConfig)\n\n        const certificateChain = extractX509CertificatesFromJwt(parsedPresentation.jwt)\n        let trustedCertificates: string[] | undefined\n\n        if (certificateChain && x509Config.getTrustedCertificatesForVerification) {\n          trustedCertificates = await x509Config.getTrustedCertificatesForVerification?.(agentContext, {\n            certificateChain,\n            verification: {\n              type: 'credential',\n              credential: parsedPresentation,\n              didcommProofRecordId: proofRecord.id,\n            },\n          })\n        }\n\n        if (!trustedCertificates) {\n          trustedCertificates = x509Config.trustedCertificates ?? []\n        }\n\n        verificationResult = await w3cCredentialService.verifyPresentation(agentContext, {\n          presentation: parsedPresentation,\n          challenge: request.options.challenge,\n          domain: request.options.domain,\n        })\n      } else if (parsedPresentation.claimFormat === ClaimFormat.LdpVp) {\n        if (\n          this.shouldVerifyUsingAnonCredsDataIntegrity(parsedPresentation, jsonPresentation.presentation_submission)\n        ) {\n          const dataIntegrityService = agentContext.dependencyManager.resolve<IAnonCredsDataIntegrityService>(\n            AnonCredsDataIntegrityServiceSymbol\n          )\n          const proofVerificationResult = await dataIntegrityService.verifyPresentation(agentContext, {\n            presentation: parsedPresentation as W3cJsonLdVerifiablePresentation,\n            presentationDefinition: request.presentation_definition,\n            presentationSubmission: jsonPresentation.presentation_submission,\n            challenge: request.options.challenge,\n          })\n\n          verificationResult = {\n            isValid: proofVerificationResult,\n            validations: {},\n            error: {\n              name: 'DataIntegrityError',\n              message: 'Verifying the Data Integrity Proof failed. An unknown error occurred.',\n            },\n          }\n        } else {\n          verificationResult = await w3cCredentialService.verifyPresentation(agentContext, {\n            presentation: parsedPresentation,\n            challenge: request.options.challenge,\n            domain: request.options.domain,\n          })\n        }\n      } else {\n        agentContext.config.logger.error(\n          `Received presentation in PEX proof format with unsupported format ${\n            // biome-ignore lint/suspicious/noExplicitAny: no explanation\n            (parsedPresentation as any).claimFormat\n          }.`\n        )\n        return false\n      }\n\n      if (!verificationResult.isValid) {\n        agentContext.config.logger.error(\n          `Received presentation in PEX proof format that could not be verified: ${verificationResult.error}`,\n          { verificationResult }\n        )\n        return false\n      }\n\n      return true\n    } catch (e) {\n      agentContext.config.logger.error(`Failed to verify presentation in PEX proof format service: ${e.message}`, {\n        cause: e,\n      })\n      return false\n    }\n  }\n\n  public async getCredentialsForRequest(\n    agentContext: AgentContext,\n    { requestAttachment }: DidCommProofFormatGetCredentialsForRequestOptions<DidCommDifPresentationExchangeProofFormat>\n  ) {\n    const ps = this.presentationExchangeService(agentContext)\n    const { presentation_definition: presentationDefinition } =\n      requestAttachment.getDataAsJson<DifPresentationExchangeRequest>()\n\n    ps.validatePresentationDefinition(presentationDefinition)\n\n    const presentationSubmission = await ps.getCredentialsForRequest(agentContext, presentationDefinition)\n    return presentationSubmission\n  }\n\n  public async selectCredentialsForRequest(\n    agentContext: AgentContext,\n    {\n      requestAttachment,\n    }: DidCommProofFormatSelectCredentialsForRequestOptions<DidCommDifPresentationExchangeProofFormat>\n  ) {\n    const ps = this.presentationExchangeService(agentContext)\n    const { presentation_definition: presentationDefinition } =\n      requestAttachment.getDataAsJson<DifPresentationExchangeRequest>()\n\n    const credentialsForRequest = await ps.getCredentialsForRequest(agentContext, presentationDefinition)\n    return { credentials: ps.selectCredentialsForRequest(credentialsForRequest) }\n  }\n\n  public async shouldAutoRespondToProposal(\n    _agentContext: AgentContext,\n    { requestAttachment, proposalAttachment }: DidCommProofFormatAutoRespondProposalOptions\n  ): Promise<boolean> {\n    const proposalData = proposalAttachment.getDataAsJson<DifPresentationExchangeProposal>()\n    const requestData = requestAttachment.getDataAsJson<DifPresentationExchangeRequest>()\n\n    return deepEquality(requestData.presentation_definition, proposalData)\n  }\n\n  public async shouldAutoRespondToRequest(\n    _agentContext: AgentContext,\n    { requestAttachment, proposalAttachment }: DidCommProofFormatAutoRespondRequestOptions\n  ): Promise<boolean> {\n    const proposalData = proposalAttachment.getDataAsJson<DifPresentationExchangeProposal>()\n    const requestData = requestAttachment.getDataAsJson<DifPresentationExchangeRequest>()\n\n    return deepEquality(requestData.presentation_definition, proposalData)\n  }\n\n  /**\n   *\n   * The presentation is already verified in processPresentation, so we can just return true here.\n   * It's only an ack, so it's just that we received the presentation.\n   *\n   */\n  public async shouldAutoRespondToPresentation(\n    _agentContext: AgentContext,\n    _options: DidCommProofFormatAutoRespondPresentationOptions\n  ): Promise<boolean> {\n    return true\n  }\n\n  private getFormatData(data: unknown, id: string): DidCommAttachment {\n    const attachment = new DidCommAttachment({\n      id,\n      mimeType: 'application/json',\n      data: new DidCommAttachmentData({\n        json: data as JsonValue,\n      }),\n    })\n\n    return attachment\n  }\n}\n"],"mappings":"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"}