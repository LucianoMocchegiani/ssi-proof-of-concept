{"version":3,"file":"DidCommProofsApi.mjs","names":[],"sources":["../../../src/modules/proofs/DidCommProofsApi.ts"],"sourcesContent":["import type { Query, QueryOptions } from '@credo-ts/core'\nimport { AgentContext, CredoError, injectable } from '@credo-ts/core'\nimport { DidCommMessage } from '../../DidCommMessage'\nimport { DidCommMessageSender } from '../../DidCommMessageSender'\nimport { getOutboundDidCommMessageContext } from '../../getDidCommOutboundMessageContext'\nimport { DidCommConnectionService } from '../connections'\nimport type {\n  AcceptProofOptions,\n  AcceptProofProposalOptions,\n  AcceptProofRequestOptions,\n  CreateProofProposalOptions,\n  CreateProofRequestOptions,\n  DeclineProofRequestOptions,\n  DeleteProofOptions,\n  FindProofPresentationMessageReturn,\n  FindProofProposalMessageReturn,\n  FindProofRequestMessageReturn,\n  GetCredentialsForProofRequestOptions,\n  GetCredentialsForProofRequestReturn,\n  GetProofFormatDataReturn,\n  NegotiateProofProposalOptions,\n  NegotiateProofRequestOptions,\n  ProposeProofOptions,\n  RequestProofOptions,\n  SelectCredentialsForProofRequestOptions,\n  SelectCredentialsForProofRequestReturn,\n  SendProofProblemReportOptions,\n} from './DidCommProofsApiOptions'\nimport { DidCommProofsModuleConfig } from './DidCommProofsModuleConfig'\nimport { DidCommProofState } from './models/DidCommProofState'\nimport type { DidCommProofProtocol } from './protocol/DidCommProofProtocol'\nimport type { ProofFormatsFromProtocols } from './protocol/DidCommProofProtocolOptions'\nimport type { DidCommProofExchangeRecord } from './repository/DidCommProofExchangeRecord'\nimport { DidCommProofExchangeRepository } from './repository/DidCommProofExchangeRepository'\n\nexport interface DidCommProofsApi<PPs extends DidCommProofProtocol[]> {\n  // Proposal methods\n  proposeProof(options: ProposeProofOptions<PPs>): Promise<DidCommProofExchangeRecord>\n  acceptProposal(options: AcceptProofProposalOptions<PPs>): Promise<DidCommProofExchangeRecord>\n  negotiateProposal(options: NegotiateProofProposalOptions<PPs>): Promise<DidCommProofExchangeRecord>\n\n  // Request methods\n  requestProof(options: RequestProofOptions<PPs>): Promise<DidCommProofExchangeRecord>\n  acceptRequest(options: AcceptProofRequestOptions<PPs>): Promise<DidCommProofExchangeRecord>\n  declineRequest(options: DeclineProofRequestOptions): Promise<DidCommProofExchangeRecord>\n  negotiateRequest(options: NegotiateProofRequestOptions<PPs>): Promise<DidCommProofExchangeRecord>\n\n  // Present\n  acceptPresentation(options: AcceptProofOptions): Promise<DidCommProofExchangeRecord>\n\n  // out of band\n  createRequest(options: CreateProofRequestOptions<PPs>): Promise<{\n    message: DidCommMessage\n    proofRecord: DidCommProofExchangeRecord\n  }>\n  createProofProposal(options: CreateProofProposalOptions<PPs>): Promise<{\n    message: DidCommMessage\n    proofRecord: DidCommProofExchangeRecord\n  }>\n\n  // Auto Select\n  selectCredentialsForRequest(\n    options: SelectCredentialsForProofRequestOptions<PPs>\n  ): Promise<SelectCredentialsForProofRequestReturn<PPs>>\n\n  // Get credentials for request\n  getCredentialsForRequest(\n    options: GetCredentialsForProofRequestOptions<PPs>\n  ): Promise<GetCredentialsForProofRequestReturn<PPs>>\n\n  sendProblemReport(options: SendProofProblemReportOptions): Promise<DidCommProofExchangeRecord>\n\n  // Record Methods\n  getAll(): Promise<DidCommProofExchangeRecord[]>\n  findAllByQuery(\n    query: Query<DidCommProofExchangeRecord>,\n    queryOptions?: QueryOptions\n  ): Promise<DidCommProofExchangeRecord[]>\n  getById(proofExchangeRecordId: string): Promise<DidCommProofExchangeRecord>\n  findById(proofExchangeRecordId: string): Promise<DidCommProofExchangeRecord | null>\n  deleteById(proofId: string, options?: DeleteProofOptions): Promise<void>\n  update(proofRecord: DidCommProofExchangeRecord): Promise<void>\n  getFormatData(proofExchangeRecordId: string): Promise<GetProofFormatDataReturn<ProofFormatsFromProtocols<PPs>>>\n\n  // DidComm Message Records\n  findProposalMessage(proofExchangeRecordId: string): Promise<FindProofProposalMessageReturn<PPs>>\n  findRequestMessage(proofExchangeRecordId: string): Promise<FindProofRequestMessageReturn<PPs>>\n  findPresentationMessage(proofExchangeRecordId: string): Promise<FindProofPresentationMessageReturn<PPs>>\n}\n\n@injectable()\n// biome-ignore lint/suspicious/noUnsafeDeclarationMerging: no explanation\nexport class DidCommProofsApi<PPs extends DidCommProofProtocol[]> implements DidCommProofsApi<PPs> {\n  /**\n   * Configuration for the proofs module\n   */\n  public readonly config: DidCommProofsModuleConfig<PPs>\n\n  private connectionService: DidCommConnectionService\n  private messageSender: DidCommMessageSender\n  private proofRepository: DidCommProofExchangeRepository\n  private agentContext: AgentContext\n\n  public constructor(\n    messageSender: DidCommMessageSender,\n    connectionService: DidCommConnectionService,\n    agentContext: AgentContext,\n    proofRepository: DidCommProofExchangeRepository,\n    config: DidCommProofsModuleConfig<PPs>\n  ) {\n    this.messageSender = messageSender\n    this.connectionService = connectionService\n    this.proofRepository = proofRepository\n    this.agentContext = agentContext\n    this.config = config\n  }\n\n  private getProtocol<PVT extends PPs[number]['version']>(protocolVersion: PVT): DidCommProofProtocol {\n    const proofProtocol = this.config.proofProtocols.find((protocol) => protocol.version === protocolVersion)\n\n    if (!proofProtocol) {\n      throw new CredoError(`No proof protocol registered for protocol version ${protocolVersion}`)\n    }\n\n    return proofProtocol\n  }\n\n  /**\n   * Initiate a new presentation exchange as prover by sending a presentation proposal message\n   * to the connection with the specified connection id.\n   *\n   * @param options configuration to use for the proposal\n   * @returns Proof exchange record associated with the sent proposal message\n   */\n  public async proposeProof(options: ProposeProofOptions<PPs>): Promise<DidCommProofExchangeRecord> {\n    const protocol = this.getProtocol(options.protocolVersion)\n\n    const connectionRecord = await this.connectionService.getById(this.agentContext, options.connectionId)\n\n    // Assert\n    connectionRecord.assertReady()\n\n    const { message, proofRecord } = await protocol.createProposal(this.agentContext, {\n      connectionRecord,\n      proofFormats: options.proofFormats,\n      autoAcceptProof: options.autoAcceptProof,\n      goalCode: options.goalCode,\n      goal: options.goal,\n      comment: options.comment,\n      parentThreadId: options.parentThreadId,\n    })\n\n    const outboundMessageContext = await getOutboundDidCommMessageContext(this.agentContext, {\n      message,\n      associatedRecord: proofRecord,\n      connectionRecord,\n    })\n\n    await this.messageSender.sendMessage(outboundMessageContext)\n    return proofRecord\n  }\n\n  /**\n   * Initiate a new presentation exchange as prover by sending an out of band proof proposal message\n   *\n   * @param options multiple properties like protocol version, proof Formats to build the proof request\n   * @returns the message itself and the proof record associated with the sent request message\n   */\n  public async createProofProposal(options: CreateProofProposalOptions<PPs>): Promise<{\n    message: DidCommMessage\n    proofRecord: DidCommProofExchangeRecord\n  }> {\n    const protocol = this.getProtocol(options.protocolVersion)\n\n    return await protocol.createProposal(this.agentContext, {\n      proofFormats: options.proofFormats,\n      autoAcceptProof: options.autoAcceptProof,\n      goalCode: options.goalCode,\n      comment: options.comment,\n      parentThreadId: options.parentThreadId,\n    })\n  }\n\n  /**\n   * Accept a presentation proposal as verifier (by sending a presentation request message) to the connection\n   * associated with the proof record.\n   *\n   * @param options config object for accepting the proposal\n   * @returns Proof exchange record associated with the presentation request\n   */\n  public async acceptProposal(options: AcceptProofProposalOptions<PPs>): Promise<DidCommProofExchangeRecord> {\n    const proofRecord = await this.getById(options.proofExchangeRecordId)\n\n    if (!proofRecord.connectionId) {\n      throw new CredoError(\n        `No connectionId found for proof record '${proofRecord.id}'. Connection-less verification does not support presentation proposal or negotiation.`\n      )\n    }\n\n    // with version we can get the protocol\n    const protocol = this.getProtocol(proofRecord.protocolVersion)\n    const connectionRecord = await this.connectionService.getById(this.agentContext, proofRecord.connectionId)\n\n    // Assert\n    connectionRecord.assertReady()\n\n    const { message } = await protocol.acceptProposal(this.agentContext, {\n      proofRecord,\n      proofFormats: options.proofFormats,\n      goalCode: options.goalCode,\n      goal: options.goal,\n      willConfirm: options.willConfirm,\n      comment: options.comment,\n      autoAcceptProof: options.autoAcceptProof,\n    })\n\n    // send the message\n    const outboundMessageContext = await getOutboundDidCommMessageContext(this.agentContext, {\n      message,\n      associatedRecord: proofRecord,\n      connectionRecord,\n    })\n\n    await this.messageSender.sendMessage(outboundMessageContext)\n    return proofRecord\n  }\n\n  /**\n   * Answer with a new presentation request in response to received presentation proposal message\n   * to the connection associated with the proof record.\n   *\n   * @param options multiple properties like proof record id, proof formats to accept requested credentials object\n   * specifying which credentials to use for the proof\n   * @returns Proof record associated with the sent request message\n   */\n  public async negotiateProposal(options: NegotiateProofProposalOptions<PPs>): Promise<DidCommProofExchangeRecord> {\n    const proofRecord = await this.getById(options.proofExchangeRecordId)\n\n    if (!proofRecord.connectionId) {\n      throw new CredoError(\n        `No connectionId found for proof record '${proofRecord.id}'. Connection-less verification does not support negotiation.`\n      )\n    }\n\n    const protocol = this.getProtocol(proofRecord.protocolVersion)\n    const connectionRecord = await this.connectionService.getById(this.agentContext, proofRecord.connectionId)\n\n    // Assert\n    connectionRecord.assertReady()\n\n    const { message } = await protocol.negotiateProposal(this.agentContext, {\n      proofRecord,\n      proofFormats: options.proofFormats,\n      autoAcceptProof: options.autoAcceptProof,\n      comment: options.comment,\n      goalCode: options.goalCode,\n      goal: options.goal,\n      willConfirm: options.willConfirm,\n    })\n\n    const outboundMessageContext = await getOutboundDidCommMessageContext(this.agentContext, {\n      message,\n      associatedRecord: proofRecord,\n      connectionRecord,\n    })\n    await this.messageSender.sendMessage(outboundMessageContext)\n\n    return proofRecord\n  }\n\n  /**\n   * Initiate a new presentation exchange as verifier by sending a presentation request message\n   * to the connection with the specified connection id\n   *\n   * @param options multiple properties like connection id, protocol version, proof Formats to build the proof request\n   * @returns Proof record associated with the sent request message\n   */\n  public async requestProof(options: RequestProofOptions<PPs>): Promise<DidCommProofExchangeRecord> {\n    const connectionRecord = await this.connectionService.getById(this.agentContext, options.connectionId)\n    const protocol = this.getProtocol(options.protocolVersion)\n\n    // Assert\n    connectionRecord.assertReady()\n\n    const { message, proofRecord } = await protocol.createRequest(this.agentContext, {\n      connectionRecord,\n      proofFormats: options.proofFormats,\n      autoAcceptProof: options.autoAcceptProof,\n      parentThreadId: options.parentThreadId,\n      comment: options.comment,\n      goalCode: options.goalCode,\n      goal: options.goal,\n      willConfirm: options.willConfirm,\n    })\n\n    const outboundMessageContext = await getOutboundDidCommMessageContext(this.agentContext, {\n      message,\n      associatedRecord: proofRecord,\n      connectionRecord,\n    })\n\n    await this.messageSender.sendMessage(outboundMessageContext)\n    return proofRecord\n  }\n\n  /**\n   * Accept a presentation request as prover (by sending a presentation message) to the connection\n   * associated with the proof record.\n   *\n   * @param options multiple properties like proof record id, proof formats to accept requested credentials object\n   * specifying which credentials to use for the proof\n   * @returns Proof record associated with the sent presentation message\n   */\n  public async acceptRequest(options: AcceptProofRequestOptions<PPs>): Promise<DidCommProofExchangeRecord> {\n    const proofRecord = await this.getById(options.proofExchangeRecordId)\n\n    const protocol = this.getProtocol(proofRecord.protocolVersion)\n\n    const requestMessage = await protocol.findRequestMessage(this.agentContext, proofRecord.id)\n    if (!requestMessage) {\n      throw new CredoError(`No request message found for proof record with id '${proofRecord.id}'`)\n    }\n\n    // Use connection if present\n    const connectionRecord = proofRecord.connectionId\n      ? await this.connectionService.getById(this.agentContext, proofRecord.connectionId)\n      : undefined\n    connectionRecord?.assertReady()\n\n    const { message } = await protocol.acceptRequest(this.agentContext, {\n      proofFormats: options.proofFormats,\n      proofRecord,\n      comment: options.comment,\n      autoAcceptProof: options.autoAcceptProof,\n      goalCode: options.goalCode,\n      goal: options.goal,\n    })\n\n    const outboundMessageContext = await getOutboundDidCommMessageContext(this.agentContext, {\n      message,\n      connectionRecord,\n      associatedRecord: proofRecord,\n      lastReceivedMessage: requestMessage,\n    })\n    await this.messageSender.sendMessage(outboundMessageContext)\n\n    return proofRecord\n  }\n\n  public async declineRequest(options: DeclineProofRequestOptions): Promise<DidCommProofExchangeRecord> {\n    const proofRecord = await this.getById(options.proofExchangeRecordId)\n    proofRecord.assertState(DidCommProofState.RequestReceived)\n\n    const protocol = this.getProtocol(proofRecord.protocolVersion)\n    if (options.sendProblemReport) {\n      await this.sendProblemReport({\n        proofExchangeRecordId: options.proofExchangeRecordId,\n        description: options.problemReportDescription ?? 'Request declined',\n      })\n    }\n\n    await protocol.updateState(this.agentContext, proofRecord, DidCommProofState.Declined)\n\n    return proofRecord\n  }\n\n  /**\n   * Answer with a new presentation proposal in response to received presentation request message\n   * to the connection associated with the proof record.\n   *\n   * @param options multiple properties like proof record id, proof format (indy/ presentation exchange)\n   * to include in the message\n   * @returns Proof record associated with the sent proposal message\n   */\n  public async negotiateRequest(options: NegotiateProofRequestOptions<PPs>): Promise<DidCommProofExchangeRecord> {\n    const proofRecord = await this.getById(options.proofExchangeRecordId)\n\n    if (!proofRecord.connectionId) {\n      throw new CredoError(\n        `No connectionId found for proof record '${proofRecord.id}'. Connection-less verification does not support presentation proposal or negotiation.`\n      )\n    }\n\n    const connectionRecord = await this.connectionService.getById(this.agentContext, proofRecord.connectionId)\n\n    // Assert\n    connectionRecord.assertReady()\n\n    const protocol = this.getProtocol(proofRecord.protocolVersion)\n    const { message } = await protocol.negotiateRequest(this.agentContext, {\n      proofRecord,\n      proofFormats: options.proofFormats,\n      autoAcceptProof: options.autoAcceptProof,\n      goalCode: options.goalCode,\n      goal: options.goal,\n      comment: options.comment,\n    })\n\n    const outboundMessageContext = await getOutboundDidCommMessageContext(this.agentContext, {\n      message,\n      connectionRecord,\n      associatedRecord: proofRecord,\n    })\n    await this.messageSender.sendMessage(outboundMessageContext)\n\n    return proofRecord\n  }\n\n  /**\n   * Initiate a new presentation exchange as verifier by sending an out of band presentation\n   * request message\n   *\n   * @param options multiple properties like protocol version, proof Formats to build the proof request\n   * @returns the message itself and the proof record associated with the sent request message\n   */\n  public async createRequest(options: CreateProofRequestOptions<PPs>): Promise<{\n    message: DidCommMessage\n    proofRecord: DidCommProofExchangeRecord\n  }> {\n    const protocol = this.getProtocol(options.protocolVersion)\n\n    return await protocol.createRequest(this.agentContext, {\n      proofFormats: options.proofFormats,\n      autoAcceptProof: options.autoAcceptProof,\n      comment: options.comment,\n      parentThreadId: options.parentThreadId,\n      goalCode: options.goalCode,\n      goal: options.goal,\n      willConfirm: options.willConfirm,\n    })\n  }\n\n  /**\n   * Accept a presentation as prover (by sending a presentation acknowledgement message) to the connection\n   * associated with the proof record.\n   *\n   * @param proofExchangeRecordId The id of the proof exchange record for which to accept the presentation\n   * @returns Proof record associated with the sent presentation acknowledgement message\n   *\n   */\n  public async acceptPresentation(options: AcceptProofOptions): Promise<DidCommProofExchangeRecord> {\n    const proofRecord = await this.getById(options.proofExchangeRecordId)\n    const protocol = this.getProtocol(proofRecord.protocolVersion)\n\n    const requestMessage = await protocol.findRequestMessage(this.agentContext, proofRecord.id)\n    if (!requestMessage) {\n      throw new CredoError(`No request message found for proof record with id '${proofRecord.id}'`)\n    }\n\n    const presentationMessage = await protocol.findPresentationMessage(this.agentContext, proofRecord.id)\n    if (!presentationMessage) {\n      throw new CredoError(`No presentation message found for proof record with id '${proofRecord.id}'`)\n    }\n\n    // Use connection if present\n    const connectionRecord = proofRecord.connectionId\n      ? await this.connectionService.getById(this.agentContext, proofRecord.connectionId)\n      : undefined\n    connectionRecord?.assertReady()\n\n    const { message } = await protocol.acceptPresentation(this.agentContext, {\n      proofRecord,\n    })\n\n    // FIXME: returnRoute: false\n    const outboundMessageContext = await getOutboundDidCommMessageContext(this.agentContext, {\n      message,\n      connectionRecord,\n      associatedRecord: proofRecord,\n      lastSentMessage: requestMessage,\n      lastReceivedMessage: presentationMessage,\n    })\n    await this.messageSender.sendMessage(outboundMessageContext)\n\n    return proofRecord\n  }\n\n  /**\n   * Create a {@link RetrievedCredentials} object. Given input proof request and presentation proposal,\n   * use credentials in the wallet to build indy requested credentials object for input to proof creation.\n   * If restrictions allow, self attested attributes will be used.\n   *\n   * @param options multiple properties like proof record id and optional configuration\n   * @returns RequestedCredentials\n   */\n  public async selectCredentialsForRequest(\n    options: SelectCredentialsForProofRequestOptions<PPs>\n  ): Promise<SelectCredentialsForProofRequestReturn<PPs>> {\n    const proofRecord = await this.getById(options.proofExchangeRecordId)\n\n    const protocol = this.getProtocol(proofRecord.protocolVersion)\n\n    return protocol.selectCredentialsForRequest(this.agentContext, {\n      proofFormats: options.proofFormats,\n      proofRecord,\n    })\n  }\n\n  /**\n   * Get credentials in the wallet for a received proof request.\n   *\n   * @param options multiple properties like proof record id and optional configuration\n   */\n  public async getCredentialsForRequest(\n    options: GetCredentialsForProofRequestOptions<PPs>\n  ): Promise<GetCredentialsForProofRequestReturn<PPs>> {\n    const proofRecord = await this.getById(options.proofExchangeRecordId)\n\n    const protocol = this.getProtocol(proofRecord.protocolVersion)\n\n    return protocol.getCredentialsForRequest(this.agentContext, {\n      proofRecord,\n      proofFormats: options.proofFormats,\n    })\n  }\n\n  /**\n   * Send problem report message for a proof record\n   *\n   * @param proofExchangeRecordId  The id of the proof record for which to send problem report\n   * @param message message to send\n   * @returns proof record associated with the proof problem report message\n   */\n  public async sendProblemReport(options: SendProofProblemReportOptions): Promise<DidCommProofExchangeRecord> {\n    const proofRecord = await this.getById(options.proofExchangeRecordId)\n\n    const protocol = this.getProtocol(proofRecord.protocolVersion)\n\n    const requestMessage = await protocol.findRequestMessage(this.agentContext, proofRecord.id)\n\n    const proposalMessage = await protocol.findProposalMessage(this.agentContext, proofRecord.id)\n\n    const { message: problemReport } = await protocol.createProblemReport(this.agentContext, {\n      proofRecord,\n      description: options.description,\n    })\n\n    // Use connection if present\n    const connectionRecord = proofRecord.connectionId\n      ? await this.connectionService.getById(this.agentContext, proofRecord.connectionId)\n      : undefined\n    connectionRecord?.assertReady()\n\n    // If there's no connection (so connection-less, we require the state to be request received or proposal sent)\n    if (!connectionRecord) {\n      proofRecord.assertState([DidCommProofState.RequestReceived, DidCommProofState.ProposalSent])\n\n      if (!requestMessage && !proposalMessage) {\n        throw new CredoError(`No request or proposal message found for proof record with id '${proofRecord.id}'`)\n      }\n    }\n\n    const outboundMessageContext = await getOutboundDidCommMessageContext(this.agentContext, {\n      message: problemReport,\n      connectionRecord,\n      associatedRecord: proofRecord,\n      lastSentMessage: proposalMessage ?? undefined,\n      lastReceivedMessage: requestMessage ?? undefined,\n    })\n    await this.messageSender.sendMessage(outboundMessageContext)\n\n    return proofRecord\n  }\n\n  public async getFormatData(\n    proofExchangeRecordId: string\n  ): Promise<GetProofFormatDataReturn<ProofFormatsFromProtocols<PPs>>> {\n    const proofRecord = await this.getById(proofExchangeRecordId)\n    const protocol = this.getProtocol(proofRecord.protocolVersion)\n\n    return protocol.getFormatData(this.agentContext, proofExchangeRecordId)\n  }\n\n  /**\n   * Retrieve all proof records\n   *\n   * @returns List containing all proof records\n   */\n  public async getAll(): Promise<DidCommProofExchangeRecord[]> {\n    return this.proofRepository.getAll(this.agentContext)\n  }\n\n  /**\n   * Retrieve all proof records by specified query params\n   *\n   * @returns List containing all proof records matching specified params\n   */\n  public findAllByQuery(\n    query: Query<DidCommProofExchangeRecord>,\n    queryOptions?: QueryOptions\n  ): Promise<DidCommProofExchangeRecord[]> {\n    return this.proofRepository.findByQuery(this.agentContext, query, queryOptions)\n  }\n\n  /**\n   * Retrieve a proof record by id\n   *\n   * @param proofExchangeRecordId The proof record id\n   * @throws {RecordNotFoundError} If no record is found\n   * @return The proof record\n   *\n   */\n  public async getById(proofExchangeRecordId: string): Promise<DidCommProofExchangeRecord> {\n    return await this.proofRepository.getById(this.agentContext, proofExchangeRecordId)\n  }\n\n  /**\n   * Retrieve a proof record by id\n   *\n   * @param proofExchangeRecordId The proof record id\n   * @return The proof record or null if not found\n   *\n   */\n  public async findById(proofExchangeRecordId: string): Promise<DidCommProofExchangeRecord | null> {\n    return await this.proofRepository.findById(this.agentContext, proofExchangeRecordId)\n  }\n\n  /**\n   * Delete a proof record by id\n   *\n   * @param proofId the proof record id\n   */\n  public async deleteById(proofId: string, options?: DeleteProofOptions) {\n    const proofRecord = await this.getById(proofId)\n    const protocol = this.getProtocol(proofRecord.protocolVersion)\n    return protocol.delete(this.agentContext, proofRecord, options)\n  }\n\n  /**\n   * Retrieve a proof record by connection id and thread id\n   *\n   * @param connectionId The connection id\n   * @param threadId The thread id\n   * @throws {RecordNotFoundError} If no record is found\n   * @throws {RecordDuplicateError} If multiple records are found\n   * @returns The proof record\n   */\n  public async getByThreadAndConnectionId(\n    threadId: string,\n    connectionId?: string\n  ): Promise<DidCommProofExchangeRecord> {\n    return this.proofRepository.getByThreadAndConnectionId(this.agentContext, threadId, connectionId)\n  }\n\n  /**\n   * Retrieve proof records by connection id and parent thread id\n   *\n   * @param connectionId The connection id\n   * @param parentThreadId The parent thread id\n   * @returns List containing all proof records matching the given query\n   */\n  public async getByParentThreadAndConnectionId(\n    parentThreadId: string,\n    connectionId?: string\n  ): Promise<DidCommProofExchangeRecord[]> {\n    return this.proofRepository.getByParentThreadAndConnectionId(this.agentContext, parentThreadId, connectionId)\n  }\n\n  /**\n   * Update a proof record by\n   *\n   * @param proofRecord the proof record\n   */\n  public async update(proofRecord: DidCommProofExchangeRecord): Promise<void> {\n    await this.proofRepository.update(this.agentContext, proofRecord)\n  }\n\n  public async findProposalMessage(proofExchangeRecordId: string): Promise<FindProofProposalMessageReturn<PPs>> {\n    const record = await this.getById(proofExchangeRecordId)\n    const protocol = this.getProtocol(record.protocolVersion)\n    return protocol.findProposalMessage(this.agentContext, proofExchangeRecordId) as FindProofProposalMessageReturn<PPs>\n  }\n\n  public async findRequestMessage(proofExchangeRecordId: string): Promise<FindProofRequestMessageReturn<PPs>> {\n    const record = await this.getById(proofExchangeRecordId)\n    const protocol = this.getProtocol(record.protocolVersion)\n    return protocol.findRequestMessage(this.agentContext, proofExchangeRecordId) as FindProofRequestMessageReturn<PPs>\n  }\n\n  public async findPresentationMessage(\n    proofExchangeRecordId: string\n  ): Promise<FindProofPresentationMessageReturn<PPs>> {\n    const record = await this.getById(proofExchangeRecordId)\n    const protocol = this.getProtocol(record.protocolVersion)\n    return protocol.findPresentationMessage(\n      this.agentContext,\n      proofExchangeRecordId\n    ) as FindProofPresentationMessageReturn<PPs>\n  }\n}\n"],"mappings":"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"}