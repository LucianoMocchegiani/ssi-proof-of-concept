{"version":3,"file":"DidCommBaseProofProtocol.mjs","names":[],"sources":["../../../../src/modules/proofs/protocol/DidCommBaseProofProtocol.ts"],"sourcesContent":["import type { AgentContext, Query, QueryOptions } from '@credo-ts/core'\nimport { EventEmitter } from '@credo-ts/core'\nimport type { DidCommFeatureRegistry } from '../../../DidCommFeatureRegistry'\nimport type { DidCommMessage } from '../../../DidCommMessage'\nimport type { DidCommMessageHandlerRegistry } from '../../../DidCommMessageHandlerRegistry'\nimport type { DidCommProblemReportMessage } from '../../../messages'\nimport type { DidCommInboundMessageContext } from '../../../models'\nimport { DidCommMessageRepository } from '../../../repository'\nimport { DidCommConnectionService } from '../../connections'\nimport type { DidCommProofStateChangedEvent } from '../DidCommProofEvents'\nimport { DidCommProofEventTypes } from '../DidCommProofEvents'\nimport type { DidCommProofFormatService, ExtractProofFormats } from '../formats'\nimport type { DidCommProofRole } from '../models'\nimport { DidCommProofState } from '../models/DidCommProofState'\nimport type { DidCommProofExchangeRecord } from '../repository'\nimport { DidCommProofExchangeRepository } from '../repository'\nimport type { DidCommProofProtocol } from './DidCommProofProtocol'\nimport type {\n  AcceptPresentationOptions,\n  AcceptProofProposalOptions,\n  AcceptProofRequestOptions,\n  CreateProofProblemReportOptions,\n  CreateProofProposalOptions,\n  CreateProofRequestOptions,\n  DeleteProofOptions,\n  GetCredentialsForRequestOptions,\n  GetCredentialsForRequestReturn,\n  GetProofFormatDataReturn,\n  NegotiateProofProposalOptions,\n  NegotiateProofRequestOptions,\n  ProofProtocolMsgReturnType,\n  SelectCredentialsForRequestOptions,\n  SelectCredentialsForRequestReturn,\n} from './DidCommProofProtocolOptions'\n\nexport abstract class DidCommBaseProofProtocol<PFs extends DidCommProofFormatService[] = DidCommProofFormatService[]>\n  implements DidCommProofProtocol<PFs>\n{\n  public abstract readonly version: string\n\n  public abstract register(\n    messageHandlerRegistry: DidCommMessageHandlerRegistry,\n    featureRegistry: DidCommFeatureRegistry\n  ): void\n\n  // methods for proposal\n  public abstract createProposal(\n    agentContext: AgentContext,\n    options: CreateProofProposalOptions<PFs>\n  ): Promise<ProofProtocolMsgReturnType<DidCommMessage>>\n  public abstract processProposal(\n    messageContext: DidCommInboundMessageContext<DidCommMessage>\n  ): Promise<DidCommProofExchangeRecord>\n  public abstract acceptProposal(\n    agentContext: AgentContext,\n    options: AcceptProofProposalOptions<PFs>\n  ): Promise<ProofProtocolMsgReturnType<DidCommMessage>>\n  public abstract negotiateProposal(\n    agentContext: AgentContext,\n    options: NegotiateProofProposalOptions<PFs>\n  ): Promise<ProofProtocolMsgReturnType<DidCommMessage>>\n\n  // methods for request\n  public abstract createRequest(\n    agentContext: AgentContext,\n    options: CreateProofRequestOptions<PFs>\n  ): Promise<ProofProtocolMsgReturnType<DidCommMessage>>\n  public abstract processRequest(\n    messageContext: DidCommInboundMessageContext<DidCommMessage>\n  ): Promise<DidCommProofExchangeRecord>\n  public abstract acceptRequest(\n    agentContext: AgentContext,\n    options: AcceptProofRequestOptions<PFs>\n  ): Promise<ProofProtocolMsgReturnType<DidCommMessage>>\n  public abstract negotiateRequest(\n    agentContext: AgentContext,\n    options: NegotiateProofRequestOptions<PFs>\n  ): Promise<ProofProtocolMsgReturnType<DidCommMessage>>\n\n  // retrieving credentials for request\n  public abstract getCredentialsForRequest(\n    agentContext: AgentContext,\n    options: GetCredentialsForRequestOptions<PFs>\n  ): Promise<GetCredentialsForRequestReturn<PFs>>\n  public abstract selectCredentialsForRequest(\n    agentContext: AgentContext,\n    options: SelectCredentialsForRequestOptions<PFs>\n  ): Promise<SelectCredentialsForRequestReturn<PFs>>\n\n  // methods for presentation\n  public abstract processPresentation(\n    messageContext: DidCommInboundMessageContext<DidCommMessage>\n  ): Promise<DidCommProofExchangeRecord>\n  public abstract acceptPresentation(\n    agentContext: AgentContext,\n    options: AcceptPresentationOptions\n  ): Promise<ProofProtocolMsgReturnType<DidCommMessage>>\n\n  // methods for ack\n  public abstract processAck(\n    messageContext: DidCommInboundMessageContext<DidCommMessage>\n  ): Promise<DidCommProofExchangeRecord>\n  // method for problem report\n  public abstract createProblemReport(\n    agentContext: AgentContext,\n    options: CreateProofProblemReportOptions\n  ): Promise<ProofProtocolMsgReturnType<DidCommProblemReportMessage>>\n\n  public abstract findProposalMessage(\n    agentContext: AgentContext,\n    proofExchangeId: string\n  ): Promise<DidCommMessage | null>\n  public abstract findRequestMessage(\n    agentContext: AgentContext,\n    proofExchangeId: string\n  ): Promise<DidCommMessage | null>\n  public abstract findPresentationMessage(\n    agentContext: AgentContext,\n    proofExchangeId: string\n  ): Promise<DidCommMessage | null>\n  public abstract getFormatData(\n    agentContext: AgentContext,\n    proofExchangeId: string\n  ): Promise<GetProofFormatDataReturn<ExtractProofFormats<PFs>>>\n\n  public async processProblemReport(\n    messageContext: DidCommInboundMessageContext<DidCommProblemReportMessage>\n  ): Promise<DidCommProofExchangeRecord> {\n    const { message: proofProblemReportMessage, agentContext, connection } = messageContext\n\n    const connectionService = agentContext.dependencyManager.resolve(DidCommConnectionService)\n\n    agentContext.config.logger.debug(`Processing problem report with message id ${proofProblemReportMessage.id}`)\n\n    const proofRecord = await this.getByProperties(agentContext, {\n      threadId: proofProblemReportMessage.threadId,\n    })\n\n    // Assert\n    await connectionService.assertConnectionOrOutOfBandExchange(messageContext, {\n      expectedConnectionId: proofRecord.connectionId,\n    })\n\n    //  This makes sure that the sender of the incoming message is authorized to do so.\n    if (!proofRecord?.connectionId) {\n      await connectionService.matchIncomingMessageToRequestMessageInOutOfBandExchange(messageContext, {\n        expectedConnectionId: proofRecord?.connectionId,\n      })\n\n      proofRecord.connectionId = connection?.id\n    }\n\n    // Update record\n    proofRecord.errorMessage = `${proofProblemReportMessage.description.code}: ${proofProblemReportMessage.description.en}`\n    await this.updateState(agentContext, proofRecord, DidCommProofState.Abandoned)\n    return proofRecord\n  }\n\n  /**\n   * Update the record to a new state and emit an state changed event. Also updates the record\n   * in storage.\n   *\n   * @param proofRecord The proof record to update the state for\n   * @param newState The state to update to\n   *\n   */\n  public async updateState(\n    agentContext: AgentContext,\n    proofRecord: DidCommProofExchangeRecord,\n    newState: DidCommProofState\n  ) {\n    const proofRepository = agentContext.dependencyManager.resolve(DidCommProofExchangeRepository)\n\n    agentContext.config.logger.debug(\n      `Updating proof record ${proofRecord.id} to state ${newState} (previous=${proofRecord.state})`\n    )\n\n    const previousState = proofRecord.state\n    proofRecord.state = newState\n    await proofRepository.update(agentContext, proofRecord)\n\n    this.emitStateChangedEvent(agentContext, proofRecord, previousState)\n  }\n\n  protected emitStateChangedEvent(\n    agentContext: AgentContext,\n    proofRecord: DidCommProofExchangeRecord,\n    previousState: DidCommProofState | null\n  ) {\n    const eventEmitter = agentContext.dependencyManager.resolve(EventEmitter)\n\n    eventEmitter.emit<DidCommProofStateChangedEvent>(agentContext, {\n      type: DidCommProofEventTypes.ProofStateChanged,\n      payload: {\n        proofRecord: proofRecord.clone(),\n        previousState: previousState,\n      },\n    })\n  }\n\n  /**\n   * Retrieve a proof record by id\n   *\n   * @param proofExchangeRecordId The proof record id\n   * @throws {RecordNotFoundError} If no record is found\n   * @return The proof record\n   *\n   */\n  public getById(agentContext: AgentContext, proofExchangeRecordId: string): Promise<DidCommProofExchangeRecord> {\n    const proofRepository = agentContext.dependencyManager.resolve(DidCommProofExchangeRepository)\n\n    return proofRepository.getById(agentContext, proofExchangeRecordId)\n  }\n\n  /**\n   * Retrieve all proof records\n   *\n   * @returns List containing all proof records\n   */\n  public getAll(agentContext: AgentContext): Promise<DidCommProofExchangeRecord[]> {\n    const proofRepository = agentContext.dependencyManager.resolve(DidCommProofExchangeRepository)\n\n    return proofRepository.getAll(agentContext)\n  }\n\n  public async findAllByQuery(\n    agentContext: AgentContext,\n    query: Query<DidCommProofExchangeRecord>,\n    queryOptions?: QueryOptions\n  ): Promise<DidCommProofExchangeRecord[]> {\n    const proofRepository = agentContext.dependencyManager.resolve(DidCommProofExchangeRepository)\n\n    return proofRepository.findByQuery(agentContext, query, queryOptions)\n  }\n\n  /**\n   * Find a proof record by id\n   *\n   * @param proofExchangeRecordId the proof record id\n   * @returns The proof record or null if not found\n   */\n  public findById(\n    agentContext: AgentContext,\n    proofExchangeRecordId: string\n  ): Promise<DidCommProofExchangeRecord | null> {\n    const proofRepository = agentContext.dependencyManager.resolve(DidCommProofExchangeRepository)\n\n    return proofRepository.findById(agentContext, proofExchangeRecordId)\n  }\n\n  public async delete(\n    agentContext: AgentContext,\n    proofRecord: DidCommProofExchangeRecord,\n    options?: DeleteProofOptions\n  ): Promise<void> {\n    const proofRepository = agentContext.dependencyManager.resolve(DidCommProofExchangeRepository)\n    const didCommMessageRepository = agentContext.dependencyManager.resolve(DidCommMessageRepository)\n\n    await proofRepository.delete(agentContext, proofRecord)\n\n    const deleteAssociatedDidCommMessages = options?.deleteAssociatedDidCommMessages ?? true\n\n    if (deleteAssociatedDidCommMessages) {\n      const didCommMessages = await didCommMessageRepository.findByQuery(agentContext, {\n        associatedRecordId: proofRecord.id,\n      })\n      for (const didCommMessage of didCommMessages) {\n        await didCommMessageRepository.delete(agentContext, didCommMessage)\n      }\n    }\n  }\n\n  /**\n   * Retrieve a proof record by connection id and thread id\n   *\n   * @param properties Properties to query by\n   *\n   * @throws {RecordNotFoundError} If no record is found\n   * @throws {RecordDuplicateError} If multiple records are found\n   *\n   * @returns The proof record\n   */\n  public getByProperties(\n    agentContext: AgentContext,\n    properties: {\n      threadId: string\n      role?: DidCommProofRole\n      connectionId?: string\n    }\n  ): Promise<DidCommProofExchangeRecord> {\n    const { threadId, connectionId, role } = properties\n    const proofRepository = agentContext.dependencyManager.resolve(DidCommProofExchangeRepository)\n\n    return proofRepository.getSingleByQuery(agentContext, {\n      connectionId,\n      threadId,\n      role,\n    })\n  }\n\n  /**\n   * Find a proof record by connection id and thread id, returns null if not found\n   *\n   * @param properties Properties to query by\n   *\n   * @returns The proof record\n   */\n  public findByProperties(\n    agentContext: AgentContext,\n    properties: {\n      threadId: string\n      role?: DidCommProofRole\n      connectionId?: string\n    }\n  ): Promise<DidCommProofExchangeRecord | null> {\n    const { role, connectionId, threadId } = properties\n    const proofRepository = agentContext.dependencyManager.resolve(DidCommProofExchangeRepository)\n\n    return proofRepository.findSingleByQuery(agentContext, {\n      connectionId,\n      threadId,\n      role,\n    })\n  }\n\n  public async update(agentContext: AgentContext, proofRecord: DidCommProofExchangeRecord) {\n    const proofRepository = agentContext.dependencyManager.resolve(DidCommProofExchangeRepository)\n\n    return await proofRepository.update(agentContext, proofRecord)\n  }\n}\n"],"mappings":";;;;;;;;;;;AAmCA,IAAsB,2BAAtB,MAEA;CAwFE,MAAa,qBACX,gBACqC;EACrC,MAAM,EAAE,SAAS,2BAA2B,cAAc,eAAe;EAEzE,MAAM,oBAAoB,aAAa,kBAAkB,QAAQ,yBAAyB;AAE1F,eAAa,OAAO,OAAO,MAAM,6CAA6C,0BAA0B,KAAK;EAE7G,MAAM,cAAc,MAAM,KAAK,gBAAgB,cAAc,EAC3D,UAAU,0BAA0B,UACrC,CAAC;AAGF,QAAM,kBAAkB,oCAAoC,gBAAgB,EAC1E,sBAAsB,YAAY,cACnC,CAAC;AAGF,MAAI,CAAC,aAAa,cAAc;AAC9B,SAAM,kBAAkB,wDAAwD,gBAAgB,EAC9F,sBAAsB,aAAa,cACpC,CAAC;AAEF,eAAY,eAAe,YAAY;;AAIzC,cAAY,eAAe,GAAG,0BAA0B,YAAY,KAAK,IAAI,0BAA0B,YAAY;AACnH,QAAM,KAAK,YAAY,cAAc,aAAa,kBAAkB,UAAU;AAC9E,SAAO;;;;;;;;;;CAWT,MAAa,YACX,cACA,aACA,UACA;EACA,MAAM,kBAAkB,aAAa,kBAAkB,QAAQ,+BAA+B;AAE9F,eAAa,OAAO,OAAO,MACzB,yBAAyB,YAAY,GAAG,YAAY,SAAS,aAAa,YAAY,MAAM,GAC7F;EAED,MAAM,gBAAgB,YAAY;AAClC,cAAY,QAAQ;AACpB,QAAM,gBAAgB,OAAO,cAAc,YAAY;AAEvD,OAAK,sBAAsB,cAAc,aAAa,cAAc;;CAGtE,AAAU,sBACR,cACA,aACA,eACA;AAGA,EAFqB,aAAa,kBAAkB,QAAQ,aAAa,CAE5D,KAAoC,cAAc;GAC7D,MAAM,uBAAuB;GAC7B,SAAS;IACP,aAAa,YAAY,OAAO;IACjB;IAChB;GACF,CAAC;;;;;;;;;;CAWJ,AAAO,QAAQ,cAA4B,uBAAoE;AAG7G,SAFwB,aAAa,kBAAkB,QAAQ,+BAA+B,CAEvE,QAAQ,cAAc,sBAAsB;;;;;;;CAQrE,AAAO,OAAO,cAAmE;AAG/E,SAFwB,aAAa,kBAAkB,QAAQ,+BAA+B,CAEvE,OAAO,aAAa;;CAG7C,MAAa,eACX,cACA,OACA,cACuC;AAGvC,SAFwB,aAAa,kBAAkB,QAAQ,+BAA+B,CAEvE,YAAY,cAAc,OAAO,aAAa;;;;;;;;CASvE,AAAO,SACL,cACA,uBAC4C;AAG5C,SAFwB,aAAa,kBAAkB,QAAQ,+BAA+B,CAEvE,SAAS,cAAc,sBAAsB;;CAGtE,MAAa,OACX,cACA,aACA,SACe;EACf,MAAM,kBAAkB,aAAa,kBAAkB,QAAQ,+BAA+B;EAC9F,MAAM,2BAA2B,aAAa,kBAAkB,QAAQ,yBAAyB;AAEjG,QAAM,gBAAgB,OAAO,cAAc,YAAY;AAIvD,MAFwC,SAAS,mCAAmC,MAE/C;GACnC,MAAM,kBAAkB,MAAM,yBAAyB,YAAY,cAAc,EAC/E,oBAAoB,YAAY,IACjC,CAAC;AACF,QAAK,MAAM,kBAAkB,gBAC3B,OAAM,yBAAyB,OAAO,cAAc,eAAe;;;;;;;;;;;;;CAezE,AAAO,gBACL,cACA,YAKqC;EACrC,MAAM,EAAE,UAAU,cAAc,SAAS;AAGzC,SAFwB,aAAa,kBAAkB,QAAQ,+BAA+B,CAEvE,iBAAiB,cAAc;GACpD;GACA;GACA;GACD,CAAC;;;;;;;;;CAUJ,AAAO,iBACL,cACA,YAK4C;EAC5C,MAAM,EAAE,MAAM,cAAc,aAAa;AAGzC,SAFwB,aAAa,kBAAkB,QAAQ,+BAA+B,CAEvE,kBAAkB,cAAc;GACrD;GACA;GACA;GACD,CAAC;;CAGJ,MAAa,OAAO,cAA4B,aAAyC;AAGvF,SAAO,MAFiB,aAAa,kBAAkB,QAAQ,+BAA+B,CAEjE,OAAO,cAAc,YAAY"}