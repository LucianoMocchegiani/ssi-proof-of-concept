import { DidCommProtocol } from "../../../../models/features/DidCommProtocol.mjs";
import "../../../../models/index.mjs";
import { AckStatus } from "../../../../messages/common/DidCommAckMessage.mjs";
import "../../../../messages/index.mjs";
import { DidCommConnectionService } from "../../../connections/services/DidCommConnectionService.mjs";
import "../../../connections/index.mjs";
import { DidCommMessageRepository } from "../../../../repository/DidCommMessageRepository.mjs";
import { DidCommMessageRole } from "../../../../repository/DidCommMessageRole.mjs";
import "../../../../repository/index.mjs";
import { DidCommAutoAcceptProof } from "../../models/DidCommProofAutoAcceptType.mjs";
import { DidCommProofsModuleConfig } from "../../DidCommProofsModuleConfig.mjs";
import { DidCommProofState } from "../../models/DidCommProofState.mjs";
import { DidCommProofExchangeRecord } from "../../repository/DidCommProofExchangeRecord.mjs";
import { DidCommProofExchangeRepository } from "../../repository/DidCommProofExchangeRepository.mjs";
import { DidCommPresentationProblemReportReason } from "../../errors/DidCommPresentationProblemReportReason.mjs";
import { DidCommProofRole } from "../../models/DidCommProofRole.mjs";
import "../../models/index.mjs";
import "../../repository/index.mjs";
import { composeAutoAccept } from "../../utils/composeAutoAccept.mjs";
import "../../utils/index.mjs";
import { DidCommBaseProofProtocol } from "../DidCommBaseProofProtocol.mjs";
import { DidCommPresentationV2AckMessage } from "./messages/DidCommPresentationV2AckMessage.mjs";
import { DidCommPresentationV2Message } from "./messages/DidCommPresentationV2Message.mjs";
import { DidCommPresentationV2ProblemReportMessage } from "./messages/DidCommPresentationV2ProblemReportMessage.mjs";
import { DidCommProposePresentationV2Message } from "./messages/DidCommProposePresentationV2Message.mjs";
import { DidCommRequestPresentationV2Message } from "./messages/DidCommRequestPresentationV2Message.mjs";
import "./messages/index.mjs";
import { DidCommProofFormatCoordinator } from "./DidCommProofFormatCoordinator.mjs";
import { V2PresentationProblemReportError } from "./errors/V2PresentationProblemReportError.mjs";
import "./errors/index.mjs";
import { DidCommPresentationV2AckHandler } from "./handlers/DidCommPresentationV2AckHandler.mjs";
import { DidCommPresentationV2Handler } from "./handlers/DidCommPresentationV2Handler.mjs";
import { DidCommPresentationV2ProblemReportHandler } from "./handlers/DidCommPresentationV2ProblemReportHandler.mjs";
import { DidCommProposePresentationV2Handler } from "./handlers/DidCommProposePresentationV2Handler.mjs";
import { DidCommRequestPresentationV2Handler } from "./handlers/DidCommRequestPresentationV2Handler.mjs";
import { CredoError, utils } from "@credo-ts/core";

//#region src/modules/proofs/protocol/v2/DidCommProofV2Protocol.ts
var DidCommProofV2Protocol = class extends DidCommBaseProofProtocol {
	constructor({ proofFormats }) {
		super();
		this.proofFormatCoordinator = new DidCommProofFormatCoordinator();
		this.version = "v2";
		this.proofFormats = proofFormats;
	}
	register(messageHandlerRegistry, featureRegistry) {
		messageHandlerRegistry.registerMessageHandlers([
			new DidCommProposePresentationV2Handler(this),
			new DidCommRequestPresentationV2Handler(this),
			new DidCommPresentationV2Handler(this),
			new DidCommPresentationV2AckHandler(this),
			new DidCommPresentationV2ProblemReportHandler(this)
		]);
		featureRegistry.register(new DidCommProtocol({
			id: "https://didcomm.org/present-proof/2.0",
			roles: ["prover", "verifier"]
		}));
	}
	async createProposal(agentContext, { connectionRecord, proofFormats, comment, autoAcceptProof, goalCode, goal, parentThreadId }) {
		const proofRepository = agentContext.dependencyManager.resolve(DidCommProofExchangeRepository);
		const formatServices = this.getFormatServices(proofFormats);
		if (formatServices.length === 0) throw new CredoError("Unable to create proposal. No supported formats");
		const proofRecord = new DidCommProofExchangeRecord({
			connectionId: connectionRecord?.id,
			threadId: utils.uuid(),
			parentThreadId,
			state: DidCommProofState.ProposalSent,
			role: DidCommProofRole.Prover,
			protocolVersion: "v2",
			autoAcceptProof
		});
		const proposalMessage = await this.proofFormatCoordinator.createProposal(agentContext, {
			proofFormats,
			proofRecord,
			formatServices,
			comment,
			goalCode,
			goal
		});
		agentContext.config.logger.debug("Save record and emit state change event");
		await proofRepository.save(agentContext, proofRecord);
		this.emitStateChangedEvent(agentContext, proofRecord, null);
		return {
			proofRecord,
			message: proposalMessage
		};
	}
	/**
	* Method called by {@link V2ProposeCredentialHandler} on reception of a propose presentation message
	* We do the necessary processing here to accept the proposal and do the state change, emit event etc.
	* @param messageContext the inbound propose presentation message
	* @returns proof record appropriate for this incoming message (once accepted)
	*/
	async processProposal(messageContext) {
		const { message: proposalMessage, connection, agentContext } = messageContext;
		agentContext.config.logger.debug(`Processing presentation proposal with id ${proposalMessage.id}`);
		const proofRepository = agentContext.dependencyManager.resolve(DidCommProofExchangeRepository);
		const didCommMessageRepository = agentContext.dependencyManager.resolve(DidCommMessageRepository);
		const connectionService = agentContext.dependencyManager.resolve(DidCommConnectionService);
		let proofRecord = await this.findByProperties(messageContext.agentContext, {
			threadId: proposalMessage.threadId,
			role: DidCommProofRole.Verifier,
			connectionId: connection?.id
		});
		const formatServices = this.getFormatServicesFromMessage(proposalMessage.formats);
		if (formatServices.length === 0) throw new CredoError("Unable to process proposal. No supported formats");
		if (proofRecord) {
			const lastReceivedMessage = await didCommMessageRepository.findAgentMessage(messageContext.agentContext, {
				associatedRecordId: proofRecord.id,
				messageClass: DidCommProposePresentationV2Message,
				role: DidCommMessageRole.Receiver
			});
			const lastSentMessage = await didCommMessageRepository.findAgentMessage(messageContext.agentContext, {
				associatedRecordId: proofRecord.id,
				messageClass: DidCommRequestPresentationV2Message,
				role: DidCommMessageRole.Sender
			});
			proofRecord.assertProtocolVersion("v2");
			proofRecord.assertState(DidCommProofState.RequestSent);
			await connectionService.assertConnectionOrOutOfBandExchange(messageContext, {
				lastReceivedMessage,
				lastSentMessage,
				expectedConnectionId: proofRecord.connectionId
			});
			await this.proofFormatCoordinator.processProposal(messageContext.agentContext, {
				proofRecord,
				formatServices,
				message: proposalMessage
			});
			await this.updateState(messageContext.agentContext, proofRecord, DidCommProofState.ProposalReceived);
			return proofRecord;
		}
		await connectionService.assertConnectionOrOutOfBandExchange(messageContext);
		proofRecord = new DidCommProofExchangeRecord({
			connectionId: connection?.id,
			threadId: proposalMessage.threadId,
			state: DidCommProofState.ProposalReceived,
			role: DidCommProofRole.Verifier,
			protocolVersion: "v2",
			parentThreadId: proposalMessage.thread?.parentThreadId
		});
		await this.proofFormatCoordinator.processProposal(messageContext.agentContext, {
			proofRecord,
			formatServices,
			message: proposalMessage
		});
		await proofRepository.save(messageContext.agentContext, proofRecord);
		this.emitStateChangedEvent(messageContext.agentContext, proofRecord, null);
		return proofRecord;
	}
	async acceptProposal(agentContext, { proofRecord, proofFormats, autoAcceptProof, comment, goalCode, goal, willConfirm }) {
		proofRecord.assertProtocolVersion("v2");
		proofRecord.assertState(DidCommProofState.ProposalReceived);
		const didCommMessageRepository = agentContext.dependencyManager.resolve(DidCommMessageRepository);
		let formatServices = this.getFormatServices(proofFormats ?? {});
		if (formatServices.length === 0) {
			const proposalMessage = await didCommMessageRepository.getAgentMessage(agentContext, {
				associatedRecordId: proofRecord.id,
				messageClass: DidCommProposePresentationV2Message,
				role: DidCommMessageRole.Receiver
			});
			formatServices = this.getFormatServicesFromMessage(proposalMessage.formats);
		}
		if (formatServices.length === 0) throw new CredoError("Unable to accept proposal. No supported formats provided as input or in proposal message");
		const requestMessage = await this.proofFormatCoordinator.acceptProposal(agentContext, {
			proofRecord,
			formatServices,
			comment,
			proofFormats,
			goalCode,
			goal,
			willConfirm,
			presentMultiple: false
		});
		proofRecord.autoAcceptProof = autoAcceptProof ?? proofRecord.autoAcceptProof;
		await this.updateState(agentContext, proofRecord, DidCommProofState.RequestSent);
		return {
			proofRecord,
			message: requestMessage
		};
	}
	/**
	* Negotiate a proof proposal as verifier (by sending a proof request message) to the connection
	* associated with the proof record.
	*
	* @param options configuration for the request see {@link NegotiateProofProposalOptions}
	* @returns Proof exchange record associated with the proof request
	*
	*/
	async negotiateProposal(agentContext, { proofRecord, proofFormats, autoAcceptProof, comment, goalCode, goal, willConfirm }) {
		proofRecord.assertProtocolVersion("v2");
		proofRecord.assertState(DidCommProofState.ProposalReceived);
		if (!proofRecord.connectionId) throw new CredoError(`No connectionId found for proof record '${proofRecord.id}'. Connection-less verification does not support negotiation.`);
		const formatServices = this.getFormatServices(proofFormats);
		if (formatServices.length === 0) throw new CredoError("Unable to create request. No supported formats");
		const requestMessage = await this.proofFormatCoordinator.createRequest(agentContext, {
			formatServices,
			proofFormats,
			proofRecord,
			comment,
			goalCode,
			goal,
			willConfirm,
			presentMultiple: false
		});
		proofRecord.autoAcceptProof = autoAcceptProof ?? proofRecord.autoAcceptProof;
		await this.updateState(agentContext, proofRecord, DidCommProofState.RequestSent);
		return {
			proofRecord,
			message: requestMessage
		};
	}
	/**
	* Create a {@link DidCommRequestPresentationV2Message} as beginning of protocol process.
	* @returns Object containing request message and associated credential record
	*
	*/
	async createRequest(agentContext, { proofFormats, autoAcceptProof, comment, connectionRecord, parentThreadId, goalCode, goal, willConfirm }) {
		const proofRepository = agentContext.dependencyManager.resolve(DidCommProofExchangeRepository);
		const formatServices = this.getFormatServices(proofFormats);
		if (formatServices.length === 0) throw new CredoError("Unable to create request. No supported formats");
		const proofRecord = new DidCommProofExchangeRecord({
			connectionId: connectionRecord?.id,
			threadId: utils.uuid(),
			state: DidCommProofState.RequestSent,
			role: DidCommProofRole.Verifier,
			autoAcceptProof,
			protocolVersion: "v2",
			parentThreadId
		});
		const requestMessage = await this.proofFormatCoordinator.createRequest(agentContext, {
			formatServices,
			proofFormats,
			proofRecord,
			comment,
			goalCode,
			goal,
			willConfirm
		});
		agentContext.config.logger.debug(`Saving record and emitting state changed for proof exchange record ${proofRecord.id}`);
		await proofRepository.save(agentContext, proofRecord);
		this.emitStateChangedEvent(agentContext, proofRecord, null);
		return {
			proofRecord,
			message: requestMessage
		};
	}
	/**
	* Process a received {@link DidCommRequestPresentationV2Message}. This will not accept the proof request
	* or send a proof. It will only update the existing proof record with
	* the information from the proof request message. Use {@link createCredential}
	* after calling this method to create a proof.
	*z
	* @param messageContext The message context containing a v2 proof request message
	* @returns proof record associated with the proof request message
	*
	*/
	async processRequest(messageContext) {
		const { message: requestMessage, connection, agentContext } = messageContext;
		const proofRepository = agentContext.dependencyManager.resolve(DidCommProofExchangeRepository);
		const didCommMessageRepository = agentContext.dependencyManager.resolve(DidCommMessageRepository);
		const connectionService = agentContext.dependencyManager.resolve(DidCommConnectionService);
		agentContext.config.logger.debug(`Processing proof request with id ${requestMessage.id}`);
		let proofRecord = await this.findByProperties(messageContext.agentContext, {
			threadId: requestMessage.threadId,
			role: DidCommProofRole.Prover
		});
		const formatServices = this.getFormatServicesFromMessage(requestMessage.formats);
		if (formatServices.length === 0) throw new CredoError("Unable to process request. No supported formats");
		if (proofRecord) {
			const lastSentMessage = await didCommMessageRepository.findAgentMessage(messageContext.agentContext, {
				associatedRecordId: proofRecord.id,
				messageClass: DidCommProposePresentationV2Message,
				role: DidCommMessageRole.Sender
			});
			const lastReceivedMessage = await didCommMessageRepository.findAgentMessage(messageContext.agentContext, {
				associatedRecordId: proofRecord.id,
				messageClass: DidCommRequestPresentationV2Message,
				role: DidCommMessageRole.Receiver
			});
			proofRecord.assertProtocolVersion("v2");
			proofRecord.assertState(DidCommProofState.ProposalSent);
			await connectionService.assertConnectionOrOutOfBandExchange(messageContext, {
				lastReceivedMessage,
				lastSentMessage,
				expectedConnectionId: proofRecord.connectionId
			});
			if (!proofRecord.connectionId) proofRecord.connectionId = connection?.id;
			await this.proofFormatCoordinator.processRequest(messageContext.agentContext, {
				proofRecord,
				formatServices,
				message: requestMessage
			});
			await this.updateState(messageContext.agentContext, proofRecord, DidCommProofState.RequestReceived);
			return proofRecord;
		}
		await connectionService.assertConnectionOrOutOfBandExchange(messageContext);
		agentContext.config.logger.debug("No proof record found for request, creating a new one");
		proofRecord = new DidCommProofExchangeRecord({
			connectionId: connection?.id,
			threadId: requestMessage.threadId,
			state: DidCommProofState.RequestReceived,
			role: DidCommProofRole.Prover,
			protocolVersion: "v2",
			parentThreadId: requestMessage.thread?.parentThreadId
		});
		await this.proofFormatCoordinator.processRequest(messageContext.agentContext, {
			proofRecord,
			formatServices,
			message: requestMessage
		});
		agentContext.config.logger.debug("Saving proof record and emit request-received event");
		await proofRepository.save(messageContext.agentContext, proofRecord);
		this.emitStateChangedEvent(messageContext.agentContext, proofRecord, null);
		return proofRecord;
	}
	async acceptRequest(agentContext, { proofRecord, autoAcceptProof, comment, proofFormats, goalCode, goal }) {
		const didCommMessageRepository = agentContext.dependencyManager.resolve(DidCommMessageRepository);
		proofRecord.assertProtocolVersion("v2");
		proofRecord.assertState(DidCommProofState.RequestReceived);
		let formatServices = this.getFormatServices(proofFormats ?? {});
		if (formatServices.length === 0) {
			const requestMessage = await didCommMessageRepository.getAgentMessage(agentContext, {
				associatedRecordId: proofRecord.id,
				messageClass: DidCommRequestPresentationV2Message,
				role: DidCommMessageRole.Receiver
			});
			formatServices = this.getFormatServicesFromMessage(requestMessage.formats);
		}
		if (formatServices.length === 0) throw new CredoError("Unable to accept request. No supported formats provided as input or in request message");
		const message = await this.proofFormatCoordinator.acceptRequest(agentContext, {
			proofRecord,
			formatServices,
			comment,
			proofFormats,
			goalCode,
			goal,
			lastPresentation: true
		});
		proofRecord.autoAcceptProof = autoAcceptProof ?? proofRecord.autoAcceptProof;
		await this.updateState(agentContext, proofRecord, DidCommProofState.PresentationSent);
		return {
			proofRecord,
			message
		};
	}
	/**
	* Create a {@link DidCommProposePresentationV2Message} as response to a received credential request.
	* To create a proposal not bound to an existing proof exchange, use {@link createProposal}.
	*
	* @param options configuration to use for the proposal
	* @returns Object containing proposal message and associated proof record
	*
	*/
	async negotiateRequest(agentContext, { proofRecord, proofFormats, autoAcceptProof, comment, goalCode, goal }) {
		proofRecord.assertProtocolVersion("v2");
		proofRecord.assertState(DidCommProofState.RequestReceived);
		if (!proofRecord.connectionId) throw new CredoError(`No connectionId found for proof record '${proofRecord.id}'. Connection-less verification does not support negotiation.`);
		const formatServices = this.getFormatServices(proofFormats);
		if (formatServices.length === 0) throw new CredoError("Unable to create proposal. No supported formats");
		const proposalMessage = await this.proofFormatCoordinator.createProposal(agentContext, {
			formatServices,
			proofFormats,
			proofRecord,
			comment,
			goalCode,
			goal
		});
		proofRecord.autoAcceptProof = autoAcceptProof ?? proofRecord.autoAcceptProof;
		await this.updateState(agentContext, proofRecord, DidCommProofState.ProposalSent);
		return {
			proofRecord,
			message: proposalMessage
		};
	}
	async getCredentialsForRequest(agentContext, { proofRecord, proofFormats }) {
		const didCommMessageRepository = agentContext.dependencyManager.resolve(DidCommMessageRepository);
		proofRecord.assertProtocolVersion("v2");
		proofRecord.assertState(DidCommProofState.RequestReceived);
		let formatServices = this.getFormatServices(proofFormats ?? {});
		if (formatServices.length === 0) {
			const requestMessage = await didCommMessageRepository.getAgentMessage(agentContext, {
				associatedRecordId: proofRecord.id,
				messageClass: DidCommRequestPresentationV2Message,
				role: DidCommMessageRole.Receiver
			});
			formatServices = this.getFormatServicesFromMessage(requestMessage.formats);
		}
		if (formatServices.length === 0) throw new CredoError("Unable to get credentials for request. No supported formats provided as input or in request message");
		return { proofFormats: await this.proofFormatCoordinator.getCredentialsForRequest(agentContext, {
			formatServices,
			proofFormats,
			proofRecord
		}) };
	}
	async selectCredentialsForRequest(agentContext, { proofRecord, proofFormats }) {
		const didCommMessageRepository = agentContext.dependencyManager.resolve(DidCommMessageRepository);
		proofRecord.assertProtocolVersion("v2");
		proofRecord.assertState(DidCommProofState.RequestReceived);
		let formatServices = this.getFormatServices(proofFormats ?? {});
		if (formatServices.length === 0) {
			const requestMessage = await didCommMessageRepository.getAgentMessage(agentContext, {
				associatedRecordId: proofRecord.id,
				messageClass: DidCommRequestPresentationV2Message,
				role: DidCommMessageRole.Receiver
			});
			formatServices = this.getFormatServicesFromMessage(requestMessage.formats);
		}
		if (formatServices.length === 0) throw new CredoError("Unable to get credentials for request. No supported formats provided as input or in request message");
		return { proofFormats: await this.proofFormatCoordinator.selectCredentialsForRequest(agentContext, {
			formatServices,
			proofFormats,
			proofRecord
		}) };
	}
	async processPresentation(messageContext) {
		const { message: presentationMessage, connection, agentContext } = messageContext;
		const didCommMessageRepository = agentContext.dependencyManager.resolve(DidCommMessageRepository);
		const connectionService = agentContext.dependencyManager.resolve(DidCommConnectionService);
		agentContext.config.logger.debug(`Processing presentation with id ${presentationMessage.id}`);
		const proofRecord = await this.getByProperties(messageContext.agentContext, {
			threadId: presentationMessage.threadId,
			role: DidCommProofRole.Verifier
		});
		const lastSentMessage = await didCommMessageRepository.getAgentMessage(messageContext.agentContext, {
			associatedRecordId: proofRecord.id,
			messageClass: DidCommRequestPresentationV2Message,
			role: DidCommMessageRole.Sender
		});
		const lastReceivedMessage = await didCommMessageRepository.findAgentMessage(messageContext.agentContext, {
			associatedRecordId: proofRecord.id,
			messageClass: DidCommProposePresentationV2Message,
			role: DidCommMessageRole.Receiver
		});
		proofRecord.assertProtocolVersion("v2");
		proofRecord.assertState(DidCommProofState.RequestSent);
		await connectionService.assertConnectionOrOutOfBandExchange(messageContext, {
			lastReceivedMessage,
			lastSentMessage,
			expectedConnectionId: proofRecord.connectionId
		});
		if (!proofRecord.connectionId) {
			await connectionService.matchIncomingMessageToRequestMessageInOutOfBandExchange(messageContext, { expectedConnectionId: proofRecord.connectionId });
			proofRecord.connectionId = connection?.id;
		}
		const formatServices = this.getFormatServicesFromMessage(presentationMessage.formats);
		if (formatServices.length === 0) {
			proofRecord.errorMessage = "Unable to process presentation. No supported formats";
			await this.updateState(messageContext.agentContext, proofRecord, DidCommProofState.Abandoned);
			throw new V2PresentationProblemReportError(proofRecord.errorMessage, { problemCode: DidCommPresentationProblemReportReason.Abandoned });
		}
		const result = await this.proofFormatCoordinator.processPresentation(messageContext.agentContext, {
			proofRecord,
			formatServices,
			requestMessage: lastSentMessage,
			message: presentationMessage
		});
		proofRecord.isVerified = result.isValid;
		if (result.isValid) await this.updateState(messageContext.agentContext, proofRecord, DidCommProofState.PresentationReceived);
		else {
			proofRecord.errorMessage = result.message;
			proofRecord.isVerified = false;
			await this.updateState(messageContext.agentContext, proofRecord, DidCommProofState.Abandoned);
			throw new V2PresentationProblemReportError(proofRecord.errorMessage, { problemCode: DidCommPresentationProblemReportReason.Abandoned });
		}
		return proofRecord;
	}
	async acceptPresentation(agentContext, { proofRecord }) {
		proofRecord.assertProtocolVersion("v2");
		proofRecord.assertState(DidCommProofState.PresentationReceived);
		const presentation = await agentContext.dependencyManager.resolve(DidCommMessageRepository).getAgentMessage(agentContext, {
			associatedRecordId: proofRecord.id,
			messageClass: DidCommPresentationV2Message,
			role: DidCommMessageRole.Receiver
		});
		if (!presentation.lastPresentation) throw new CredoError(`Trying to send an ack message while presentation with id ${presentation.id} indicates this is not the last presentation (presentation.last_presentation is set to false)`);
		const message = new DidCommPresentationV2AckMessage({
			threadId: proofRecord.threadId,
			status: AckStatus.OK
		});
		message.setThread({
			threadId: proofRecord.threadId,
			parentThreadId: proofRecord.parentThreadId
		});
		await this.updateState(agentContext, proofRecord, DidCommProofState.Done);
		return {
			message,
			proofRecord
		};
	}
	async processAck(messageContext) {
		const { message: ackMessage, connection, agentContext } = messageContext;
		agentContext.config.logger.debug(`Processing proof ack with id ${ackMessage.id}`);
		const didCommMessageRepository = agentContext.dependencyManager.resolve(DidCommMessageRepository);
		const connectionService = agentContext.dependencyManager.resolve(DidCommConnectionService);
		const proofRecord = await this.getByProperties(messageContext.agentContext, {
			threadId: ackMessage.threadId,
			role: DidCommProofRole.Prover,
			connectionId: connection?.id
		});
		proofRecord.connectionId = connection?.id;
		const lastReceivedMessage = await didCommMessageRepository.getAgentMessage(messageContext.agentContext, {
			associatedRecordId: proofRecord.id,
			messageClass: DidCommRequestPresentationV2Message,
			role: DidCommMessageRole.Receiver
		});
		const lastSentMessage = await didCommMessageRepository.getAgentMessage(messageContext.agentContext, {
			associatedRecordId: proofRecord.id,
			messageClass: DidCommPresentationV2Message,
			role: DidCommMessageRole.Sender
		});
		proofRecord.assertProtocolVersion("v2");
		proofRecord.assertState(DidCommProofState.PresentationSent);
		await connectionService.assertConnectionOrOutOfBandExchange(messageContext, {
			lastReceivedMessage,
			lastSentMessage,
			expectedConnectionId: proofRecord.connectionId
		});
		await this.updateState(messageContext.agentContext, proofRecord, DidCommProofState.Done);
		return proofRecord;
	}
	async createProblemReport(_agentContext, { description, proofRecord }) {
		const message = new DidCommPresentationV2ProblemReportMessage({ description: {
			en: description,
			code: DidCommPresentationProblemReportReason.Abandoned
		} });
		message.setThread({
			threadId: proofRecord.threadId,
			parentThreadId: proofRecord.parentThreadId
		});
		return {
			proofRecord,
			message
		};
	}
	async shouldAutoRespondToProposal(agentContext, options) {
		const { proofRecord, proposalMessage } = options;
		const proofsModuleConfig = agentContext.dependencyManager.resolve(DidCommProofsModuleConfig);
		const autoAccept = composeAutoAccept(proofRecord.autoAcceptProof, proofsModuleConfig.autoAcceptProofs);
		if (autoAccept === DidCommAutoAcceptProof.Always) return true;
		if (autoAccept === DidCommAutoAcceptProof.Never) return false;
		const requestMessage = await this.findRequestMessage(agentContext, proofRecord.id);
		if (!requestMessage) return false;
		const formatServices = this.getFormatServicesFromMessage(requestMessage.formats);
		for (const formatService of formatServices) {
			const requestAttachment = this.proofFormatCoordinator.getAttachmentForService(formatService, requestMessage.formats, requestMessage.requestAttachments);
			const proposalAttachment = this.proofFormatCoordinator.getAttachmentForService(formatService, proposalMessage.formats, proposalMessage.proposalAttachments);
			if (!await formatService.shouldAutoRespondToProposal(agentContext, {
				proofRecord,
				requestAttachment,
				proposalAttachment
			})) return false;
		}
		return true;
	}
	async shouldAutoRespondToRequest(agentContext, options) {
		const { proofRecord, requestMessage } = options;
		const proofsModuleConfig = agentContext.dependencyManager.resolve(DidCommProofsModuleConfig);
		const autoAccept = composeAutoAccept(proofRecord.autoAcceptProof, proofsModuleConfig.autoAcceptProofs);
		if (autoAccept === DidCommAutoAcceptProof.Always) return true;
		if (autoAccept === DidCommAutoAcceptProof.Never) return false;
		const proposalMessage = await this.findProposalMessage(agentContext, proofRecord.id);
		if (!proposalMessage) return false;
		const formatServices = this.getFormatServicesFromMessage(proposalMessage.formats);
		for (const formatService of formatServices) {
			const proposalAttachment = this.proofFormatCoordinator.getAttachmentForService(formatService, proposalMessage.formats, proposalMessage.proposalAttachments);
			const requestAttachment = this.proofFormatCoordinator.getAttachmentForService(formatService, requestMessage.formats, requestMessage.requestAttachments);
			if (!await formatService.shouldAutoRespondToRequest(agentContext, {
				proofRecord,
				requestAttachment,
				proposalAttachment
			})) return false;
		}
		return true;
	}
	async shouldAutoRespondToPresentation(agentContext, options) {
		const { proofRecord, presentationMessage } = options;
		const proofsModuleConfig = agentContext.dependencyManager.resolve(DidCommProofsModuleConfig);
		if (!presentationMessage.lastPresentation) return false;
		const autoAccept = composeAutoAccept(proofRecord.autoAcceptProof, proofsModuleConfig.autoAcceptProofs);
		if (autoAccept === DidCommAutoAcceptProof.Always) return true;
		if (autoAccept === DidCommAutoAcceptProof.Never) return false;
		const proposalMessage = await this.findProposalMessage(agentContext, proofRecord.id);
		const requestMessage = await this.findRequestMessage(agentContext, proofRecord.id);
		if (!requestMessage) return false;
		if (!requestMessage.willConfirm) return false;
		const formatServices = this.getFormatServicesFromMessage(requestMessage.formats);
		for (const formatService of formatServices) {
			const proposalAttachment = proposalMessage ? this.proofFormatCoordinator.getAttachmentForService(formatService, proposalMessage.formats, proposalMessage.proposalAttachments) : void 0;
			const requestAttachment = this.proofFormatCoordinator.getAttachmentForService(formatService, requestMessage.formats, requestMessage.requestAttachments);
			const presentationAttachment = this.proofFormatCoordinator.getAttachmentForService(formatService, presentationMessage.formats, presentationMessage.presentationAttachments);
			if (!await formatService.shouldAutoRespondToPresentation(agentContext, {
				proofRecord,
				presentationAttachment,
				requestAttachment,
				proposalAttachment
			})) return false;
		}
		return true;
	}
	async findRequestMessage(agentContext, proofExchangeRecordId) {
		return await agentContext.dependencyManager.resolve(DidCommMessageRepository).findAgentMessage(agentContext, {
			associatedRecordId: proofExchangeRecordId,
			messageClass: DidCommRequestPresentationV2Message
		});
	}
	async findPresentationMessage(agentContext, proofExchangeRecordId) {
		return await agentContext.dependencyManager.resolve(DidCommMessageRepository).findAgentMessage(agentContext, {
			associatedRecordId: proofExchangeRecordId,
			messageClass: DidCommPresentationV2Message
		});
	}
	async findProposalMessage(agentContext, proofExchangeRecordId) {
		return await agentContext.dependencyManager.resolve(DidCommMessageRepository).findAgentMessage(agentContext, {
			associatedRecordId: proofExchangeRecordId,
			messageClass: DidCommProposePresentationV2Message
		});
	}
	async getFormatData(agentContext, proofExchangeRecordId) {
		const [proposalMessage, requestMessage, presentationMessage] = await Promise.all([
			this.findProposalMessage(agentContext, proofExchangeRecordId),
			this.findRequestMessage(agentContext, proofExchangeRecordId),
			this.findPresentationMessage(agentContext, proofExchangeRecordId)
		]);
		const messages = {
			proposal: [proposalMessage?.formats, proposalMessage?.proposalAttachments],
			request: [requestMessage?.formats, requestMessage?.requestAttachments],
			presentation: [presentationMessage?.formats, presentationMessage?.presentationAttachments]
		};
		const formatData = {};
		for (const [messageKey, [formats, attachments]] of Object.entries(messages)) {
			if (!formats || !attachments) continue;
			const formatServices = this.getFormatServicesFromMessage(formats);
			const messageFormatData = {};
			for (const formatService of formatServices) {
				const attachment = this.proofFormatCoordinator.getAttachmentForService(formatService, formats, attachments);
				messageFormatData[formatService.formatKey] = attachment.getDataAsJson();
			}
			formatData[messageKey] = messageFormatData;
		}
		return formatData;
	}
	/**
	* Get all the format service objects for a given proof format from an incoming message
	* @param messageFormats the format objects containing the format name (eg indy)
	* @return the proof format service objects in an array - derived from format object keys
	*/
	getFormatServicesFromMessage(messageFormats) {
		const formatServices = /* @__PURE__ */ new Set();
		for (const msg of messageFormats) {
			const service = this.getFormatServiceForFormat(msg.format);
			if (service) formatServices.add(service);
		}
		return Array.from(formatServices);
	}
	/**
	* Get all the format service objects for a given proof format
	* @param proofFormats the format object containing various optional parameters
	* @return the proof format service objects in an array - derived from format object keys
	*/
	getFormatServices(proofFormats) {
		const formats = /* @__PURE__ */ new Set();
		for (const formatKey of Object.keys(proofFormats)) {
			const formatService = this.getFormatServiceForFormatKey(formatKey);
			if (formatService) formats.add(formatService);
		}
		return Array.from(formats);
	}
	getFormatServiceForFormatKey(formatKey) {
		return this.proofFormats.find((proofFormats) => proofFormats.formatKey === formatKey) ?? null;
	}
	getFormatServiceForFormat(format) {
		return this.proofFormats.find((proofFormats) => proofFormats.supportsFormat(format)) ?? null;
	}
};

//#endregion
export { DidCommProofV2Protocol };
//# sourceMappingURL=DidCommProofV2Protocol.mjs.map