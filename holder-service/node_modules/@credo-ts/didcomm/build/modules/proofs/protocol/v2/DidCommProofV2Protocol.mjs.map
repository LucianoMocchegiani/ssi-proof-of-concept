{"version":3,"file":"DidCommProofV2Protocol.mjs","names":[],"sources":["../../../../../src/modules/proofs/protocol/v2/DidCommProofV2Protocol.ts"],"sourcesContent":["import type { AgentContext } from '@credo-ts/core'\nimport { CredoError, utils } from '@credo-ts/core'\nimport type { DidCommFeatureRegistry } from '../../../../DidCommFeatureRegistry'\nimport type { DidCommMessage } from '../../../../DidCommMessage'\nimport type { DidCommMessageHandlerRegistry } from '../../../../DidCommMessageHandlerRegistry'\nimport type { DidCommProblemReportMessage } from '../../../../messages'\nimport { AckStatus } from '../../../../messages'\nimport type { DidCommInboundMessageContext } from '../../../../models'\nimport { DidCommProtocol } from '../../../../models'\nimport { DidCommMessageRepository, DidCommMessageRole } from '../../../../repository'\nimport { DidCommConnectionService } from '../../../connections'\nimport { DidCommProofsModuleConfig } from '../../DidCommProofsModuleConfig'\nimport { DidCommPresentationProblemReportReason } from '../../errors/DidCommPresentationProblemReportReason'\nimport type {\n  DidCommProofFormat,\n  DidCommProofFormatCredentialForRequestPayload,\n  DidCommProofFormatPayload,\n  ExtractProofFormats,\n} from '../../formats'\nimport type { DidCommProofFormatService } from '../../formats/DidCommProofFormatService'\nimport { DidCommAutoAcceptProof, DidCommProofRole, DidCommProofState } from '../../models'\nimport type { DidCommProofFormatSpec } from '../../models/DidCommProofFormatSpec'\nimport { DidCommProofExchangeRecord, DidCommProofExchangeRepository } from '../../repository'\nimport { composeAutoAccept } from '../../utils'\nimport { DidCommBaseProofProtocol } from '../DidCommBaseProofProtocol'\nimport type { DidCommProofProtocol } from '../DidCommProofProtocol'\nimport type {\n  AcceptPresentationOptions,\n  AcceptProofProposalOptions,\n  AcceptProofRequestOptions,\n  CreateProofProblemReportOptions,\n  CreateProofProposalOptions,\n  CreateProofRequestOptions,\n  GetCredentialsForRequestOptions,\n  GetCredentialsForRequestReturn,\n  GetProofFormatDataReturn,\n  NegotiateProofProposalOptions,\n  NegotiateProofRequestOptions,\n  ProofFormatDataMessagePayload,\n  ProofProtocolMsgReturnType,\n  SelectCredentialsForRequestOptions,\n  SelectCredentialsForRequestReturn,\n} from '../DidCommProofProtocolOptions'\n\nimport { DidCommProofFormatCoordinator } from './DidCommProofFormatCoordinator'\nimport { V2PresentationProblemReportError } from './errors'\nimport { DidCommPresentationV2AckHandler } from './handlers/DidCommPresentationV2AckHandler'\nimport { DidCommPresentationV2Handler } from './handlers/DidCommPresentationV2Handler'\nimport { DidCommPresentationV2ProblemReportHandler } from './handlers/DidCommPresentationV2ProblemReportHandler'\nimport { DidCommProposePresentationV2Handler } from './handlers/DidCommProposePresentationV2Handler'\nimport { DidCommRequestPresentationV2Handler } from './handlers/DidCommRequestPresentationV2Handler'\nimport { DidCommPresentationV2AckMessage, DidCommRequestPresentationV2Message } from './messages'\nimport { DidCommPresentationV2Message } from './messages/DidCommPresentationV2Message'\nimport { DidCommPresentationV2ProblemReportMessage } from './messages/DidCommPresentationV2ProblemReportMessage'\nimport { DidCommProposePresentationV2Message } from './messages/DidCommProposePresentationV2Message'\n\nexport interface DidCommProofV2ProtocolConfig<ProofFormatServices extends DidCommProofFormatService[]> {\n  proofFormats: ProofFormatServices\n}\n\nexport class DidCommProofV2Protocol<PFs extends DidCommProofFormatService[] = DidCommProofFormatService[]>\n  extends DidCommBaseProofProtocol\n  implements DidCommProofProtocol<PFs>\n{\n  private proofFormatCoordinator = new DidCommProofFormatCoordinator<PFs>()\n  private proofFormats: PFs\n\n  public constructor({ proofFormats }: DidCommProofV2ProtocolConfig<PFs>) {\n    super()\n\n    this.proofFormats = proofFormats\n  }\n\n  /**\n   * The version of the present proof protocol this service supports\n   */\n  public readonly version = 'v2' as const\n\n  public register(messageHandlerRegistry: DidCommMessageHandlerRegistry, featureRegistry: DidCommFeatureRegistry) {\n    // Register message handlers for the Present Proof V2 Protocol\n    messageHandlerRegistry.registerMessageHandlers([\n      new DidCommProposePresentationV2Handler(this),\n      new DidCommRequestPresentationV2Handler(this),\n      new DidCommPresentationV2Handler(this),\n      new DidCommPresentationV2AckHandler(this),\n      new DidCommPresentationV2ProblemReportHandler(this),\n    ])\n\n    // Register Present Proof V2 in feature registry, with supported roles\n    featureRegistry.register(\n      new DidCommProtocol({\n        id: 'https://didcomm.org/present-proof/2.0',\n        roles: ['prover', 'verifier'],\n      })\n    )\n  }\n\n  public async createProposal(\n    agentContext: AgentContext,\n    {\n      connectionRecord,\n      proofFormats,\n      comment,\n      autoAcceptProof,\n      goalCode,\n      goal,\n      parentThreadId,\n    }: CreateProofProposalOptions<PFs>\n  ): Promise<{ proofRecord: DidCommProofExchangeRecord; message: DidCommMessage }> {\n    const proofRepository = agentContext.dependencyManager.resolve(DidCommProofExchangeRepository)\n\n    const formatServices = this.getFormatServices(proofFormats)\n    if (formatServices.length === 0) {\n      throw new CredoError('Unable to create proposal. No supported formats')\n    }\n\n    const proofRecord = new DidCommProofExchangeRecord({\n      connectionId: connectionRecord?.id,\n      threadId: utils.uuid(),\n      parentThreadId,\n      state: DidCommProofState.ProposalSent,\n      role: DidCommProofRole.Prover,\n      protocolVersion: 'v2',\n      autoAcceptProof,\n    })\n\n    const proposalMessage = await this.proofFormatCoordinator.createProposal(agentContext, {\n      proofFormats,\n      proofRecord,\n      formatServices,\n      comment,\n      goalCode,\n      goal,\n    })\n\n    agentContext.config.logger.debug('Save record and emit state change event')\n    await proofRepository.save(agentContext, proofRecord)\n    this.emitStateChangedEvent(agentContext, proofRecord, null)\n\n    return {\n      proofRecord,\n      message: proposalMessage,\n    }\n  }\n\n  /**\n   * Method called by {@link V2ProposeCredentialHandler} on reception of a propose presentation message\n   * We do the necessary processing here to accept the proposal and do the state change, emit event etc.\n   * @param messageContext the inbound propose presentation message\n   * @returns proof record appropriate for this incoming message (once accepted)\n   */\n  public async processProposal(\n    messageContext: DidCommInboundMessageContext<DidCommProposePresentationV2Message>\n  ): Promise<DidCommProofExchangeRecord> {\n    const { message: proposalMessage, connection, agentContext } = messageContext\n\n    agentContext.config.logger.debug(`Processing presentation proposal with id ${proposalMessage.id}`)\n\n    const proofRepository = agentContext.dependencyManager.resolve(DidCommProofExchangeRepository)\n    const didCommMessageRepository = agentContext.dependencyManager.resolve(DidCommMessageRepository)\n    const connectionService = agentContext.dependencyManager.resolve(DidCommConnectionService)\n\n    let proofRecord = await this.findByProperties(messageContext.agentContext, {\n      threadId: proposalMessage.threadId,\n      role: DidCommProofRole.Verifier,\n      connectionId: connection?.id,\n    })\n\n    const formatServices = this.getFormatServicesFromMessage(proposalMessage.formats)\n    if (formatServices.length === 0) {\n      throw new CredoError('Unable to process proposal. No supported formats')\n    }\n\n    // credential record already exists\n    if (proofRecord) {\n      const lastReceivedMessage = await didCommMessageRepository.findAgentMessage(messageContext.agentContext, {\n        associatedRecordId: proofRecord.id,\n        messageClass: DidCommProposePresentationV2Message,\n        role: DidCommMessageRole.Receiver,\n      })\n      const lastSentMessage = await didCommMessageRepository.findAgentMessage(messageContext.agentContext, {\n        associatedRecordId: proofRecord.id,\n        messageClass: DidCommRequestPresentationV2Message,\n        role: DidCommMessageRole.Sender,\n      })\n\n      // Assert\n      proofRecord.assertProtocolVersion('v2')\n      proofRecord.assertState(DidCommProofState.RequestSent)\n      await connectionService.assertConnectionOrOutOfBandExchange(messageContext, {\n        lastReceivedMessage,\n        lastSentMessage,\n        expectedConnectionId: proofRecord.connectionId,\n      })\n\n      await this.proofFormatCoordinator.processProposal(messageContext.agentContext, {\n        proofRecord,\n        formatServices,\n        message: proposalMessage,\n      })\n\n      await this.updateState(messageContext.agentContext, proofRecord, DidCommProofState.ProposalReceived)\n\n      return proofRecord\n    }\n    // Assert\n    await connectionService.assertConnectionOrOutOfBandExchange(messageContext)\n\n    // No proof record exists with thread id\n    proofRecord = new DidCommProofExchangeRecord({\n      connectionId: connection?.id,\n      threadId: proposalMessage.threadId,\n      state: DidCommProofState.ProposalReceived,\n      role: DidCommProofRole.Verifier,\n      protocolVersion: 'v2',\n      parentThreadId: proposalMessage.thread?.parentThreadId,\n    })\n\n    await this.proofFormatCoordinator.processProposal(messageContext.agentContext, {\n      proofRecord,\n      formatServices,\n      message: proposalMessage,\n    })\n\n    // Save record and emit event\n    await proofRepository.save(messageContext.agentContext, proofRecord)\n    this.emitStateChangedEvent(messageContext.agentContext, proofRecord, null)\n\n    return proofRecord\n  }\n\n  public async acceptProposal(\n    agentContext: AgentContext,\n    {\n      proofRecord,\n      proofFormats,\n      autoAcceptProof,\n      comment,\n      goalCode,\n      goal,\n      willConfirm,\n    }: AcceptProofProposalOptions<PFs>\n  ): Promise<ProofProtocolMsgReturnType<DidCommRequestPresentationV2Message>> {\n    // Assert\n    proofRecord.assertProtocolVersion('v2')\n    proofRecord.assertState(DidCommProofState.ProposalReceived)\n\n    const didCommMessageRepository = agentContext.dependencyManager.resolve(DidCommMessageRepository)\n\n    // Use empty proofFormats if not provided to denote all formats should be accepted\n    let formatServices = this.getFormatServices(proofFormats ?? {})\n\n    // if no format services could be extracted from the proofFormats\n    // take all available format services from the proposal message\n    if (formatServices.length === 0) {\n      const proposalMessage = await didCommMessageRepository.getAgentMessage(agentContext, {\n        associatedRecordId: proofRecord.id,\n        messageClass: DidCommProposePresentationV2Message,\n        role: DidCommMessageRole.Receiver,\n      })\n\n      formatServices = this.getFormatServicesFromMessage(proposalMessage.formats)\n    }\n\n    // If the format services list is still empty, throw an error as we don't support any\n    // of the formats\n    if (formatServices.length === 0) {\n      throw new CredoError('Unable to accept proposal. No supported formats provided as input or in proposal message')\n    }\n\n    const requestMessage = await this.proofFormatCoordinator.acceptProposal(agentContext, {\n      proofRecord,\n      formatServices,\n      comment,\n      proofFormats,\n      goalCode,\n      goal,\n      willConfirm,\n      // Not supported at the moment\n      presentMultiple: false,\n    })\n\n    proofRecord.autoAcceptProof = autoAcceptProof ?? proofRecord.autoAcceptProof\n    await this.updateState(agentContext, proofRecord, DidCommProofState.RequestSent)\n\n    return { proofRecord, message: requestMessage }\n  }\n\n  /**\n   * Negotiate a proof proposal as verifier (by sending a proof request message) to the connection\n   * associated with the proof record.\n   *\n   * @param options configuration for the request see {@link NegotiateProofProposalOptions}\n   * @returns Proof exchange record associated with the proof request\n   *\n   */\n  public async negotiateProposal(\n    agentContext: AgentContext,\n    {\n      proofRecord,\n      proofFormats,\n      autoAcceptProof,\n      comment,\n      goalCode,\n      goal,\n      willConfirm,\n    }: NegotiateProofProposalOptions<PFs>\n  ): Promise<ProofProtocolMsgReturnType<DidCommRequestPresentationV2Message>> {\n    // Assert\n    proofRecord.assertProtocolVersion('v2')\n    proofRecord.assertState(DidCommProofState.ProposalReceived)\n\n    if (!proofRecord.connectionId) {\n      throw new CredoError(\n        `No connectionId found for proof record '${proofRecord.id}'. Connection-less verification does not support negotiation.`\n      )\n    }\n\n    const formatServices = this.getFormatServices(proofFormats)\n    if (formatServices.length === 0) {\n      throw new CredoError('Unable to create request. No supported formats')\n    }\n\n    const requestMessage = await this.proofFormatCoordinator.createRequest(agentContext, {\n      formatServices,\n      proofFormats,\n      proofRecord,\n      comment,\n      goalCode,\n      goal,\n      willConfirm,\n      // Not supported at the moment\n      presentMultiple: false,\n    })\n\n    proofRecord.autoAcceptProof = autoAcceptProof ?? proofRecord.autoAcceptProof\n    await this.updateState(agentContext, proofRecord, DidCommProofState.RequestSent)\n\n    return { proofRecord, message: requestMessage }\n  }\n\n  /**\n   * Create a {@link DidCommRequestPresentationV2Message} as beginning of protocol process.\n   * @returns Object containing request message and associated credential record\n   *\n   */\n  public async createRequest(\n    agentContext: AgentContext,\n    {\n      proofFormats,\n      autoAcceptProof,\n      comment,\n      connectionRecord,\n      parentThreadId,\n      goalCode,\n      goal,\n      willConfirm,\n    }: CreateProofRequestOptions<PFs>\n  ): Promise<ProofProtocolMsgReturnType<DidCommRequestPresentationV2Message>> {\n    const proofRepository = agentContext.dependencyManager.resolve(DidCommProofExchangeRepository)\n\n    const formatServices = this.getFormatServices(proofFormats)\n    if (formatServices.length === 0) {\n      throw new CredoError('Unable to create request. No supported formats')\n    }\n\n    const proofRecord = new DidCommProofExchangeRecord({\n      connectionId: connectionRecord?.id,\n      threadId: utils.uuid(),\n      state: DidCommProofState.RequestSent,\n      role: DidCommProofRole.Verifier,\n      autoAcceptProof,\n      protocolVersion: 'v2',\n      parentThreadId,\n    })\n\n    const requestMessage = await this.proofFormatCoordinator.createRequest(agentContext, {\n      formatServices,\n      proofFormats,\n      proofRecord,\n      comment,\n      goalCode,\n      goal,\n      willConfirm,\n    })\n\n    agentContext.config.logger.debug(\n      `Saving record and emitting state changed for proof exchange record ${proofRecord.id}`\n    )\n    await proofRepository.save(agentContext, proofRecord)\n    this.emitStateChangedEvent(agentContext, proofRecord, null)\n\n    return { proofRecord, message: requestMessage }\n  }\n\n  /**\n   * Process a received {@link DidCommRequestPresentationV2Message}. This will not accept the proof request\n   * or send a proof. It will only update the existing proof record with\n   * the information from the proof request message. Use {@link createCredential}\n   * after calling this method to create a proof.\n   *z\n   * @param messageContext The message context containing a v2 proof request message\n   * @returns proof record associated with the proof request message\n   *\n   */\n  public async processRequest(\n    messageContext: DidCommInboundMessageContext<DidCommRequestPresentationV2Message>\n  ): Promise<DidCommProofExchangeRecord> {\n    const { message: requestMessage, connection, agentContext } = messageContext\n\n    const proofRepository = agentContext.dependencyManager.resolve(DidCommProofExchangeRepository)\n    const didCommMessageRepository = agentContext.dependencyManager.resolve(DidCommMessageRepository)\n    const connectionService = agentContext.dependencyManager.resolve(DidCommConnectionService)\n\n    agentContext.config.logger.debug(`Processing proof request with id ${requestMessage.id}`)\n\n    let proofRecord = await this.findByProperties(messageContext.agentContext, {\n      threadId: requestMessage.threadId,\n      role: DidCommProofRole.Prover,\n    })\n\n    const formatServices = this.getFormatServicesFromMessage(requestMessage.formats)\n    if (formatServices.length === 0) {\n      throw new CredoError('Unable to process request. No supported formats')\n    }\n\n    // proof record already exists\n    if (proofRecord) {\n      const lastSentMessage = await didCommMessageRepository.findAgentMessage(messageContext.agentContext, {\n        associatedRecordId: proofRecord.id,\n        messageClass: DidCommProposePresentationV2Message,\n        role: DidCommMessageRole.Sender,\n      })\n\n      const lastReceivedMessage = await didCommMessageRepository.findAgentMessage(messageContext.agentContext, {\n        associatedRecordId: proofRecord.id,\n        messageClass: DidCommRequestPresentationV2Message,\n        role: DidCommMessageRole.Receiver,\n      })\n\n      // Assert\n      proofRecord.assertProtocolVersion('v2')\n      proofRecord.assertState(DidCommProofState.ProposalSent)\n      await connectionService.assertConnectionOrOutOfBandExchange(messageContext, {\n        lastReceivedMessage,\n        lastSentMessage,\n        expectedConnectionId: proofRecord.connectionId,\n      })\n\n      if (!proofRecord.connectionId) proofRecord.connectionId = connection?.id\n\n      await this.proofFormatCoordinator.processRequest(messageContext.agentContext, {\n        proofRecord,\n        formatServices,\n        message: requestMessage,\n      })\n\n      await this.updateState(messageContext.agentContext, proofRecord, DidCommProofState.RequestReceived)\n      return proofRecord\n    }\n    // Assert\n    await connectionService.assertConnectionOrOutOfBandExchange(messageContext)\n\n    // No proof record exists with thread id\n    agentContext.config.logger.debug('No proof record found for request, creating a new one')\n    proofRecord = new DidCommProofExchangeRecord({\n      connectionId: connection?.id,\n      threadId: requestMessage.threadId,\n      state: DidCommProofState.RequestReceived,\n      role: DidCommProofRole.Prover,\n      protocolVersion: 'v2',\n      parentThreadId: requestMessage.thread?.parentThreadId,\n    })\n\n    await this.proofFormatCoordinator.processRequest(messageContext.agentContext, {\n      proofRecord,\n      formatServices,\n      message: requestMessage,\n    })\n\n    // Save in repository\n    agentContext.config.logger.debug('Saving proof record and emit request-received event')\n    await proofRepository.save(messageContext.agentContext, proofRecord)\n\n    this.emitStateChangedEvent(messageContext.agentContext, proofRecord, null)\n    return proofRecord\n  }\n\n  public async acceptRequest(\n    agentContext: AgentContext,\n    { proofRecord, autoAcceptProof, comment, proofFormats, goalCode, goal }: AcceptProofRequestOptions<PFs>\n  ) {\n    const didCommMessageRepository = agentContext.dependencyManager.resolve(DidCommMessageRepository)\n\n    // Assert\n    proofRecord.assertProtocolVersion('v2')\n    proofRecord.assertState(DidCommProofState.RequestReceived)\n\n    // Use empty proofFormats if not provided to denote all formats should be accepted\n    let formatServices = this.getFormatServices(proofFormats ?? {})\n\n    // if no format services could be extracted from the proofFormats\n    // take all available format services from the request message\n    if (formatServices.length === 0) {\n      const requestMessage = await didCommMessageRepository.getAgentMessage(agentContext, {\n        associatedRecordId: proofRecord.id,\n        messageClass: DidCommRequestPresentationV2Message,\n        role: DidCommMessageRole.Receiver,\n      })\n\n      formatServices = this.getFormatServicesFromMessage(requestMessage.formats)\n    }\n\n    // If the format services list is still empty, throw an error as we don't support any\n    // of the formats\n    if (formatServices.length === 0) {\n      throw new CredoError('Unable to accept request. No supported formats provided as input or in request message')\n    }\n    const message = await this.proofFormatCoordinator.acceptRequest(agentContext, {\n      proofRecord,\n      formatServices,\n      comment,\n      proofFormats,\n      goalCode,\n      goal,\n      // Sending multiple presentation messages not supported at the moment\n      lastPresentation: true,\n    })\n\n    proofRecord.autoAcceptProof = autoAcceptProof ?? proofRecord.autoAcceptProof\n    await this.updateState(agentContext, proofRecord, DidCommProofState.PresentationSent)\n\n    return { proofRecord, message }\n  }\n\n  /**\n   * Create a {@link DidCommProposePresentationV2Message} as response to a received credential request.\n   * To create a proposal not bound to an existing proof exchange, use {@link createProposal}.\n   *\n   * @param options configuration to use for the proposal\n   * @returns Object containing proposal message and associated proof record\n   *\n   */\n  public async negotiateRequest(\n    agentContext: AgentContext,\n    { proofRecord, proofFormats, autoAcceptProof, comment, goalCode, goal }: NegotiateProofRequestOptions<PFs>\n  ): Promise<ProofProtocolMsgReturnType<DidCommProposePresentationV2Message>> {\n    // Assert\n    proofRecord.assertProtocolVersion('v2')\n    proofRecord.assertState(DidCommProofState.RequestReceived)\n\n    if (!proofRecord.connectionId) {\n      throw new CredoError(\n        `No connectionId found for proof record '${proofRecord.id}'. Connection-less verification does not support negotiation.`\n      )\n    }\n\n    const formatServices = this.getFormatServices(proofFormats)\n    if (formatServices.length === 0) {\n      throw new CredoError('Unable to create proposal. No supported formats')\n    }\n\n    const proposalMessage = await this.proofFormatCoordinator.createProposal(agentContext, {\n      formatServices,\n      proofFormats,\n      proofRecord,\n      comment,\n      goalCode,\n      goal,\n    })\n\n    proofRecord.autoAcceptProof = autoAcceptProof ?? proofRecord.autoAcceptProof\n    await this.updateState(agentContext, proofRecord, DidCommProofState.ProposalSent)\n\n    return { proofRecord, message: proposalMessage }\n  }\n\n  public async getCredentialsForRequest(\n    agentContext: AgentContext,\n    { proofRecord, proofFormats }: GetCredentialsForRequestOptions<PFs>\n  ): Promise<GetCredentialsForRequestReturn<PFs>> {\n    const didCommMessageRepository = agentContext.dependencyManager.resolve(DidCommMessageRepository)\n\n    // Assert\n    proofRecord.assertProtocolVersion('v2')\n    proofRecord.assertState(DidCommProofState.RequestReceived)\n\n    // Use empty proofFormats if not provided to denote all formats should be accepted\n    let formatServices = this.getFormatServices(proofFormats ?? {})\n\n    // if no format services could be extracted from the proofFormats\n    // take all available format services from the request message\n    if (formatServices.length === 0) {\n      const requestMessage = await didCommMessageRepository.getAgentMessage(agentContext, {\n        associatedRecordId: proofRecord.id,\n        messageClass: DidCommRequestPresentationV2Message,\n        role: DidCommMessageRole.Receiver,\n      })\n\n      formatServices = this.getFormatServicesFromMessage(requestMessage.formats)\n    }\n\n    // If the format services list is still empty, throw an error as we don't support any\n    // of the formats\n    if (formatServices.length === 0) {\n      throw new CredoError(\n        'Unable to get credentials for request. No supported formats provided as input or in request message'\n      )\n    }\n\n    const result = await this.proofFormatCoordinator.getCredentialsForRequest(agentContext, {\n      formatServices,\n      proofFormats,\n      proofRecord,\n    })\n\n    return {\n      proofFormats: result,\n    }\n  }\n\n  public async selectCredentialsForRequest(\n    agentContext: AgentContext,\n    { proofRecord, proofFormats }: SelectCredentialsForRequestOptions<PFs>\n  ): Promise<SelectCredentialsForRequestReturn<PFs>> {\n    const didCommMessageRepository = agentContext.dependencyManager.resolve(DidCommMessageRepository)\n\n    // Assert\n    proofRecord.assertProtocolVersion('v2')\n    proofRecord.assertState(DidCommProofState.RequestReceived)\n\n    // Use empty proofFormats if not provided to denote all formats should be accepted\n    let formatServices = this.getFormatServices(proofFormats ?? {})\n\n    // if no format services could be extracted from the proofFormats\n    // take all available format services from the request message\n    if (formatServices.length === 0) {\n      const requestMessage = await didCommMessageRepository.getAgentMessage(agentContext, {\n        associatedRecordId: proofRecord.id,\n        messageClass: DidCommRequestPresentationV2Message,\n        role: DidCommMessageRole.Receiver,\n      })\n\n      formatServices = this.getFormatServicesFromMessage(requestMessage.formats)\n    }\n\n    // If the format services list is still empty, throw an error as we don't support any\n    // of the formats\n    if (formatServices.length === 0) {\n      throw new CredoError(\n        'Unable to get credentials for request. No supported formats provided as input or in request message'\n      )\n    }\n\n    const result = await this.proofFormatCoordinator.selectCredentialsForRequest(agentContext, {\n      formatServices,\n      proofFormats,\n      proofRecord,\n    })\n\n    return {\n      proofFormats: result,\n    }\n  }\n\n  public async processPresentation(\n    messageContext: DidCommInboundMessageContext<DidCommPresentationV2Message>\n  ): Promise<DidCommProofExchangeRecord> {\n    const { message: presentationMessage, connection, agentContext } = messageContext\n\n    const didCommMessageRepository = agentContext.dependencyManager.resolve(DidCommMessageRepository)\n    const connectionService = agentContext.dependencyManager.resolve(DidCommConnectionService)\n\n    agentContext.config.logger.debug(`Processing presentation with id ${presentationMessage.id}`)\n\n    const proofRecord = await this.getByProperties(messageContext.agentContext, {\n      threadId: presentationMessage.threadId,\n      role: DidCommProofRole.Verifier,\n    })\n\n    const lastSentMessage = await didCommMessageRepository.getAgentMessage(messageContext.agentContext, {\n      associatedRecordId: proofRecord.id,\n      messageClass: DidCommRequestPresentationV2Message,\n      role: DidCommMessageRole.Sender,\n    })\n\n    const lastReceivedMessage = await didCommMessageRepository.findAgentMessage(messageContext.agentContext, {\n      associatedRecordId: proofRecord.id,\n      messageClass: DidCommProposePresentationV2Message,\n      role: DidCommMessageRole.Receiver,\n    })\n\n    // Assert\n    proofRecord.assertProtocolVersion('v2')\n    proofRecord.assertState(DidCommProofState.RequestSent)\n    await connectionService.assertConnectionOrOutOfBandExchange(messageContext, {\n      lastReceivedMessage,\n      lastSentMessage,\n      expectedConnectionId: proofRecord.connectionId,\n    })\n\n    // This makes sure that the sender of the incoming message is authorized to do so.\n    if (!proofRecord.connectionId) {\n      await connectionService.matchIncomingMessageToRequestMessageInOutOfBandExchange(messageContext, {\n        expectedConnectionId: proofRecord.connectionId,\n      })\n\n      proofRecord.connectionId = connection?.id\n    }\n\n    const formatServices = this.getFormatServicesFromMessage(presentationMessage.formats)\n    // Abandon if no supported formats\n    if (formatServices.length === 0) {\n      proofRecord.errorMessage = 'Unable to process presentation. No supported formats'\n      await this.updateState(messageContext.agentContext, proofRecord, DidCommProofState.Abandoned)\n      throw new V2PresentationProblemReportError(proofRecord.errorMessage, {\n        problemCode: DidCommPresentationProblemReportReason.Abandoned,\n      })\n    }\n\n    const result = await this.proofFormatCoordinator.processPresentation(messageContext.agentContext, {\n      proofRecord,\n      formatServices,\n      requestMessage: lastSentMessage,\n      message: presentationMessage,\n    })\n\n    proofRecord.isVerified = result.isValid\n    if (result.isValid) {\n      await this.updateState(messageContext.agentContext, proofRecord, DidCommProofState.PresentationReceived)\n    } else {\n      proofRecord.errorMessage = result.message\n      proofRecord.isVerified = false\n      await this.updateState(messageContext.agentContext, proofRecord, DidCommProofState.Abandoned)\n      throw new V2PresentationProblemReportError(proofRecord.errorMessage, {\n        problemCode: DidCommPresentationProblemReportReason.Abandoned,\n      })\n    }\n\n    return proofRecord\n  }\n\n  public async acceptPresentation(\n    agentContext: AgentContext,\n    { proofRecord }: AcceptPresentationOptions\n  ): Promise<ProofProtocolMsgReturnType<DidCommPresentationV2AckMessage>> {\n    proofRecord.assertProtocolVersion('v2')\n    proofRecord.assertState(DidCommProofState.PresentationReceived)\n\n    const didCommMessageRepository = agentContext.dependencyManager.resolve(DidCommMessageRepository)\n\n    // assert we've received the final presentation\n    const presentation = await didCommMessageRepository.getAgentMessage(agentContext, {\n      associatedRecordId: proofRecord.id,\n      messageClass: DidCommPresentationV2Message,\n      role: DidCommMessageRole.Receiver,\n    })\n\n    if (!presentation.lastPresentation) {\n      throw new CredoError(\n        `Trying to send an ack message while presentation with id ${presentation.id} indicates this is not the last presentation (presentation.last_presentation is set to false)`\n      )\n    }\n\n    const message = new DidCommPresentationV2AckMessage({\n      threadId: proofRecord.threadId,\n      status: AckStatus.OK,\n    })\n\n    message.setThread({\n      threadId: proofRecord.threadId,\n      parentThreadId: proofRecord.parentThreadId,\n    })\n\n    await this.updateState(agentContext, proofRecord, DidCommProofState.Done)\n\n    return {\n      message,\n      proofRecord,\n    }\n  }\n\n  public async processAck(\n    messageContext: DidCommInboundMessageContext<DidCommPresentationV2AckMessage>\n  ): Promise<DidCommProofExchangeRecord> {\n    const { message: ackMessage, connection, agentContext } = messageContext\n\n    agentContext.config.logger.debug(`Processing proof ack with id ${ackMessage.id}`)\n\n    const didCommMessageRepository = agentContext.dependencyManager.resolve(DidCommMessageRepository)\n    const connectionService = agentContext.dependencyManager.resolve(DidCommConnectionService)\n\n    const proofRecord = await this.getByProperties(messageContext.agentContext, {\n      threadId: ackMessage.threadId,\n      role: DidCommProofRole.Prover,\n      connectionId: connection?.id,\n    })\n    proofRecord.connectionId = connection?.id\n\n    const lastReceivedMessage = await didCommMessageRepository.getAgentMessage(messageContext.agentContext, {\n      associatedRecordId: proofRecord.id,\n      messageClass: DidCommRequestPresentationV2Message,\n      role: DidCommMessageRole.Receiver,\n    })\n\n    const lastSentMessage = await didCommMessageRepository.getAgentMessage(messageContext.agentContext, {\n      associatedRecordId: proofRecord.id,\n      messageClass: DidCommPresentationV2Message,\n      role: DidCommMessageRole.Sender,\n    })\n\n    // Assert\n    proofRecord.assertProtocolVersion('v2')\n    proofRecord.assertState(DidCommProofState.PresentationSent)\n    await connectionService.assertConnectionOrOutOfBandExchange(messageContext, {\n      lastReceivedMessage,\n      lastSentMessage,\n      expectedConnectionId: proofRecord.connectionId,\n    })\n\n    // Update record\n    await this.updateState(messageContext.agentContext, proofRecord, DidCommProofState.Done)\n\n    return proofRecord\n  }\n\n  public async createProblemReport(\n    _agentContext: AgentContext,\n    { description, proofRecord }: CreateProofProblemReportOptions\n  ): Promise<ProofProtocolMsgReturnType<DidCommProblemReportMessage>> {\n    const message = new DidCommPresentationV2ProblemReportMessage({\n      description: {\n        en: description,\n        code: DidCommPresentationProblemReportReason.Abandoned,\n      },\n    })\n\n    message.setThread({\n      threadId: proofRecord.threadId,\n      parentThreadId: proofRecord.parentThreadId,\n    })\n\n    return {\n      proofRecord,\n      message,\n    }\n  }\n\n  public async shouldAutoRespondToProposal(\n    agentContext: AgentContext,\n    options: {\n      proofRecord: DidCommProofExchangeRecord\n      proposalMessage: DidCommProposePresentationV2Message\n    }\n  ): Promise<boolean> {\n    const { proofRecord, proposalMessage } = options\n    const proofsModuleConfig = agentContext.dependencyManager.resolve(DidCommProofsModuleConfig)\n\n    const autoAccept = composeAutoAccept(proofRecord.autoAcceptProof, proofsModuleConfig.autoAcceptProofs)\n\n    // Handle always / never cases\n    if (autoAccept === DidCommAutoAcceptProof.Always) return true\n    if (autoAccept === DidCommAutoAcceptProof.Never) return false\n\n    const requestMessage = await this.findRequestMessage(agentContext, proofRecord.id)\n    if (!requestMessage) return false\n\n    // NOTE: we take the formats from the requestMessage so we always check all services that we last sent\n    // Otherwise we'll only check the formats from the proposal, which could be different from the formats\n    // we use.\n    const formatServices = this.getFormatServicesFromMessage(requestMessage.formats)\n\n    for (const formatService of formatServices) {\n      const requestAttachment = this.proofFormatCoordinator.getAttachmentForService(\n        formatService,\n        requestMessage.formats,\n        requestMessage.requestAttachments\n      )\n\n      const proposalAttachment = this.proofFormatCoordinator.getAttachmentForService(\n        formatService,\n        proposalMessage.formats,\n        proposalMessage.proposalAttachments\n      )\n\n      const shouldAutoRespondToFormat = await formatService.shouldAutoRespondToProposal(agentContext, {\n        proofRecord,\n        requestAttachment,\n        proposalAttachment,\n      })\n      // If any of the formats return false, we should not auto accept\n      if (!shouldAutoRespondToFormat) return false\n    }\n\n    return true\n  }\n\n  public async shouldAutoRespondToRequest(\n    agentContext: AgentContext,\n    options: {\n      proofRecord: DidCommProofExchangeRecord\n      requestMessage: DidCommRequestPresentationV2Message\n    }\n  ): Promise<boolean> {\n    const { proofRecord, requestMessage } = options\n    const proofsModuleConfig = agentContext.dependencyManager.resolve(DidCommProofsModuleConfig)\n\n    const autoAccept = composeAutoAccept(proofRecord.autoAcceptProof, proofsModuleConfig.autoAcceptProofs)\n\n    // Handle always / never cases\n    if (autoAccept === DidCommAutoAcceptProof.Always) return true\n    if (autoAccept === DidCommAutoAcceptProof.Never) return false\n\n    const proposalMessage = await this.findProposalMessage(agentContext, proofRecord.id)\n    if (!proposalMessage) return false\n\n    // NOTE: we take the formats from the proposalMessage so we always check all services that we last sent\n    // Otherwise we'll only check the formats from the request, which could be different from the formats\n    // we use.\n    const formatServices = this.getFormatServicesFromMessage(proposalMessage.formats)\n\n    for (const formatService of formatServices) {\n      const proposalAttachment = this.proofFormatCoordinator.getAttachmentForService(\n        formatService,\n        proposalMessage.formats,\n        proposalMessage.proposalAttachments\n      )\n\n      const requestAttachment = this.proofFormatCoordinator.getAttachmentForService(\n        formatService,\n        requestMessage.formats,\n        requestMessage.requestAttachments\n      )\n\n      const shouldAutoRespondToFormat = await formatService.shouldAutoRespondToRequest(agentContext, {\n        proofRecord,\n        requestAttachment,\n        proposalAttachment,\n      })\n\n      // If any of the formats return false, we should not auto accept\n      if (!shouldAutoRespondToFormat) return false\n    }\n\n    return true\n  }\n\n  public async shouldAutoRespondToPresentation(\n    agentContext: AgentContext,\n    options: { proofRecord: DidCommProofExchangeRecord; presentationMessage: DidCommPresentationV2Message }\n  ): Promise<boolean> {\n    const { proofRecord, presentationMessage } = options\n    const proofsModuleConfig = agentContext.dependencyManager.resolve(DidCommProofsModuleConfig)\n\n    // If this isn't the last presentation yet, we should not auto accept\n    if (!presentationMessage.lastPresentation) return false\n\n    const autoAccept = composeAutoAccept(proofRecord.autoAcceptProof, proofsModuleConfig.autoAcceptProofs)\n\n    // Handle always / never cases\n    if (autoAccept === DidCommAutoAcceptProof.Always) return true\n    if (autoAccept === DidCommAutoAcceptProof.Never) return false\n\n    const proposalMessage = await this.findProposalMessage(agentContext, proofRecord.id)\n\n    const requestMessage = await this.findRequestMessage(agentContext, proofRecord.id)\n    if (!requestMessage) return false\n    if (!requestMessage.willConfirm) return false\n\n    // NOTE: we take the formats from the requestMessage so we always check all services that we last sent\n    // Otherwise we'll only check the formats from the credential, which could be different from the formats\n    // we use.\n    const formatServices = this.getFormatServicesFromMessage(requestMessage.formats)\n\n    for (const formatService of formatServices) {\n      const proposalAttachment = proposalMessage\n        ? this.proofFormatCoordinator.getAttachmentForService(\n            formatService,\n            proposalMessage.formats,\n            proposalMessage.proposalAttachments\n          )\n        : undefined\n\n      const requestAttachment = this.proofFormatCoordinator.getAttachmentForService(\n        formatService,\n        requestMessage.formats,\n        requestMessage.requestAttachments\n      )\n\n      const presentationAttachment = this.proofFormatCoordinator.getAttachmentForService(\n        formatService,\n        presentationMessage.formats,\n        presentationMessage.presentationAttachments\n      )\n\n      const shouldAutoRespondToFormat = await formatService.shouldAutoRespondToPresentation(agentContext, {\n        proofRecord,\n        presentationAttachment,\n        requestAttachment,\n        proposalAttachment,\n      })\n\n      // If any of the formats return false, we should not auto accept\n      if (!shouldAutoRespondToFormat) return false\n    }\n    return true\n  }\n\n  public async findRequestMessage(\n    agentContext: AgentContext,\n    proofExchangeRecordId: string\n  ): Promise<DidCommRequestPresentationV2Message | null> {\n    const didCommMessageRepository = agentContext.dependencyManager.resolve(DidCommMessageRepository)\n\n    return await didCommMessageRepository.findAgentMessage(agentContext, {\n      associatedRecordId: proofExchangeRecordId,\n      messageClass: DidCommRequestPresentationV2Message,\n    })\n  }\n\n  public async findPresentationMessage(\n    agentContext: AgentContext,\n    proofExchangeRecordId: string\n  ): Promise<DidCommPresentationV2Message | null> {\n    const didCommMessageRepository = agentContext.dependencyManager.resolve(DidCommMessageRepository)\n\n    return await didCommMessageRepository.findAgentMessage(agentContext, {\n      associatedRecordId: proofExchangeRecordId,\n      messageClass: DidCommPresentationV2Message,\n    })\n  }\n\n  public async findProposalMessage(\n    agentContext: AgentContext,\n    proofExchangeRecordId: string\n  ): Promise<DidCommProposePresentationV2Message | null> {\n    const didCommMessageRepository = agentContext.dependencyManager.resolve(DidCommMessageRepository)\n\n    return await didCommMessageRepository.findAgentMessage(agentContext, {\n      associatedRecordId: proofExchangeRecordId,\n      messageClass: DidCommProposePresentationV2Message,\n    })\n  }\n\n  public async getFormatData(\n    agentContext: AgentContext,\n    proofExchangeRecordId: string\n  ): Promise<GetProofFormatDataReturn> {\n    // TODO: we could looking at fetching all record using a single query and then filtering based on the type of the message.\n    const [proposalMessage, requestMessage, presentationMessage] = await Promise.all([\n      this.findProposalMessage(agentContext, proofExchangeRecordId),\n      this.findRequestMessage(agentContext, proofExchangeRecordId),\n      this.findPresentationMessage(agentContext, proofExchangeRecordId),\n    ])\n\n    // Create object with the keys and the message formats/attachments. We can then loop over this in a generic\n    // way so we don't have to add the same operation code four times\n    const messages = {\n      proposal: [proposalMessage?.formats, proposalMessage?.proposalAttachments],\n      request: [requestMessage?.formats, requestMessage?.requestAttachments],\n      presentation: [presentationMessage?.formats, presentationMessage?.presentationAttachments],\n    } as const\n\n    const formatData: GetProofFormatDataReturn = {}\n\n    // We loop through all of the message keys as defined above\n    for (const [messageKey, [formats, attachments]] of Object.entries(messages)) {\n      // Message can be undefined, so we continue if it is not defined\n      if (!formats || !attachments) continue\n\n      // Find all format services associated with the message\n      const formatServices = this.getFormatServicesFromMessage(formats)\n\n      const messageFormatData: ProofFormatDataMessagePayload = {}\n\n      // Loop through all of the format services, for each we will extract the attachment data and assign this to the object\n      // using the unique format key (e.g. indy)\n      for (const formatService of formatServices) {\n        const attachment = this.proofFormatCoordinator.getAttachmentForService(formatService, formats, attachments)\n        messageFormatData[formatService.formatKey] = attachment.getDataAsJson()\n      }\n\n      formatData[messageKey as keyof GetProofFormatDataReturn] = messageFormatData\n    }\n\n    return formatData\n  }\n\n  /**\n   * Get all the format service objects for a given proof format from an incoming message\n   * @param messageFormats the format objects containing the format name (eg indy)\n   * @return the proof format service objects in an array - derived from format object keys\n   */\n  private getFormatServicesFromMessage(messageFormats: DidCommProofFormatSpec[]): DidCommProofFormatService[] {\n    const formatServices = new Set<DidCommProofFormatService>()\n\n    for (const msg of messageFormats) {\n      const service = this.getFormatServiceForFormat(msg.format)\n      if (service) formatServices.add(service)\n    }\n\n    return Array.from(formatServices)\n  }\n\n  /**\n   * Get all the format service objects for a given proof format\n   * @param proofFormats the format object containing various optional parameters\n   * @return the proof format service objects in an array - derived from format object keys\n   */\n  private getFormatServices<M extends keyof DidCommProofFormat['proofFormats']>(\n    proofFormats: M extends 'selectCredentialsForRequest' | 'getCredentialsForRequest'\n      ? DidCommProofFormatCredentialForRequestPayload<ExtractProofFormats<PFs>, M, 'input'>\n      : DidCommProofFormatPayload<ExtractProofFormats<PFs>, M>\n  ): DidCommProofFormatService[] {\n    const formats = new Set<DidCommProofFormatService>()\n\n    for (const formatKey of Object.keys(proofFormats)) {\n      const formatService = this.getFormatServiceForFormatKey(formatKey)\n\n      if (formatService) formats.add(formatService)\n    }\n\n    return Array.from(formats)\n  }\n\n  private getFormatServiceForFormatKey(formatKey: string): DidCommProofFormatService | null {\n    const formatService = this.proofFormats.find((proofFormats) => proofFormats.formatKey === formatKey)\n\n    return formatService ?? null\n  }\n\n  private getFormatServiceForFormat(format: string): DidCommProofFormatService | null {\n    const formatService = this.proofFormats.find((proofFormats) => proofFormats.supportsFormat(format))\n\n    return formatService ?? null\n  }\n}\n"],"mappings":"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"}