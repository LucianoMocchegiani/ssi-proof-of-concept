import { DidCommConnectionService } from "../../connections/services/DidCommConnectionService.mjs";
import "../../connections/index.mjs";
import { DidCommMessageRepository } from "../../../repository/DidCommMessageRepository.mjs";
import "../../../repository/index.mjs";
import { DidCommProofEventTypes } from "../DidCommProofEvents.mjs";
import { DidCommProofState } from "../models/DidCommProofState.mjs";
import { DidCommProofExchangeRepository } from "../repository/DidCommProofExchangeRepository.mjs";
import "../repository/index.mjs";
import { EventEmitter } from "@credo-ts/core";

//#region src/modules/proofs/protocol/DidCommBaseProofProtocol.ts
var DidCommBaseProofProtocol = class {
	async processProblemReport(messageContext) {
		const { message: proofProblemReportMessage, agentContext, connection } = messageContext;
		const connectionService = agentContext.dependencyManager.resolve(DidCommConnectionService);
		agentContext.config.logger.debug(`Processing problem report with message id ${proofProblemReportMessage.id}`);
		const proofRecord = await this.getByProperties(agentContext, { threadId: proofProblemReportMessage.threadId });
		await connectionService.assertConnectionOrOutOfBandExchange(messageContext, { expectedConnectionId: proofRecord.connectionId });
		if (!proofRecord?.connectionId) {
			await connectionService.matchIncomingMessageToRequestMessageInOutOfBandExchange(messageContext, { expectedConnectionId: proofRecord?.connectionId });
			proofRecord.connectionId = connection?.id;
		}
		proofRecord.errorMessage = `${proofProblemReportMessage.description.code}: ${proofProblemReportMessage.description.en}`;
		await this.updateState(agentContext, proofRecord, DidCommProofState.Abandoned);
		return proofRecord;
	}
	/**
	* Update the record to a new state and emit an state changed event. Also updates the record
	* in storage.
	*
	* @param proofRecord The proof record to update the state for
	* @param newState The state to update to
	*
	*/
	async updateState(agentContext, proofRecord, newState) {
		const proofRepository = agentContext.dependencyManager.resolve(DidCommProofExchangeRepository);
		agentContext.config.logger.debug(`Updating proof record ${proofRecord.id} to state ${newState} (previous=${proofRecord.state})`);
		const previousState = proofRecord.state;
		proofRecord.state = newState;
		await proofRepository.update(agentContext, proofRecord);
		this.emitStateChangedEvent(agentContext, proofRecord, previousState);
	}
	emitStateChangedEvent(agentContext, proofRecord, previousState) {
		agentContext.dependencyManager.resolve(EventEmitter).emit(agentContext, {
			type: DidCommProofEventTypes.ProofStateChanged,
			payload: {
				proofRecord: proofRecord.clone(),
				previousState
			}
		});
	}
	/**
	* Retrieve a proof record by id
	*
	* @param proofExchangeRecordId The proof record id
	* @throws {RecordNotFoundError} If no record is found
	* @return The proof record
	*
	*/
	getById(agentContext, proofExchangeRecordId) {
		return agentContext.dependencyManager.resolve(DidCommProofExchangeRepository).getById(agentContext, proofExchangeRecordId);
	}
	/**
	* Retrieve all proof records
	*
	* @returns List containing all proof records
	*/
	getAll(agentContext) {
		return agentContext.dependencyManager.resolve(DidCommProofExchangeRepository).getAll(agentContext);
	}
	async findAllByQuery(agentContext, query, queryOptions) {
		return agentContext.dependencyManager.resolve(DidCommProofExchangeRepository).findByQuery(agentContext, query, queryOptions);
	}
	/**
	* Find a proof record by id
	*
	* @param proofExchangeRecordId the proof record id
	* @returns The proof record or null if not found
	*/
	findById(agentContext, proofExchangeRecordId) {
		return agentContext.dependencyManager.resolve(DidCommProofExchangeRepository).findById(agentContext, proofExchangeRecordId);
	}
	async delete(agentContext, proofRecord, options) {
		const proofRepository = agentContext.dependencyManager.resolve(DidCommProofExchangeRepository);
		const didCommMessageRepository = agentContext.dependencyManager.resolve(DidCommMessageRepository);
		await proofRepository.delete(agentContext, proofRecord);
		if (options?.deleteAssociatedDidCommMessages ?? true) {
			const didCommMessages = await didCommMessageRepository.findByQuery(agentContext, { associatedRecordId: proofRecord.id });
			for (const didCommMessage of didCommMessages) await didCommMessageRepository.delete(agentContext, didCommMessage);
		}
	}
	/**
	* Retrieve a proof record by connection id and thread id
	*
	* @param properties Properties to query by
	*
	* @throws {RecordNotFoundError} If no record is found
	* @throws {RecordDuplicateError} If multiple records are found
	*
	* @returns The proof record
	*/
	getByProperties(agentContext, properties) {
		const { threadId, connectionId, role } = properties;
		return agentContext.dependencyManager.resolve(DidCommProofExchangeRepository).getSingleByQuery(agentContext, {
			connectionId,
			threadId,
			role
		});
	}
	/**
	* Find a proof record by connection id and thread id, returns null if not found
	*
	* @param properties Properties to query by
	*
	* @returns The proof record
	*/
	findByProperties(agentContext, properties) {
		const { role, connectionId, threadId } = properties;
		return agentContext.dependencyManager.resolve(DidCommProofExchangeRepository).findSingleByQuery(agentContext, {
			connectionId,
			threadId,
			role
		});
	}
	async update(agentContext, proofRecord) {
		return await agentContext.dependencyManager.resolve(DidCommProofExchangeRepository).update(agentContext, proofRecord);
	}
};

//#endregion
export { DidCommBaseProofProtocol };
//# sourceMappingURL=DidCommBaseProofProtocol.mjs.map