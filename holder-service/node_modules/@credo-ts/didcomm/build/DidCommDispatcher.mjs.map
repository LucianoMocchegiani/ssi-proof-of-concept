{"version":3,"file":"DidCommDispatcher.mjs","names":[],"sources":["../src/DidCommDispatcher.ts"],"sourcesContent":["import { CredoError, EventEmitter, InjectionSymbols, inject, injectable, type Logger } from '@credo-ts/core'\nimport type { DidCommMessageProcessedEvent } from './DidCommEvents'\nimport { DidCommEventTypes } from './DidCommEvents'\nimport type { DidCommMessage } from './DidCommMessage'\nimport { DidCommMessageHandlerRegistry } from './DidCommMessageHandlerRegistry'\nimport { DidCommMessageSender } from './DidCommMessageSender'\nimport { DidCommProblemReportError } from './errors/problem-reports'\nimport { DidCommMessageHandlerMiddlewareRunner } from './handlers'\nimport type { DidCommMessageHandlerMiddleware } from './handlers/DidCommMessageHandlerMiddleware'\nimport { DidCommProblemReportMessage } from './messages'\nimport { DidCommOutboundMessageContext } from './models'\nimport type { DidCommInboundMessageContext } from './models/DidCommInboundMessageContext'\nimport { DidCommProblemReportReason } from './models/problem-reports'\nimport { canHandleMessageType, parseMessageType } from './util/messageType'\n\n@injectable()\nexport class DidCommDispatcher {\n  private messageHandlerRegistry: DidCommMessageHandlerRegistry\n  private messageSender: DidCommMessageSender\n  private eventEmitter: EventEmitter\n  private logger: Logger\n\n  public constructor(\n    messageSender: DidCommMessageSender,\n    eventEmitter: EventEmitter,\n    messageHandlerRegistry: DidCommMessageHandlerRegistry,\n    @inject(InjectionSymbols.Logger) logger: Logger\n  ) {\n    this.messageSender = messageSender\n    this.eventEmitter = eventEmitter\n    this.messageHandlerRegistry = messageHandlerRegistry\n    this.logger = logger\n  }\n\n  private defaultHandlerMiddleware: DidCommMessageHandlerMiddleware = async (inboundMessageContext, next) => {\n    let messageHandler = inboundMessageContext.messageHandler\n\n    const fallbackMessageHandler =\n      inboundMessageContext.agentContext.dependencyManager.resolve(DidCommMessageHandlerRegistry).fallbackMessageHandler\n    if (!messageHandler && fallbackMessageHandler) {\n      messageHandler = {\n        supportedMessages: [],\n        handle: fallbackMessageHandler,\n      }\n    }\n\n    if (!messageHandler) {\n      throw new DidCommProblemReportError(\n        `Error handling message ${inboundMessageContext.message.id} with type ${inboundMessageContext.message.type}. The message type is not supported`,\n        {\n          problemCode: DidCommProblemReportReason.MessageParseFailure,\n        }\n      )\n    }\n\n    const outboundMessage = await messageHandler.handle(inboundMessageContext)\n    if (outboundMessage) {\n      inboundMessageContext.setResponseMessage(outboundMessage)\n    }\n\n    await next()\n  }\n\n  public async dispatch(messageContext: DidCommInboundMessageContext): Promise<void> {\n    const { agentContext, connection, senderKey, recipientKey, message, encryptedMessage } = messageContext\n\n    // Set default handler if available, middleware can still override the message handler\n    const messageHandler = this.messageHandlerRegistry.getHandlerForMessageType(message.type)\n    if (messageHandler) {\n      messageContext.setMessageHandler(messageHandler)\n    }\n\n    let outboundMessage: DidCommOutboundMessageContext<DidCommMessage> | undefined\n\n    try {\n      const messageHandlerMiddlewares =\n        agentContext.dependencyManager.resolve(DidCommMessageHandlerRegistry).messageHandlerMiddlewares\n      const middlewares = [...messageHandlerMiddlewares, this.defaultHandlerMiddleware]\n      await DidCommMessageHandlerMiddlewareRunner.run(middlewares, messageContext)\n\n      outboundMessage = messageContext.responseMessage\n    } catch (error) {\n      const problemReportMessage = error.problemReport\n\n      if (problemReportMessage instanceof DidCommProblemReportMessage && messageContext.connection) {\n        const messageType = parseMessageType(messageContext.message.type)\n        if (canHandleMessageType(DidCommProblemReportMessage, messageType)) {\n          throw new CredoError(`Not sending problem report in response to problem report: ${message}`)\n        }\n\n        const { protocolUri: problemReportProtocolUri } = parseMessageType(problemReportMessage.type)\n        const { protocolUri: inboundProtocolUri } = parseMessageType(messageContext.message.type)\n\n        // If the inbound protocol uri is the same as the problem report protocol uri, we can see the interaction as the same thread\n        // However if it is no the same we should see it as a new thread, where the inbound message `@id` is the parentThreadId\n        if (inboundProtocolUri === problemReportProtocolUri) {\n          problemReportMessage.setThread({\n            threadId: message.threadId,\n          })\n        } else {\n          problemReportMessage.setThread({\n            parentThreadId: message.id,\n          })\n        }\n\n        outboundMessage = new DidCommOutboundMessageContext(problemReportMessage, {\n          agentContext,\n          connection: messageContext.connection,\n          inboundMessageContext: messageContext,\n        })\n      } else {\n        this.logger.error(`Error handling message with type ${message.type}`, {\n          message: message.toJSON(),\n          error,\n          senderKey: senderKey?.fingerprint,\n          recipientKey: recipientKey?.fingerprint,\n          connectionId: connection?.id,\n        })\n\n        throw error\n      }\n    }\n\n    if (outboundMessage) {\n      // set the inbound message context, if not already defined\n      if (!outboundMessage.inboundMessageContext) {\n        outboundMessage.inboundMessageContext = messageContext\n      }\n\n      await this.messageSender.sendMessage(outboundMessage)\n    }\n\n    // Emit event that allows to hook into received messages\n    this.eventEmitter.emit<DidCommMessageProcessedEvent>(agentContext, {\n      type: DidCommEventTypes.DidCommMessageProcessed,\n      payload: {\n        message,\n        connection,\n        receivedAt: messageContext.receivedAt,\n        encryptedMessage,\n      },\n    })\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;AAgBO,8BAAM,kBAAkB;CAM7B,AAAO,YACL,eACA,cACA,wBACA,AAAiC,QACjC;OAOM,2BAA4D,OAAO,uBAAuB,SAAS;GACzG,IAAI,iBAAiB,sBAAsB;GAE3C,MAAM,yBACJ,sBAAsB,aAAa,kBAAkB,QAAQ,8BAA8B,CAAC;AAC9F,OAAI,CAAC,kBAAkB,uBACrB,kBAAiB;IACf,mBAAmB,EAAE;IACrB,QAAQ;IACT;AAGH,OAAI,CAAC,eACH,OAAM,IAAI,0BACR,0BAA0B,sBAAsB,QAAQ,GAAG,aAAa,sBAAsB,QAAQ,KAAK,sCAC3G,EACE,aAAa,2BAA2B,qBACzC,CACF;GAGH,MAAM,kBAAkB,MAAM,eAAe,OAAO,sBAAsB;AAC1E,OAAI,gBACF,uBAAsB,mBAAmB,gBAAgB;AAG3D,SAAM,MAAM;;AAhCZ,OAAK,gBAAgB;AACrB,OAAK,eAAe;AACpB,OAAK,yBAAyB;AAC9B,OAAK,SAAS;;CAgChB,MAAa,SAAS,gBAA6D;EACjF,MAAM,EAAE,cAAc,YAAY,WAAW,cAAc,SAAS,qBAAqB;EAGzF,MAAM,iBAAiB,KAAK,uBAAuB,yBAAyB,QAAQ,KAAK;AACzF,MAAI,eACF,gBAAe,kBAAkB,eAAe;EAGlD,IAAI;AAEJ,MAAI;GAGF,MAAM,cAAc,CAAC,GADnB,aAAa,kBAAkB,QAAQ,8BAA8B,CAAC,2BACrB,KAAK,yBAAyB;AACjF,SAAM,sCAAsC,IAAI,aAAa,eAAe;AAE5E,qBAAkB,eAAe;WAC1B,OAAO;GACd,MAAM,uBAAuB,MAAM;AAEnC,OAAI,gCAAgC,+BAA+B,eAAe,YAAY;AAE5F,QAAI,qBAAqB,6BADL,iBAAiB,eAAe,QAAQ,KAAK,CACC,CAChE,OAAM,IAAI,WAAW,6DAA6D,UAAU;IAG9F,MAAM,EAAE,aAAa,6BAA6B,iBAAiB,qBAAqB,KAAK;IAC7F,MAAM,EAAE,aAAa,uBAAuB,iBAAiB,eAAe,QAAQ,KAAK;AAIzF,QAAI,uBAAuB,yBACzB,sBAAqB,UAAU,EAC7B,UAAU,QAAQ,UACnB,CAAC;QAEF,sBAAqB,UAAU,EAC7B,gBAAgB,QAAQ,IACzB,CAAC;AAGJ,sBAAkB,IAAI,8BAA8B,sBAAsB;KACxE;KACA,YAAY,eAAe;KAC3B,uBAAuB;KACxB,CAAC;UACG;AACL,SAAK,OAAO,MAAM,oCAAoC,QAAQ,QAAQ;KACpE,SAAS,QAAQ,QAAQ;KACzB;KACA,WAAW,WAAW;KACtB,cAAc,cAAc;KAC5B,cAAc,YAAY;KAC3B,CAAC;AAEF,UAAM;;;AAIV,MAAI,iBAAiB;AAEnB,OAAI,CAAC,gBAAgB,sBACnB,iBAAgB,wBAAwB;AAG1C,SAAM,KAAK,cAAc,YAAY,gBAAgB;;AAIvD,OAAK,aAAa,KAAmC,cAAc;GACjE,MAAM,kBAAkB;GACxB,SAAS;IACP;IACA;IACA,YAAY,eAAe;IAC3B;IACD;GACF,CAAC;;;;CA9HL,YAAY;oBAWR,OAAO,iBAAiB,OAAO"}