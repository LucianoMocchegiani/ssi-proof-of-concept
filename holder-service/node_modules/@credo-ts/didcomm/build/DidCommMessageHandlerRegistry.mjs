import { __decorate } from "./_virtual/_@oxc-project_runtime@0.110.0/helpers/decorate.mjs";
import { canHandleMessageType, parseMessageType, supportsIncomingDidCommProtocolUri } from "./util/messageType.mjs";
import { injectable } from "@credo-ts/core";

//#region src/DidCommMessageHandlerRegistry.ts
let DidCommMessageHandlerRegistry = class DidCommMessageHandlerRegistry {
	constructor() {
		this.messageHandlers = [];
		this.messageHandlerMiddlewares = [];
	}
	registerMessageHandler(messageHandler) {
		this.messageHandlers.push(messageHandler);
	}
	registerMessageHandlers(messageHandlers) {
		for (const messageHandler of messageHandlers) this.registerMessageHandler(messageHandler);
	}
	registerMessageHandlerMiddleware(messageHandlerMiddleware) {
		this.messageHandlerMiddlewares.push(messageHandlerMiddleware);
	}
	get fallbackMessageHandler() {
		return this._fallbackMessageHandler;
	}
	/**
	* Sets the fallback message handler, the message handler that will be called if no handler
	* is registered for an incoming message type.
	*/
	setFallbackMessageHandler(fallbackMessageHandler) {
		this._fallbackMessageHandler = fallbackMessageHandler;
	}
	getHandlerForMessageType(messageType) {
		const incomingMessageType = parseMessageType(messageType);
		for (const handler of this.messageHandlers) for (const MessageClass of handler.supportedMessages) if (canHandleMessageType(MessageClass, incomingMessageType)) return handler;
	}
	getMessageClassForMessageType(messageType) {
		const incomingMessageType = parseMessageType(messageType);
		for (const handler of this.messageHandlers) for (const MessageClass of handler.supportedMessages) if (canHandleMessageType(MessageClass, incomingMessageType)) return MessageClass;
	}
	/**
	* Returns array of message types that dispatcher is able to handle.
	* Message type format is MTURI specified at https://github.com/hyperledger/aries-rfcs/blob/main/concepts/0003-protocols/README.md#mturi.
	*/
	get supportedMessageTypes() {
		return this.messageHandlers.reduce((all, cur) => [...all, ...cur.supportedMessages], []).map((m) => m.type);
	}
	/**
	* Returns array of protocol IDs that dispatcher is able to handle.
	* Protocol ID format is PIURI specified at https://github.com/hyperledger/aries-rfcs/blob/main/concepts/0003-protocols/README.md#piuri.
	*/
	get supportedProtocolUris() {
		const seenProtocolUris = /* @__PURE__ */ new Set();
		return this.supportedMessageTypes.filter((m) => {
			const has = seenProtocolUris.has(m.protocolUri);
			seenProtocolUris.add(m.protocolUri);
			return !has;
		}).map(({ messageName, messageTypeUri, ...parsedProtocolUri }) => parsedProtocolUri);
	}
	filterSupportedProtocolsByProtocolUris(parsedProtocolUris) {
		return this.supportedProtocolUris.filter((supportedProtocol) => parsedProtocolUris.some((p) => supportsIncomingDidCommProtocolUri(supportedProtocol, p)));
	}
};
DidCommMessageHandlerRegistry = __decorate([injectable()], DidCommMessageHandlerRegistry);

//#endregion
export { DidCommMessageHandlerRegistry };
//# sourceMappingURL=DidCommMessageHandlerRegistry.mjs.map