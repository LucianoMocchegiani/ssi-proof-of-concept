import { ThreadDecorator } from "./decorators/thread/ThreadDecorator.mjs";
import { L10nDecorator } from "./decorators/l10n/L10nDecorator.mjs";
import { ReturnRouteTypes, TransportDecorator } from "./decorators/transport/TransportDecorator.mjs";
import { TimingDecorator } from "./decorators/timing/TimingDecorator.mjs";
import { AckDecorator, AckValues } from "./decorators/ack/AckDecorator.mjs";
import { DidCommPlaintextMessage } from "./types.mjs";
import { ParsedMessageType } from "./util/messageType.mjs";
import { BaseDidCommMessage } from "./BaseDidCommMessage.mjs";
import { DidCommAttachment } from "./decorators/attachment/DidCommAttachment.mjs";
import { ServiceDecorator, ServiceDecoratorOptions } from "./decorators/service/ServiceDecorator.mjs";
import "./index.mjs";
import { Constructor } from "@credo-ts/core";

//#region src/DidCommMessage.d.ts
type ConstructableAgentMessage = Constructor<DidCommMessage> & {
  type: ParsedMessageType;
};
declare const Decorated: {
  new (...args: any[]): {
    thread?: ThreadDecorator;
    get threadId(): string;
    setThread(options: Partial<ThreadDecorator>): void;
    id: string;
    readonly type: string;
    generateId(): string;
  };
} & {
  new (...args: any[]): {
    l10n?: L10nDecorator;
    addLocale(locale: string): void;
    getLocale(): string | undefined;
    id: string;
    readonly type: string;
    generateId(): string;
  };
} & {
  new (...args: any[]): {
    transport?: TransportDecorator;
    setReturnRouting(type: ReturnRouteTypes, thread?: string): void;
    hasReturnRouting(threadId?: string): boolean;
    hasAnyReturnRoute(): boolean;
    id: string;
    readonly type: string;
    generateId(): string;
  };
} & {
  new (...args: any[]): {
    timing?: TimingDecorator;
    setTiming(options: Partial<TimingDecorator>): void;
    id: string;
    readonly type: string;
    generateId(): string;
  };
} & {
  new (...args: any[]): {
    pleaseAck?: AckDecorator;
    setPleaseAck(on?: [AckValues.Receipt]): void;
    getPleaseAck(): AckDecorator | undefined;
    requiresAck(): boolean;
    id: string;
    readonly type: string;
    generateId(): string;
  };
} & {
  new (...args: any[]): {
    appendedAttachments?: DidCommAttachment[];
    getAppendedAttachmentById(id: string): DidCommAttachment | undefined;
    addAppendedAttachment(attachment: DidCommAttachment): void;
    id: string;
    readonly type: string;
    generateId(): string;
  };
} & {
  new (...args: any[]): {
    service?: ServiceDecorator;
    setService(serviceData: ServiceDecoratorOptions): void;
    id: string;
    readonly type: string;
    generateId(): string;
  };
} & typeof BaseDidCommMessage;
declare class DidCommMessage extends Decorated {
  /**
   * Whether the protocol RFC was initially written using the legacy did:prefix instead of the
   * new https://didcomm.org message type prefix.
   *
   * @see https://github.com/hyperledger/aries-rfcs/blob/main/features/0348-transition-msg-type-to-https/README.md
   */
  readonly allowDidSovPrefix: boolean;
  /**
   * Whether to use Queue Transport in case the recipient of this message does not have a reliable
   * endpoint available
   *
   * @see https://github.com/decentralized-identity/didcomm-messaging/blob/main/extensions/return_route/main.md#queue-transport
   */
  readonly allowQueueTransport: boolean;
  toJSON({
    useDidSovPrefixWhereAllowed
  }?: {
    useDidSovPrefixWhereAllowed?: boolean;
  }): DidCommPlaintextMessage;
  is<C extends typeof DidCommMessage>(Class: C): this is InstanceType<C>;
}
//#endregion
export { ConstructableAgentMessage, DidCommMessage };
//# sourceMappingURL=DidCommMessage.d.mts.map