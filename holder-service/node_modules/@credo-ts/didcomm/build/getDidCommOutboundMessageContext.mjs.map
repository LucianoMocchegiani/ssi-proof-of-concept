{"version":3,"file":"getDidCommOutboundMessageContext.mjs","names":[],"sources":["../src/getDidCommOutboundMessageContext.ts"],"sourcesContent":["import type { AgentContext, BaseRecordAny, ResolvedDidCommService } from '@credo-ts/core'\nimport { CredoError, Kms, utils } from '@credo-ts/core'\nimport type { DidCommMessage } from './DidCommMessage'\nimport { ServiceDecorator } from './decorators/service/ServiceDecorator'\nimport type { DidCommRouting } from './models'\nimport { DidCommOutboundMessageContext } from './models'\nimport type { DidCommConnectionRecord } from './modules/connections/repository'\nimport type { DidCommOutOfBandRecord } from './modules/oob'\nimport {\n  DidCommInvitationType,\n  DidCommOutOfBandRepository,\n  DidCommOutOfBandRole,\n  DidCommOutOfBandService,\n} from './modules/oob'\nimport { DidCommOutOfBandRecordMetadataKeys } from './modules/oob/repository/outOfBandRecordMetadataTypes'\nimport { DidCommRoutingService } from './modules/routing'\nimport { DidCommMessageRepository, DidCommMessageRole } from './repository'\n\n/**\n * Maybe these methods should be moved to a service, but that would require\n * extra injection in the sender functions, and I'm not 100% sure what would\n * be the best place to host these.\n */\n\n/**\n * Get the outbound message context for a message. Will use the connection record if available,\n * and otherwise try to create a connectionless message context.\n */\nexport async function getOutboundDidCommMessageContext(\n  agentContext: AgentContext,\n  {\n    message,\n    connectionRecord,\n    associatedRecord,\n    lastReceivedMessage,\n    lastSentMessage,\n  }: {\n    connectionRecord?: DidCommConnectionRecord\n    associatedRecord?: BaseRecordAny\n    message: DidCommMessage\n    lastReceivedMessage?: DidCommMessage\n    lastSentMessage?: DidCommMessage\n  }\n) {\n  // TODO: even if using a connection record, we should check if there's an oob record associated and this\n  // is the first response to the oob invitation. If so, we should add the parentThreadId to the message\n  if (connectionRecord) {\n    agentContext.config.logger.debug(\n      `Creating outbound message context for message ${message.id} with connection ${connectionRecord.id}`\n    )\n    return new DidCommOutboundMessageContext(message, {\n      agentContext,\n      associatedRecord,\n      connection: connectionRecord,\n    })\n  }\n\n  if (!lastReceivedMessage) {\n    throw new CredoError(\n      'No connection record and no lastReceivedMessage was supplied. For connection-less exchanges the lastReceivedMessage is required.'\n    )\n  }\n\n  if (!associatedRecord) {\n    throw new CredoError(\n      'No associated record was supplied. This is required for connection-less exchanges to store the associated ~service decorator on the message.'\n    )\n  }\n\n  // Connectionless\n  return getConnectionlessOutboundMessageContext(agentContext, {\n    message,\n    associatedRecord,\n    lastReceivedMessage,\n    lastSentMessage,\n  })\n}\n\nexport async function getConnectionlessOutboundMessageContext(\n  agentContext: AgentContext,\n  {\n    message,\n    lastReceivedMessage,\n    lastSentMessage,\n    associatedRecord,\n  }: {\n    message: DidCommMessage\n    associatedRecord: BaseRecordAny\n    lastReceivedMessage: DidCommMessage\n    lastSentMessage?: DidCommMessage\n  }\n) {\n  agentContext.config.logger.debug(\n    `Creating outbound message context for message ${message.id} using connection-less exchange`\n  )\n\n  // FIXME: we should remove support for the flow where no out of band record is used.\n  // Users have had enough time to update to the OOB API which supports legacy connectionsless\n  // invitations as well\n  const outOfBandRecord = await getOutOfBandRecordForMessage(agentContext, message)\n  let { recipientService, ourService } = await getServicesForMessage(agentContext, {\n    lastReceivedMessage,\n    lastSentMessage,\n    message,\n    outOfBandRecord,\n  })\n\n  // We need to set up routing for this exchange if we haven't sent any messages yet.\n  if (!lastSentMessage) {\n    ourService = await createOurService(agentContext, { outOfBandRecord, message })\n  }\n\n  // These errors should not happen as they will be caught by the checks above. But if there's a path missed,\n  // and to make typescript happy we add these checks.\n  if (!ourService) {\n    throw new CredoError(`Could not determine our service for connection-less exchange for message ${message.id}.`)\n  }\n  if (!recipientService) {\n    throw new CredoError(\n      `Could not determine recipient service for connection-less exchange for message ${message.id}.`\n    )\n  }\n\n  // Adds the ~service and ~thread.pthid (if oob is used) to the message and updates it in storage.\n  await addExchangeDataToMessage(agentContext, { message, ourService, outOfBandRecord, associatedRecord })\n\n  return new DidCommOutboundMessageContext(message, {\n    agentContext: agentContext,\n    associatedRecord,\n    serviceParams: {\n      service: recipientService,\n      senderKey: ourService.recipientKeys[0],\n      returnRoute: true,\n    },\n  })\n}\n\n/**\n * Retrieves the out of band record associated with the message based on the thread id of the message.\n */\nasync function getOutOfBandRecordForMessage(agentContext: AgentContext, message: DidCommMessage) {\n  agentContext.config.logger.debug(\n    `Looking for out-of-band record for message ${message.id} with thread id ${message.threadId} and type ${message.type}`\n  )\n  const outOfBandRepository = agentContext.dependencyManager.resolve(DidCommOutOfBandRepository)\n\n  const outOfBandRecord = await outOfBandRepository.findSingleByQuery(agentContext, {\n    invitationRequestsThreadIds: [message.threadId],\n  })\n\n  return outOfBandRecord ?? undefined\n}\n\n/**\n * Returns the services to use for the message. When available it will extract the services from the\n * lastSentMessage and lastReceivedMessage. If not available it will try to extract the services from\n * the out of band record.\n *\n * If the required services and fields are not available, an error will be thrown.\n */\nasync function getServicesForMessage(\n  agentContext: AgentContext,\n  {\n    lastSentMessage,\n    lastReceivedMessage,\n    message,\n    outOfBandRecord,\n  }: {\n    lastSentMessage?: DidCommMessage\n    lastReceivedMessage: DidCommMessage\n    message: DidCommMessage\n    outOfBandRecord?: DidCommOutOfBandRecord\n  }\n) {\n  let ourService = lastSentMessage?.service?.resolvedDidCommService\n  let recipientService = lastReceivedMessage.service?.resolvedDidCommService\n\n  const outOfBandService = agentContext.dependencyManager.resolve(DidCommOutOfBandService)\n\n  // Check if valid\n  if (outOfBandRecord?.role === DidCommOutOfBandRole.Sender) {\n    // Extract ourService from the oob record if not on a previous message\n    if (!ourService) {\n      ourService = await outOfBandService.getResolvedServiceForOutOfBandServices(\n        agentContext,\n        outOfBandRecord.outOfBandInvitation.getServices(),\n        outOfBandRecord.invitationInlineServiceKeys\n      )\n    }\n\n    if (!recipientService) {\n      throw new CredoError(\n        'Could not find a service to send the message to. Please make sure the connection has a service or provide a service to send the message to.'\n      )\n    }\n\n    // We have created the oob record with a message, that message should be provided here as well\n    if (!lastSentMessage) {\n      throw new CredoError('Must have lastSentMessage when out of band record has role Sender')\n    }\n  } else if (outOfBandRecord?.role === DidCommOutOfBandRole.Receiver) {\n    // Extract recipientService from the oob record if not on a previous message\n    if (!recipientService) {\n      recipientService = await outOfBandService.getResolvedServiceForOutOfBandServices(\n        agentContext,\n        outOfBandRecord.outOfBandInvitation.getServices()\n      )\n    }\n\n    if (lastSentMessage && !ourService) {\n      throw new CredoError(\n        'Could not find a service to send the message to. Please make sure the connection has a service or provide a service to send the message to.'\n      )\n    }\n\n    // We need to extract the kms key id for the connectinless exchange\n    const oobRecordRecipientRouting = outOfBandRecord?.metadata.get(DidCommOutOfBandRecordMetadataKeys.RecipientRouting)\n    if (oobRecordRecipientRouting && ourService) {\n      ourService.recipientKeys[0].keyId =\n        oobRecordRecipientRouting.recipientKeyId ?? ourService.recipientKeys[0].legacyKeyId\n    }\n  }\n  // we either miss ourService (even though a message was sent) or we miss recipientService\n  // we check in separate if statements to provide a more specific error message\n  else {\n    if (lastSentMessage && !ourService) {\n      agentContext.config.logger.error(\n        `No out of band record associated and missing our service for connection-less exchange for message ${message.id}, while previous message has already been sent.`\n      )\n      throw new CredoError(\n        `No out of band record associated and missing our service for connection-less exchange for message ${message.id}, while previous message has already been sent.`\n      )\n    }\n\n    if (!recipientService) {\n      agentContext.config.logger.error(\n        `No out of band record associated and missing recipient service for connection-less exchange for message ${message.id}.`\n      )\n      throw new CredoError(\n        `No out of band record associated and missing recipient service for connection-less exchange for message ${message.id}.`\n      )\n    }\n  }\n\n  return { ourService, recipientService }\n}\n\n/**\n * Creates a new service for us as the sender to be used in a connection-less exchange.\n *\n * Will creating routing, which takes into account mediators, and will optionally extract\n * routing configuration from the out of band record if available.\n */\nasync function createOurService(\n  agentContext: AgentContext,\n  { outOfBandRecord, message }: { outOfBandRecord?: DidCommOutOfBandRecord; message: DidCommMessage }\n): Promise<ResolvedDidCommService> {\n  agentContext.config.logger.debug(\n    `No previous sent message in thread for outbound message ${message.id} with type ${message.type}, setting up routing`\n  )\n\n  let routing: DidCommRouting | undefined\n\n  // Extract routing from out of band record if possible\n  const oobRecordRecipientRouting = outOfBandRecord?.metadata.get(DidCommOutOfBandRecordMetadataKeys.RecipientRouting)\n  if (oobRecordRecipientRouting) {\n    const recipientPublicJwk = Kms.PublicJwk.fromFingerprint(\n      oobRecordRecipientRouting.recipientKeyFingerprint\n    ) as Kms.PublicJwk<Kms.Ed25519PublicJwk>\n\n    recipientPublicJwk.keyId = oobRecordRecipientRouting.recipientKeyId ?? recipientPublicJwk.legacyKeyId\n    routing = {\n      recipientKey: recipientPublicJwk,\n      routingKeys: oobRecordRecipientRouting.routingKeyFingerprints.map(\n        (fingerprint) => Kms.PublicJwk.fromFingerprint(fingerprint) as Kms.PublicJwk<Kms.Ed25519PublicJwk>\n      ),\n      endpoints: oobRecordRecipientRouting.endpoints,\n      mediatorId: oobRecordRecipientRouting.mediatorId,\n    }\n  }\n\n  if (!routing) {\n    const routingService = agentContext.dependencyManager.resolve(DidCommRoutingService)\n    routing = await routingService.getRouting(agentContext, {\n      mediatorId: outOfBandRecord?.mediatorId,\n    })\n\n    // We need to store the routing so we can reference it in in the future.\n    if (outOfBandRecord) {\n      agentContext.config.logger.debug('Storing routing for out of band invitation.')\n      outOfBandRecord.metadata.set(DidCommOutOfBandRecordMetadataKeys.RecipientRouting, {\n        recipientKeyFingerprint: routing.recipientKey.fingerprint,\n        recipientKeyId: routing.recipientKey.keyId,\n        routingKeyFingerprints: routing.routingKeys.map((key) => key.fingerprint),\n        endpoints: routing.endpoints,\n        mediatorId: routing.mediatorId,\n      })\n      outOfBandRecord.setTags({ recipientRoutingKeyFingerprint: routing.recipientKey.fingerprint })\n      const outOfBandRepository = agentContext.resolve(DidCommOutOfBandRepository)\n      await outOfBandRepository.update(agentContext, outOfBandRecord)\n    }\n  }\n\n  return {\n    id: utils.uuid(),\n    serviceEndpoint: routing.endpoints[0],\n    recipientKeys: [routing.recipientKey],\n    routingKeys: routing.routingKeys,\n  }\n}\n\nasync function addExchangeDataToMessage(\n  agentContext: AgentContext,\n  {\n    message,\n    ourService,\n    outOfBandRecord,\n    associatedRecord,\n  }: {\n    message: DidCommMessage\n    ourService: ResolvedDidCommService\n    outOfBandRecord?: DidCommOutOfBandRecord\n    associatedRecord: BaseRecordAny\n  }\n) {\n  const legacyInvitationMetadata = outOfBandRecord?.metadata.get(DidCommOutOfBandRecordMetadataKeys.LegacyInvitation)\n\n  // Set the parentThreadId on the message from the oob invitation\n  // If connectionless is used, we should not add the parentThreadId\n  if (outOfBandRecord && legacyInvitationMetadata?.legacyInvitationType !== DidCommInvitationType.Connectionless) {\n    if (!message.thread) {\n      message.setThread({\n        parentThreadId: outOfBandRecord.outOfBandInvitation.id,\n      })\n    } else {\n      message.thread.parentThreadId = outOfBandRecord.outOfBandInvitation.id\n    }\n  }\n\n  // Set the service on the message and save service decorator to record (to remember our verkey)\n  // TODO: we should store this in the OOB record, but that would be a breaking change for now.\n  // We can change this in 0.5.0\n  message.service = ServiceDecorator.fromResolvedDidCommService(ourService)\n\n  await agentContext.dependencyManager.resolve(DidCommMessageRepository).saveOrUpdateAgentMessage(agentContext, {\n    agentMessage: message,\n    role: DidCommMessageRole.Sender,\n    associatedRecordId: associatedRecord.id,\n  })\n}\n"],"mappings":"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"}