{"version":3,"file":"SignatureDecoratorUtils.mjs","names":[],"sources":["../../../src/decorators/signature/SignatureDecoratorUtils.ts"],"sourcesContent":["import type { AgentContext } from '@credo-ts/core'\n\nimport { Buffer, CredoError, JsonEncoder, Kms, TypedArrayEncoder, utils } from '@credo-ts/core'\n\nimport { SignatureDecorator } from './SignatureDecorator'\n\n/**\n * Unpack and verify signed data before casting it to the supplied type.\n *\n * @param decorator Signature decorator to unpack and verify\n * @param wallet wallet instance\n *\n * @return Resulting data\n */\nexport async function unpackAndVerifySignatureDecorator(\n  agentContext: AgentContext,\n  decorator: SignatureDecorator\n): Promise<Record<string, unknown>> {\n  const signerVerkey = decorator.signer\n  const kms = agentContext.dependencyManager.resolve(Kms.KeyManagementApi)\n\n  const publicJwk = Kms.PublicJwk.fromPublicKey({\n    kty: 'OKP',\n    crv: 'Ed25519',\n    publicKey: TypedArrayEncoder.fromBase58(signerVerkey),\n  })\n\n  // first 8 bytes are for 64 bit integer from unix epoch\n  const signedData = TypedArrayEncoder.fromBase64(decorator.signatureData)\n  const signature = TypedArrayEncoder.fromBase64(decorator.signature)\n\n  const result = await kms.verify({\n    algorithm: 'EdDSA',\n    data: signedData,\n    key: {\n      publicJwk: publicJwk.toJson(),\n    },\n    signature,\n  })\n\n  if (!result.verified) {\n    throw new CredoError('Signature is not valid')\n  }\n\n  return JsonEncoder.fromBuffer(signedData.slice(8))\n}\n\n/**\n * Sign data supplied and return a signature decorator.\n *\n * @param data the data to sign\n * @param wallet the wallet containing a key to use for signing\n * @param signerKey signer key\n *\n * @returns Resulting signature decorator.\n */\nexport async function signData(\n  agentContext: AgentContext,\n  data: unknown,\n  signerKey: Kms.PublicJwk<Kms.Ed25519PublicJwk>\n): Promise<SignatureDecorator> {\n  const kms = agentContext.dependencyManager.resolve(Kms.KeyManagementApi)\n  const dataBuffer = Buffer.concat([utils.timestamp(), JsonEncoder.toBuffer(data)])\n\n  const result = await kms.sign({ data: dataBuffer, algorithm: 'EdDSA', keyId: signerKey.keyId })\n\n  const signatureDecorator = new SignatureDecorator({\n    signatureType: 'https://didcomm.org/signature/1.0/ed25519Sha512_single',\n    signature: TypedArrayEncoder.toBase64URL(result.signature),\n    signatureData: TypedArrayEncoder.toBase64URL(dataBuffer),\n    signer: TypedArrayEncoder.toBase58(signerKey.publicKey.publicKey),\n  })\n\n  return signatureDecorator\n}\n"],"mappings":";;;;;;;;;;;;AAcA,eAAsB,kCACpB,cACA,WACkC;CAClC,MAAM,eAAe,UAAU;CAC/B,MAAM,MAAM,aAAa,kBAAkB,QAAQ,IAAI,iBAAiB;CAExE,MAAM,YAAY,IAAI,UAAU,cAAc;EAC5C,KAAK;EACL,KAAK;EACL,WAAW,kBAAkB,WAAW,aAAa;EACtD,CAAC;CAGF,MAAM,aAAa,kBAAkB,WAAW,UAAU,cAAc;CACxE,MAAM,YAAY,kBAAkB,WAAW,UAAU,UAAU;AAWnE,KAAI,EATW,MAAM,IAAI,OAAO;EAC9B,WAAW;EACX,MAAM;EACN,KAAK,EACH,WAAW,UAAU,QAAQ,EAC9B;EACD;EACD,CAAC,EAEU,SACV,OAAM,IAAI,WAAW,yBAAyB;AAGhD,QAAO,YAAY,WAAW,WAAW,MAAM,EAAE,CAAC;;;;;;;;;;;AAYpD,eAAsB,SACpB,cACA,MACA,WAC6B;CAC7B,MAAM,MAAM,aAAa,kBAAkB,QAAQ,IAAI,iBAAiB;CACxE,MAAM,aAAa,OAAO,OAAO,CAAC,MAAM,WAAW,EAAE,YAAY,SAAS,KAAK,CAAC,CAAC;CAEjF,MAAM,SAAS,MAAM,IAAI,KAAK;EAAE,MAAM;EAAY,WAAW;EAAS,OAAO,UAAU;EAAO,CAAC;AAS/F,QAP2B,IAAI,mBAAmB;EAChD,eAAe;EACf,WAAW,kBAAkB,YAAY,OAAO,UAAU;EAC1D,eAAe,kBAAkB,YAAY,WAAW;EACxD,QAAQ,kBAAkB,SAAS,UAAU,UAAU,UAAU;EAClE,CAAC"}