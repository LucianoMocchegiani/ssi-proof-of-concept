{"version":3,"file":"TimingDecorator.mjs","names":[],"sources":["../../../src/decorators/timing/TimingDecorator.ts"],"sourcesContent":["import { Expose, Type } from 'class-transformer'\nimport { IsDate, IsNumber, IsOptional } from 'class-validator'\n\n/**\n * Represents `~timing` decorator\n * @see https://github.com/hyperledger/aries-rfcs/blob/master/features/0032-message-timing/README.md\n */\nexport class TimingDecorator {\n  public constructor(partial?: Partial<TimingDecorator>) {\n    this.inTime = partial?.inTime\n    this.outTime = partial?.outTime\n    this.staleTime = partial?.staleTime\n    this.expiresTime = partial?.expiresTime\n    this.delayMilli = partial?.delayMilli\n    this.waitUntilTime = partial?.waitUntilTime\n  }\n\n  /**\n   * The timestamp when the preceding message in this thread (the one that elicited this message as a response) was received.\n   * Or, on a dynamically composed forward message, the timestamp when an upstream relay first received the message it's now asking to be forwarded.\n   */\n  @Expose({ name: 'in_time' })\n  @Type(() => Date)\n  @IsDate()\n  @IsOptional()\n  public inTime?: Date\n\n  /**\n   * The timestamp when the message was emitted. At least millisecond precision is preferred, though second precision is acceptable.\n   */\n  @Expose({ name: 'out_time' })\n  @Type(() => Date)\n  @IsDate()\n  @IsOptional()\n  public outTime?: Date\n\n  /**\n   * Ideally, the decorated message should be processed by the the specified timestamp. After that, the message may become irrelevant or less meaningful than intended.\n   * This is a hint only.\n   */\n  @Expose({ name: 'stale_time' })\n  @Type(() => Date)\n  @IsDate()\n  @IsOptional()\n  public staleTime?: Date\n\n  /**\n   * The decorated message should be considered invalid or expired if encountered after the specified timestamp.\n   * This is a much stronger claim than the one for `stale_time`; it says that the receiver should cancel attempts to process it once the deadline is past,\n   * because the sender won't stand behind it any longer. While processing of the received message should stop,\n   * the thread of the message should be retained as the sender may send an updated/replacement message.\n   * In the case that the sender does not follow up, the policy of the receiver agent related to abandoned threads would presumably be used to eventually delete the thread.\n   */\n  @Expose({ name: 'expires_time' })\n  @Type(() => Date)\n  @IsDate()\n  @IsOptional()\n  public expiresTime?: Date\n\n  /**\n   * Wait at least this many milliseconds before processing the message. This may be useful to defeat temporal correlation.\n   * It is recommended that agents supporting this field should not honor requests for delays longer than 10 minutes (600,000 milliseconds).\n   */\n  @Expose({ name: 'delay_milli' })\n  @IsNumber()\n  @IsOptional()\n  public delayMilli?: number\n\n  /**\n   * Wait until this time before processing the message.\n   */\n  @Expose({ name: 'wait_until_time' })\n  @Type(() => Date)\n  @IsDate()\n  @IsOptional()\n  public waitUntilTime?: Date\n}\n"],"mappings":";;;;;;;;;;;AAOA,IAAa,kBAAb,MAA6B;CAC3B,AAAO,YAAY,SAAoC;AACrD,OAAK,SAAS,SAAS;AACvB,OAAK,UAAU,SAAS;AACxB,OAAK,YAAY,SAAS;AAC1B,OAAK,cAAc,SAAS;AAC5B,OAAK,aAAa,SAAS;AAC3B,OAAK,gBAAgB,SAAS;;;;CAO/B,OAAO,EAAE,MAAM,WAAW,CAAC;CAC3B,WAAW,KAAK;CAChB,QAAQ;CACR,YAAY;;;;CAMZ,OAAO,EAAE,MAAM,YAAY,CAAC;CAC5B,WAAW,KAAK;CAChB,QAAQ;CACR,YAAY;;;;CAOZ,OAAO,EAAE,MAAM,cAAc,CAAC;CAC9B,WAAW,KAAK;CAChB,QAAQ;CACR,YAAY;;;;CAUZ,OAAO,EAAE,MAAM,gBAAgB,CAAC;CAChC,WAAW,KAAK;CAChB,QAAQ;CACR,YAAY;;;;CAOZ,OAAO,EAAE,MAAM,eAAe,CAAC;CAC/B,UAAU;CACV,YAAY;;;;CAMZ,OAAO,EAAE,MAAM,mBAAmB,CAAC;CACnC,WAAW,KAAK;CAChB,QAAQ;CACR,YAAY"}