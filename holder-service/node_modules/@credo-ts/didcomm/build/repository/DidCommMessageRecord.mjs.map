{"version":3,"file":"DidCommMessageRecord.mjs","names":[],"sources":["../../src/repository/DidCommMessageRecord.ts"],"sourcesContent":["import { BaseRecord, CredoError, isJsonObject, JsonTransformer, utils } from '@credo-ts/core'\nimport type { ConstructableAgentMessage } from '../DidCommMessage'\nimport type { DidCommPlaintextMessage } from '../types'\nimport { canHandleMessageType, parseMessageType } from '../util/messageType'\nimport type { DidCommMessageRole } from './DidCommMessageRole'\n\nexport type DefaultDidCommMessageTags = {\n  role: DidCommMessageRole\n  associatedRecordId?: string\n\n  // Computed\n  protocolName: string\n  messageName: string\n  protocolMajorVersion: string\n  protocolMinorVersion: string\n  messageType: string\n  messageId: string\n  threadId: string\n}\n\nexport interface DidCommMessageRecordProps {\n  role: DidCommMessageRole\n  message: DidCommPlaintextMessage\n  id?: string\n  createdAt?: Date\n  associatedRecordId?: string\n}\n\nexport class DidCommMessageRecord extends BaseRecord<DefaultDidCommMessageTags> {\n  public message!: DidCommPlaintextMessage\n  public role!: DidCommMessageRole\n\n  /**\n   * The id of the record that is associated with this message record.\n   *\n   * E.g. if the connection record wants to store an invitation message\n   * the associatedRecordId will be the id of the connection record.\n   */\n  public associatedRecordId?: string\n\n  public static readonly type = 'DidCommMessageRecord'\n  public readonly type = DidCommMessageRecord.type\n\n  public constructor(props: DidCommMessageRecordProps) {\n    super()\n\n    if (props) {\n      this.id = props.id ?? utils.uuid()\n      this.createdAt = props.createdAt ?? new Date()\n      this.associatedRecordId = props.associatedRecordId\n      this.role = props.role\n      this.message = props.message\n    }\n  }\n\n  public getTags() {\n    const messageId = this.message['@id'] as string\n    const messageType = this.message['@type'] as string\n\n    const { protocolName, protocolMajorVersion, protocolMinorVersion, messageName } = parseMessageType(messageType)\n\n    const thread = this.message['~thread']\n    let threadId = messageId\n\n    if (isJsonObject(thread) && typeof thread.thid === 'string') {\n      threadId = thread.thid\n    }\n\n    return {\n      ...this._tags,\n      role: this.role,\n      associatedRecordId: this.associatedRecordId,\n\n      // Computed properties based on message id and type\n      threadId,\n      protocolName,\n      messageName,\n      protocolMajorVersion: protocolMajorVersion.toString(),\n      protocolMinorVersion: protocolMinorVersion.toString(),\n      messageType,\n      messageId,\n    }\n  }\n\n  public getMessageInstance<MessageClass extends ConstructableAgentMessage = ConstructableAgentMessage>(\n    messageClass: MessageClass\n  ): InstanceType<MessageClass> {\n    const messageType = parseMessageType(this.message['@type'] as string)\n\n    if (!canHandleMessageType(messageClass, messageType)) {\n      throw new CredoError('Provided message class type does not match type of stored message')\n    }\n\n    return JsonTransformer.fromJSON(this.message, messageClass) as InstanceType<MessageClass>\n  }\n}\n"],"mappings":";;;;AA4BA,IAAa,uBAAb,MAAa,6BAA6B,WAAsC;CAe9E,AAAO,YAAY,OAAkC;AACnD,SAAO;OAHO,OAAO,qBAAqB;AAK1C,MAAI,OAAO;AACT,QAAK,KAAK,MAAM,MAAM,MAAM,MAAM;AAClC,QAAK,YAAY,MAAM,6BAAa,IAAI,MAAM;AAC9C,QAAK,qBAAqB,MAAM;AAChC,QAAK,OAAO,MAAM;AAClB,QAAK,UAAU,MAAM;;;CAIzB,AAAO,UAAU;EACf,MAAM,YAAY,KAAK,QAAQ;EAC/B,MAAM,cAAc,KAAK,QAAQ;EAEjC,MAAM,EAAE,cAAc,sBAAsB,sBAAsB,gBAAgB,iBAAiB,YAAY;EAE/G,MAAM,SAAS,KAAK,QAAQ;EAC5B,IAAI,WAAW;AAEf,MAAI,aAAa,OAAO,IAAI,OAAO,OAAO,SAAS,SACjD,YAAW,OAAO;AAGpB,SAAO;GACL,GAAG,KAAK;GACR,MAAM,KAAK;GACX,oBAAoB,KAAK;GAGzB;GACA;GACA;GACA,sBAAsB,qBAAqB,UAAU;GACrD,sBAAsB,qBAAqB,UAAU;GACrD;GACA;GACD;;CAGH,AAAO,mBACL,cAC4B;AAG5B,MAAI,CAAC,qBAAqB,cAFN,iBAAiB,KAAK,QAAQ,SAAmB,CAEjB,CAClD,OAAM,IAAI,WAAW,oEAAoE;AAG3F,SAAO,gBAAgB,SAAS,KAAK,SAAS,aAAa;;;qBArDtC,OAAO"}