import { canHandleMessageType, parseMessageType } from "../util/messageType.mjs";
import { BaseRecord, CredoError, JsonTransformer, isJsonObject, utils } from "@credo-ts/core";

//#region src/repository/DidCommMessageRecord.ts
var DidCommMessageRecord = class DidCommMessageRecord extends BaseRecord {
	constructor(props) {
		super();
		this.type = DidCommMessageRecord.type;
		if (props) {
			this.id = props.id ?? utils.uuid();
			this.createdAt = props.createdAt ?? /* @__PURE__ */ new Date();
			this.associatedRecordId = props.associatedRecordId;
			this.role = props.role;
			this.message = props.message;
		}
	}
	getTags() {
		const messageId = this.message["@id"];
		const messageType = this.message["@type"];
		const { protocolName, protocolMajorVersion, protocolMinorVersion, messageName } = parseMessageType(messageType);
		const thread = this.message["~thread"];
		let threadId = messageId;
		if (isJsonObject(thread) && typeof thread.thid === "string") threadId = thread.thid;
		return {
			...this._tags,
			role: this.role,
			associatedRecordId: this.associatedRecordId,
			threadId,
			protocolName,
			messageName,
			protocolMajorVersion: protocolMajorVersion.toString(),
			protocolMinorVersion: protocolMinorVersion.toString(),
			messageType,
			messageId
		};
	}
	getMessageInstance(messageClass) {
		if (!canHandleMessageType(messageClass, parseMessageType(this.message["@type"]))) throw new CredoError("Provided message class type does not match type of stored message");
		return JsonTransformer.fromJSON(this.message, messageClass);
	}
};
DidCommMessageRecord.type = "DidCommMessageRecord";

//#endregion
export { DidCommMessageRecord };
//# sourceMappingURL=DidCommMessageRecord.mjs.map