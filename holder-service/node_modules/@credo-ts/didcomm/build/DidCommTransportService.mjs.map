{"version":3,"file":"DidCommTransportService.mjs","names":[],"sources":["../src/DidCommTransportService.ts"],"sourcesContent":["import type { DidDocument } from '@credo-ts/core'\nimport { AgentContext, CredoError, EventEmitter, injectable } from '@credo-ts/core'\nimport { DID_COMM_TRANSPORT_QUEUE } from './constants'\nimport type { EnvelopeKeys } from './DidCommEnvelopeService'\nimport type { DidCommMessage } from './DidCommMessage'\nimport type { DidCommTransportSessionRemovedEvent, DidCommTransportSessionSavedEvent } from './transport'\nimport { DidCommTransportEventTypes } from './transport'\nimport type { DidCommEncryptedMessage } from './types'\n\n@injectable()\nexport class DidCommTransportService {\n  public transportSessionTable: TransportSessionTable = {}\n  private agentContext: AgentContext\n  private eventEmitter: EventEmitter\n\n  public constructor(agentContext: AgentContext, eventEmitter: EventEmitter) {\n    this.agentContext = agentContext\n    this.eventEmitter = eventEmitter\n  }\n\n  public saveSession(session: DidCommTransportSession) {\n    if (session.connectionId) {\n      const oldSessions = this.getExistingSessionsForConnectionIdAndType(session.connectionId, session.type)\n      for (const oldSession of oldSessions) {\n        if (oldSession && oldSession.id !== session.id) {\n          this.removeSession(oldSession)\n        }\n      }\n    }\n    this.transportSessionTable[session.id] = session\n\n    this.eventEmitter.emit<DidCommTransportSessionSavedEvent>(this.agentContext, {\n      type: DidCommTransportEventTypes.DidCommTransportSessionSaved,\n      payload: {\n        session,\n      },\n    })\n  }\n\n  public findSessionByConnectionId(connectionId: string) {\n    return Object.values(this.transportSessionTable).find((session) => session?.connectionId === connectionId)\n  }\n\n  public setConnectionIdForSession(sessionId: string, connectionId: string) {\n    const session = this.findSessionById(sessionId)\n    if (!session) {\n      throw new CredoError(`Session not found with id ${sessionId}`)\n    }\n    session.connectionId = connectionId\n    this.saveSession(session)\n  }\n\n  public hasInboundEndpoint(didDocument: DidDocument): boolean {\n    return Boolean(didDocument.didCommServices?.find((s) => s.serviceEndpoint !== DID_COMM_TRANSPORT_QUEUE))\n  }\n\n  public findSessionById(sessionId: string) {\n    return this.transportSessionTable[sessionId]\n  }\n\n  public removeSession(session: DidCommTransportSession) {\n    delete this.transportSessionTable[session.id]\n    this.eventEmitter.emit<DidCommTransportSessionRemovedEvent>(this.agentContext, {\n      type: DidCommTransportEventTypes.DidCommTransportSessionRemoved,\n      payload: {\n        session,\n      },\n    })\n  }\n\n  private getExistingSessionsForConnectionIdAndType(connectionId: string, type: string) {\n    return Object.values(this.transportSessionTable).filter(\n      (session) => session?.connectionId === connectionId && session.type === type\n    )\n  }\n}\n\ninterface TransportSessionTable {\n  [sessionId: string]: DidCommTransportSession | undefined\n}\n\n// In the framework Transport sessions are used for communication. A session is\n// associated with a connection and it can be reused when we want to respond to\n// a message. If the message, for example, does not contain any way to reply to\n// this message, the session should be closed. When a new sequence of messages\n// starts it can be used again. A session will be deleted when a WebSocket\n// closes, for the WsTransportSession that is.\nexport interface DidCommTransportSession {\n  // unique identifier for a transport session. This can a uuid, or anything else, as long\n  // as it uniquely identifies a transport.\n  id: string\n\n  // The type is something that explicitly defines the transport type. For WebSocket it would\n  // be \"WebSocket\" and for HTTP it would be \"HTTP\".\n  type: string\n\n  // The enveloping keys that can be used during the transport. This is used so the framework\n  // does not have to look up the associated keys for sending a message.\n  keys?: EnvelopeKeys\n\n  // A received message that will be used to check whether it has any return routing.\n  inboundMessage?: DidCommMessage\n\n  // A stored connection id used to find this session via the `DidCommTransportService` for a specific connection\n  connectionId?: string\n\n  // Send an encrypted message\n  send(agentContext: AgentContext, encryptedMessage: DidCommEncryptedMessage): Promise<void>\n\n  // Close the session to prevent dangling sessions.\n  close(): Promise<void>\n}\n"],"mappings":";;;;;;;;;AAUO,oCAAM,wBAAwB;CAKnC,AAAO,YAAY,cAA4B,cAA4B;OAJpE,wBAA+C,EAAE;AAKtD,OAAK,eAAe;AACpB,OAAK,eAAe;;CAGtB,AAAO,YAAY,SAAkC;AACnD,MAAI,QAAQ,cAAc;GACxB,MAAM,cAAc,KAAK,0CAA0C,QAAQ,cAAc,QAAQ,KAAK;AACtG,QAAK,MAAM,cAAc,YACvB,KAAI,cAAc,WAAW,OAAO,QAAQ,GAC1C,MAAK,cAAc,WAAW;;AAIpC,OAAK,sBAAsB,QAAQ,MAAM;AAEzC,OAAK,aAAa,KAAwC,KAAK,cAAc;GAC3E,MAAM,2BAA2B;GACjC,SAAS,EACP,SACD;GACF,CAAC;;CAGJ,AAAO,0BAA0B,cAAsB;AACrD,SAAO,OAAO,OAAO,KAAK,sBAAsB,CAAC,MAAM,YAAY,SAAS,iBAAiB,aAAa;;CAG5G,AAAO,0BAA0B,WAAmB,cAAsB;EACxE,MAAM,UAAU,KAAK,gBAAgB,UAAU;AAC/C,MAAI,CAAC,QACH,OAAM,IAAI,WAAW,6BAA6B,YAAY;AAEhE,UAAQ,eAAe;AACvB,OAAK,YAAY,QAAQ;;CAG3B,AAAO,mBAAmB,aAAmC;AAC3D,SAAO,QAAQ,YAAY,iBAAiB,MAAM,MAAM,EAAE,oBAAoB,yBAAyB,CAAC;;CAG1G,AAAO,gBAAgB,WAAmB;AACxC,SAAO,KAAK,sBAAsB;;CAGpC,AAAO,cAAc,SAAkC;AACrD,SAAO,KAAK,sBAAsB,QAAQ;AAC1C,OAAK,aAAa,KAA0C,KAAK,cAAc;GAC7E,MAAM,2BAA2B;GACjC,SAAS,EACP,SACD;GACF,CAAC;;CAGJ,AAAQ,0CAA0C,cAAsB,MAAc;AACpF,SAAO,OAAO,OAAO,KAAK,sBAAsB,CAAC,QAC9C,YAAY,SAAS,iBAAiB,gBAAgB,QAAQ,SAAS,KACzE;;;sCAhEJ,YAAY"}