import { DidDoc } from "../../modules/connections/models/did/DidDoc.mjs";
import { DidCommConnectionRole } from "../../modules/connections/models/DidCommConnectionRole.mjs";
import { DidCommDidExchangeState } from "../../modules/connections/models/DidCommDidExchangeState.mjs";
import { DidCommConnectionState } from "../../modules/connections/models/DidCommConnectionState.mjs";
import { DidCommDidExchangeRole } from "../../modules/connections/models/DidCommDidExchangeRole.mjs";
import { convertToNewDidDocument } from "../../modules/connections/services/helpers.mjs";
import { DidCommOutOfBandRole } from "../../modules/oob/domain/DidCommOutOfBandRole.mjs";
import { outOfBandServiceToInlineKeysNumAlgo2Did } from "../../modules/oob/helpers.mjs";
import { DidCommOutOfBandRecord } from "../../modules/oob/repository/DidCommOutOfBandRecord.mjs";
import { DidCommOutOfBandRepository } from "../../modules/oob/repository/DidCommOutOfBandRepository.mjs";
import { DidCommOutOfBandState } from "../../modules/oob/domain/DidCommOutOfBandState.mjs";
import "../../modules/oob/repository/index.mjs";
import { DidCommConnectionInvitationMessage } from "../../modules/connections/messages/DidCommConnectionInvitationMessage.mjs";
import { DidCommConnectionRepository } from "../../modules/connections/repository/DidCommConnectionRepository.mjs";
import "../../modules/connections/index.mjs";
import { convertToNewInvitation } from "../../modules/oob/converters.mjs";
import { DidDocumentRole, DidKey, DidRecord, DidRecordMetadataKeys, DidRepository, JsonEncoder, JsonTransformer } from "@credo-ts/core";

//#region src/updates/0.1-0.2/connection.ts
/**
* Migrates the {@link DidCommConnectionRecord} to 0.2 compatible format. It fetches all records from storage
* and applies the needed updates to the records. After a record has been transformed, it is updated
* in storage and the next record will be transformed.
*
* The following transformations are applied:
*  - {@link updateConnectionRoleAndState}
*  - {@link extractDidDocument}
*  - {@link migrateToOobRecord}
*/
async function migrateConnectionRecordToV0_2(agent) {
	agent.config.logger.info("Migrating connection records to storage version 0.2");
	const connectionRepository = agent.dependencyManager.resolve(DidCommConnectionRepository);
	agent.config.logger.debug("Fetching all connection records from storage");
	const allConnections = await connectionRepository.getAll(agent.context);
	agent.config.logger.debug(`Found a total of ${allConnections.length} connection records to update.`);
	for (const connectionRecord of allConnections) {
		agent.config.logger.debug(`Migrating connection record with id ${connectionRecord.id} to storage version 0.2`);
		await updateConnectionRoleAndState(agent, connectionRecord);
		await extractDidDocument(agent, connectionRecord);
		if (await migrateToOobRecord(agent, connectionRecord)) await connectionRepository.update(agent.context, connectionRecord);
		agent.config.logger.debug(`Successfully migrated connection record with id ${connectionRecord.id} to storage version 0.2`);
	}
}
/**
* With the addition of the did exchange protocol there are now two states and roles related to the connection record; for the did exchange protocol and for the connection protocol.
* To keep it easy to work with the connection record, all state and role values are updated to those of the {@link DidCommDidExchangeRole} and {@link DidCommDidExchangeState}.
*
* This migration method transforms all connection record state and role values to their respective values of the {@link DidCommDidExchangeRole} and {@link DidCommDidExchangeState}. For convenience a getter
* property `rfc0160ConnectionState` is added to the connection record which returns the {@link DidCommConnectionState} value.
*
* The following 0.1.0 connection record structure (unrelated keys omitted):
*
* ```json
* {
*   "state": "invited",
*   "role": "inviter"
* }
* ```
*
* Will be transformed into the following 0.2.0 structure (unrelated keys omitted):
*
* ```json
* {
*   "state": "invitation-sent",
*   "role": "responder",
* }
* ```
*/
async function updateConnectionRoleAndState(agent, connectionRecord) {
	agent.config.logger.debug(`Extracting 'didDoc' and 'theirDidDoc' from connection record into separate DidRecord and updating unqualified dids to did:peer dids`);
	const oldState = connectionRecord.state;
	const oldRole = connectionRecord.role;
	const [didExchangeRole, didExchangeState] = didExchangeStateAndRoleFromRoleAndState(connectionRecord.role, connectionRecord.state);
	connectionRecord.role = didExchangeRole;
	connectionRecord.state = didExchangeState;
	agent.config.logger.debug(`Updated connection record state from ${oldState} to ${connectionRecord.state} and role from ${oldRole} to ${connectionRecord.role}`);
}
/**
* The connection record previously stored both did documents from a connection in the connection record itself. Version 0.2.0 added a generic did storage that can be used for numerous usages, one of which
* is the storage of did documents for connection records.
*
* This migration method extracts the did documents from the `didDoc` and `theirDidDoc` properties from the connection record, updates them to did documents compliant with the DID Core spec, and stores them
* in the did repository. By doing so it also updates the unqualified dids in the `did` and `theirDid` fields generated by the indy-sdk to fully qualified `did:peer` dids compliant with
* the [Peer DID Method Specification](https://identity.foundation/peer-did-method-spec/).
*
* To account for the fact that the mechanism to migrate legacy did document to peer did documents is not defined yet, the legacy did and did document are stored in the did record metadata.
* This will be deleted later if we can be certain the did doc conversion to a did:peer did document is correct.
*
* The following 0.1.0 connection record structure (unrelated keys omitted):
*
* ```json
* {
*   "did": "BBPoJqRKatdcfLEAFL7exC",
*   "theirDid": "N8NQHLtCKfPmWMgCSdfa7h",
*   "didDoc": <legacyDidDoc>,
*   "theirDidDoc": <legacyTheirDidDoc>,
*   "verkey": "GjZWsBLgZCR18aL468JAT7w9CZRiBnpxUPPgyQxh4voa"
* }
* ```
*
* Will be transformed into the following 0.2.0 structure (unrelated keys omitted):
*
* ```json
* {
*   "did": "did:peer:1zQmXUaPPhPCbUVZ3hGYmQmGxWTwyDfhqESXCpMFhKaF9Y2A",
*   "theirDid": "did:peer:1zQmZMygzYqNwU6Uhmewx5Xepf2VLp5S4HLSwwgf2aiKZuwa"
* }
* ```
*/
async function extractDidDocument(agent, connectionRecord) {
	agent.config.logger.debug(`Extracting 'didDoc' and 'theirDidDoc' from connection record into separate DidRecord and updating unqualified dids to did:peer dids`);
	const didRepository = agent.dependencyManager.resolve(DidRepository);
	const untypedConnectionRecord = connectionRecord;
	const oldOurDidDocJson = untypedConnectionRecord.didDoc;
	const oldTheirDidDocJson = untypedConnectionRecord.theirDidDoc;
	if (oldOurDidDocJson) {
		const oldOurDidDoc = JsonTransformer.fromJSON(oldOurDidDocJson, DidDoc);
		agent.config.logger.debug(`Found a legacy did document for did ${oldOurDidDoc.id} in connection record didDoc. Converting it to a peer did document.`);
		const { didDocument: newOurDidDocument } = convertToNewDidDocument(oldOurDidDoc);
		let ourDidRecord = await didRepository.findById(agent.context, newOurDidDocument.id);
		if (!ourDidRecord) {
			agent.config.logger.debug(`Creating did record for our did ${newOurDidDocument.id}`);
			ourDidRecord = new DidRecord({
				id: newOurDidDocument.id,
				did: newOurDidDocument.id,
				role: DidDocumentRole.Created,
				didDocument: newOurDidDocument,
				createdAt: connectionRecord.createdAt
			});
			ourDidRecord.metadata.set(DidRecordMetadataKeys.LegacyDid, {
				unqualifiedDid: oldOurDidDoc.id,
				didDocumentString: JsonEncoder.toString(oldOurDidDocJson)
			});
			await didRepository.save(agent.context, ourDidRecord);
			agent.config.logger.debug(`Successfully saved did record for did ${newOurDidDocument.id}`);
		} else agent.config.logger.debug(`Found existing did record for did ${newOurDidDocument.id}, not creating did record.`);
		agent.config.logger.debug("Deleting old did document from connection record and storing new did:peer did");
		delete untypedConnectionRecord.didDoc;
		connectionRecord.did = newOurDidDocument.id;
	} else agent.config.logger.debug("Did not find a did document in connection record didDoc. Not converting it to a peer did document.");
	if (oldTheirDidDocJson) {
		const oldTheirDidDoc = JsonTransformer.fromJSON(oldTheirDidDocJson, DidDoc);
		agent.config.logger.debug(`Found a legacy did document for theirDid ${oldTheirDidDoc.id} in connection record theirDidDoc. Converting it to a peer did document.`);
		const { didDocument: newTheirDidDocument } = convertToNewDidDocument(oldTheirDidDoc);
		let theirDidRecord = await didRepository.findById(agent.context, newTheirDidDocument.id);
		if (!theirDidRecord) {
			agent.config.logger.debug(`Creating did record for theirDid ${newTheirDidDocument.id}`);
			theirDidRecord = new DidRecord({
				id: newTheirDidDocument.id,
				did: newTheirDidDocument.id,
				role: DidDocumentRole.Received,
				didDocument: newTheirDidDocument,
				createdAt: connectionRecord.createdAt
			});
			theirDidRecord.metadata.set(DidRecordMetadataKeys.LegacyDid, {
				unqualifiedDid: oldTheirDidDoc.id,
				didDocumentString: JsonEncoder.toString(oldTheirDidDocJson)
			});
			await didRepository.save(agent.context, theirDidRecord);
			agent.config.logger.debug(`Successfully saved did record for theirDid ${newTheirDidDocument.id}`);
		} else agent.config.logger.debug(`Found existing did record for theirDid ${newTheirDidDocument.id}, not creating did record.`);
		agent.config.logger.debug("Deleting old theirDidDoc from connection record and storing new did:peer theirDid");
		delete untypedConnectionRecord.theirDidDoc;
		connectionRecord.theirDid = newTheirDidDocument.id;
	} else agent.config.logger.debug("Did not find a did document in connection record theirDidDoc. Not converting it to a peer did document.");
	delete untypedConnectionRecord.verkey;
}
/**
* With the addition of the out of band protocol, invitations are now stored in the {@link DidCommOutOfBandRecord}. In addition a new field `invitationDid` is added to the connection record that
* is generated based on the invitation service or did. This allows to reuse existing connections.
*
* This migration method extracts the invitation and other relevant data into a separate {@link DidCommOutOfBandRecord}. By doing so it converts the old connection protocol invitation into the new
* Out of band invitation message. Based on the service or did of the invitation, the `invitationDid` is populated.
*
* Previously when creating a multi use invitation, a connection record would be created with the `multiUseInvitation` set to true. The connection record would always be in state `invited`.
* If a request for the multi use invitation came in, a new connection record would be created. With the addition of the out of band module, no connection records are created until a request
* is received. So for multi use invitation this means that the connection record with multiUseInvitation=true will be deleted, and instead all connections created using that out of band invitation
* will contain the `outOfBandId` of the multi use invitation.
*
* The following 0.1.0 connection record structure (unrelated keys omitted):
*
* ```json
* {
*   "invitation": {
*     "@type": "https://didcomm.org/connections/1.0/invitation",
*     "@id": "04a2c382-999e-4de9-a1d2-9dec0b2fa5e4",
*     "recipientKeys": ["E6D1m3eERqCueX4ZgMCY14B4NceAr6XP2HyVqt55gDhu"],
*     "serviceEndpoint": "https://example.com",
*     "label": "test",
*   },
*   "multiUseInvitation": false
* }
* ```
*
* Will be transformed into the following 0.2.0 structure (unrelated keys omitted):
*
* ```json
* {
*   "invitationDid": "did:peer:2.Ez6MksYU4MHtfmNhNm1uGMvANr9j4CBv2FymjiJtRgA36bSVH.SeyJzIjoiaHR0cHM6Ly9leGFtcGxlLmNvbSJ9",
*   "outOfBandId": "04a2c382-999e-4de9-a1d2-9dec0b2fa5e4"
* }
* ```
*/
async function migrateToOobRecord(agent, connectionRecord) {
	agent.config.logger.debug(`Migrating properties from connection record with id ${connectionRecord.id} to out of band record`);
	const oobRepository = agent.dependencyManager.resolve(DidCommOutOfBandRepository);
	const connectionRepository = agent.dependencyManager.resolve(DidCommConnectionRepository);
	const untypedConnectionRecord = connectionRecord;
	const oldInvitationJson = untypedConnectionRecord.invitation;
	const oldMultiUseInvitation = untypedConnectionRecord.multiUseInvitation;
	if (oldInvitationJson) {
		const oldInvitation = JsonTransformer.fromJSON(oldInvitationJson, DidCommConnectionInvitationMessage);
		agent.config.logger.debug("Found a legacy invitation in connection record. Migrating it to an out of band record.");
		const outOfBandInvitation = convertToNewInvitation(oldInvitation);
		const recipientKeyFingerprints = outOfBandInvitation.getInlineServices().map((s) => s.recipientKeys).reduce((acc, curr) => [...acc, ...curr], []).map((didKey) => DidKey.fromDid(didKey).publicJwk.fingerprint);
		const oobRole = connectionRecord.role === DidCommDidExchangeRole.Responder ? DidCommOutOfBandRole.Sender : DidCommOutOfBandRole.Receiver;
		let oobRecord = (await oobRepository.findByQuery(agent.context, {
			invitationId: oldInvitation.id,
			recipientKeyFingerprints,
			role: oobRole
		}))[0];
		if (!oobRecord) {
			agent.config.logger.debug("Create out of band record.");
			const connectionRole = connectionRecord.role;
			const connectionState = connectionRecord.state;
			oobRecord = new DidCommOutOfBandRecord({
				role: oobRole,
				state: oobStateFromDidExchangeRoleAndState(connectionRole, connectionState),
				alias: connectionRecord.alias,
				autoAcceptConnection: connectionRecord.autoAcceptConnection,
				outOfBandInvitation,
				reusable: oldMultiUseInvitation,
				mediatorId: connectionRecord.mediatorId,
				createdAt: connectionRecord.createdAt,
				tags: { recipientKeyFingerprints }
			});
			await oobRepository.save(agent.context, oobRecord);
			agent.config.logger.debug(`Successfully saved out of band record for invitation @id ${oldInvitation.id}`);
		} else agent.config.logger.debug(`Found existing out of band record for invitation @id ${oldInvitation.id} and did ${connectionRecord.did}, not creating a new out of band record.`);
		if (oldMultiUseInvitation) {
			oobRecord.reusable = true;
			oobRecord.state = DidCommOutOfBandState.AwaitResponse;
			oobRecord.mediatorId = connectionRecord.mediatorId;
			oobRecord.autoAcceptConnection = connectionRecord.autoAcceptConnection;
			await oobRepository.update(agent.context, oobRecord);
			await connectionRepository.delete(agent.context, connectionRecord);
			agent.config.logger.debug(`Set reusable=true for out of band record with invitation @id ${oobRecord.outOfBandInvitation.id} and role ${oobRole}.`);
			return;
		}
		agent.config.logger.debug("Setting invitationDid and outOfBand Id, and removing invitation from connection record");
		const [invitationDid] = [...oobRecord.outOfBandInvitation.getDidServices(), ...oobRecord.outOfBandInvitation.getInlineServices().map(outOfBandServiceToInlineKeysNumAlgo2Did)];
		connectionRecord.invitationDid = invitationDid;
		delete untypedConnectionRecord.invitation;
		connectionRecord.outOfBandId = oobRecord.id;
	}
	agent.config.logger.debug("Removing multiUseInvitation property from connection record");
	delete untypedConnectionRecord.multiUseInvitation;
	return connectionRecord;
}
/**
* Determine the out of band state based on the did exchange role and state.
*/
function oobStateFromDidExchangeRoleAndState(role, state) {
	const stateMapping = {
		[DidCommDidExchangeState.InvitationReceived]: DidCommOutOfBandState.PrepareResponse,
		[DidCommDidExchangeState.InvitationSent]: DidCommOutOfBandState.AwaitResponse,
		[DidCommDidExchangeState.RequestReceived]: DidCommOutOfBandState.Done,
		[DidCommDidExchangeState.RequestSent]: DidCommOutOfBandState.Done,
		[DidCommDidExchangeState.ResponseReceived]: DidCommOutOfBandState.Done,
		[DidCommDidExchangeState.ResponseSent]: DidCommOutOfBandState.Done,
		[DidCommDidExchangeState.Completed]: DidCommOutOfBandState.Done,
		[DidCommDidExchangeState.Abandoned]: DidCommOutOfBandState.Done
	};
	if (state === DidCommDidExchangeState.Start) return role === DidCommDidExchangeRole.Requester ? DidCommOutOfBandState.PrepareResponse : DidCommOutOfBandState.AwaitResponse;
	return stateMapping[state];
}
/**
* Determine the did exchange state based on the connection/did-exchange role and state.
*/
function didExchangeStateAndRoleFromRoleAndState(role, state) {
	const roleMapping = {
		[DidCommDidExchangeRole.Responder]: DidCommDidExchangeRole.Responder,
		[DidCommConnectionRole.Inviter]: DidCommDidExchangeRole.Responder,
		[DidCommDidExchangeRole.Requester]: DidCommDidExchangeRole.Requester,
		[DidCommConnectionRole.Invitee]: DidCommDidExchangeRole.Requester
	};
	const roleStateMapping = {
		[DidCommDidExchangeRole.Requester]: {
			[DidCommConnectionState.Invited]: DidCommDidExchangeState.InvitationReceived,
			[DidCommConnectionState.Requested]: DidCommDidExchangeState.RequestSent,
			[DidCommConnectionState.Responded]: DidCommDidExchangeState.ResponseReceived,
			[DidCommConnectionState.Complete]: DidCommDidExchangeState.Completed,
			[DidCommConnectionState.Null]: DidCommDidExchangeState.Start
		},
		[DidCommDidExchangeRole.Responder]: {
			[DidCommConnectionState.Invited]: DidCommDidExchangeState.InvitationSent,
			[DidCommConnectionState.Requested]: DidCommDidExchangeState.RequestReceived,
			[DidCommConnectionState.Responded]: DidCommDidExchangeState.ResponseSent,
			[DidCommConnectionState.Complete]: DidCommDidExchangeState.Completed,
			[DidCommConnectionState.Null]: DidCommDidExchangeState.Start
		}
	};
	const didExchangeRole = roleMapping[role];
	const stateMapping = roleStateMapping[didExchangeRole];
	if (isConnectionState(state)) return [didExchangeRole, stateMapping[state]];
	return [didExchangeRole, state];
}
function isConnectionState(state) {
	return Object.values(DidCommConnectionState).includes(state);
}

//#endregion
export { migrateConnectionRecordToV0_2 };
//# sourceMappingURL=connection.mjs.map