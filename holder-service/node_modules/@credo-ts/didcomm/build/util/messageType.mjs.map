{"version":3,"file":"messageType.mjs","names":[],"sources":["../../src/util/messageType.ts"],"sourcesContent":["import type { ValidationArguments, ValidationOptions } from 'class-validator'\nimport { buildMessage, ValidateBy } from 'class-validator'\nimport type { DidCommPlaintextMessage } from '../types'\n\nconst PROTOCOL_URI_REGEX = /^(.+)\\/([^/\\\\]+)\\/(\\d+).(\\d+)$/\nconst MESSAGE_TYPE_REGEX = /^(.+)\\/([^/\\\\]+)\\/(\\d+).(\\d+)\\/([^/\\\\]+)$/\n\nexport interface ParsedDidCommProtocolUri {\n  /**\n   * Version of the protocol\n   *\n   * @example 1.0\n   */\n  protocolVersion: string\n\n  /**\n   * Major version of the protocol\n   *\n   * @example 1\n   */\n  protocolMajorVersion: number\n\n  /**\n   * Minor version of the protocol\n   *\n   * @example 0\n   */\n  protocolMinorVersion: number\n\n  /**\n   * Name of the protocol\n   *\n   * @example connections\n   */\n  protocolName: string\n\n  /**\n   * Document uri of the message.\n   *\n   * @example https://didcomm.org\n   */\n  documentUri: string\n\n  /**\n   * Uri identifier of the protocol. Includes the\n   * documentUri, protocolName and protocolVersion.\n   * Useful when working with feature discovery\n   *\n   * @example https://didcomm.org/connections/1.0\n   */\n  protocolUri: string\n}\n\nexport interface ParsedMessageType extends ParsedDidCommProtocolUri {\n  /**\n   * Message name\n   *\n   * @example request\n   */\n  messageName: string\n\n  /**\n   * Uri identifier of the message. Includes all parts\n   * or the message type.\n   *\n   * @example https://didcomm.org/connections/1.0/request\n   */\n  messageTypeUri: string\n}\n\n// TODO: rename to `parseDidCommMessageType` and `DidCommParsedProtocolUri`\n// in the future\nexport function parseMessageType(messageType: string): ParsedMessageType {\n  const match = MESSAGE_TYPE_REGEX.exec(messageType)\n\n  if (!match) {\n    throw new Error(`Invalid message type: ${messageType}`)\n  }\n\n  const [, documentUri, protocolName, protocolVersionMajor, protocolVersionMinor, messageName] = match\n\n  return {\n    documentUri,\n    protocolName,\n    protocolVersion: `${protocolVersionMajor}.${protocolVersionMinor}`,\n    protocolMajorVersion: Number.parseInt(protocolVersionMajor, 10),\n    protocolMinorVersion: Number.parseInt(protocolVersionMinor, 10),\n    messageName,\n    protocolUri: `${documentUri}/${protocolName}/${protocolVersionMajor}.${protocolVersionMinor}`,\n    messageTypeUri: messageType,\n  }\n}\n\nexport function parseDidCommProtocolUri(didCommProtocolUri: string): ParsedDidCommProtocolUri {\n  const match = PROTOCOL_URI_REGEX.exec(didCommProtocolUri)\n\n  if (!match) {\n    throw new Error(`Invalid protocol uri: ${didCommProtocolUri}`)\n  }\n\n  const [, documentUri, protocolName, protocolVersionMajor, protocolVersionMinor] = match\n\n  return {\n    documentUri,\n    protocolName,\n    protocolVersion: `${protocolVersionMajor}.${protocolVersionMinor}`,\n    protocolMajorVersion: Number.parseInt(protocolVersionMajor, 10),\n    protocolMinorVersion: Number.parseInt(protocolVersionMinor, 10),\n    protocolUri: `${documentUri}/${protocolName}/${protocolVersionMajor}.${protocolVersionMinor}`,\n  }\n}\n\n/**\n * Check whether the incoming didcomm protocol uri is a protocol uri that can be handled by comparing it to the expected didcomm protocol uri.\n * In this case the expected protocol uri is e.g. the handshake protocol supported (https://didcomm.org/connections/1.0), and the incoming protocol uri\n * is the uri that is parsed from the incoming out of band invitation handshake_protocols.\n *\n * The method will make sure the following fields are equal:\n *  - documentUri\n *  - protocolName\n *  - majorVersion\n *\n * If allowLegacyDidSovPrefixMismatch is true (default) it will allow for the case where the incoming protocol uri still has the legacy\n * did:sov:BzCbsNYhMrjHiqZDTUASHg;spec did prefix, but the expected message type does not. This only works for incoming messages with a prefix\n * of did:sov:BzCbsNYhMrjHiqZDTUASHg;spec and the expected message type having a prefix value of https:/didcomm.org\n *\n * @example\n * const incomingProtocolUri = parseDidCommProtocolUri('https://didcomm.org/connections/1.0')\n * const expectedProtocolUri = parseDidCommProtocolUri('https://didcomm.org/connections/1.4')\n *\n * // Returns true because the incoming protocol uri is equal to the expected protocol uri, except for\n * // the minor version, which is lower\n * const isIncomingProtocolUriSupported = supportsIncomingDidCommProtocolUri(incomingProtocolUri, expectedProtocolUri)\n *\n * @example\n * const incomingProtocolUri = parseDidCommProtocolUri('did:sov:BzCbsNYhMrjHiqZDTUASHg;spec/connections/1.0')\n * const expectedProtocolUri = parseDidCommProtocolUri('https://didcomm.org/connections/1.0')\n *\n * // Returns true because the incoming protocol uri is equal to the expected protocol uri, except for\n * // the legacy did sov prefix.\n * const isIncomingProtocolUriSupported = supportsIncomingDidCommProtocolUri(incomingProtocolUri, expectedProtocolUri)\n */\nexport function supportsIncomingDidCommProtocolUri(\n  incomingProtocolUri: ParsedDidCommProtocolUri,\n  expectedProtocolUri: ParsedDidCommProtocolUri,\n  { allowLegacyDidSovPrefixMismatch = true }: { allowLegacyDidSovPrefixMismatch?: boolean } = {}\n) {\n  const incomingDocumentUri = allowLegacyDidSovPrefixMismatch\n    ? replaceLegacyDidSovPrefix(incomingProtocolUri.documentUri)\n    : incomingProtocolUri.documentUri\n\n  const documentUriMatches = expectedProtocolUri.documentUri === incomingDocumentUri\n  const protocolNameMatches = expectedProtocolUri.protocolName === incomingProtocolUri.protocolName\n  const majorVersionMatches = expectedProtocolUri.protocolMajorVersion === incomingProtocolUri.protocolMajorVersion\n\n  // Everything besides the minor version must match\n  return documentUriMatches && protocolNameMatches && majorVersionMatches\n}\n\n/**\n * Check whether the incoming message type is a message type that can be handled by comparing it to the expected message type.\n * In this case the expected message type is e.g. the type declared on an agent message class, and the incoming message type is the type\n * that is parsed from the incoming JSON.\n *\n * The method will make sure the following fields are equal:\n *  - documentUri\n *  - protocolName\n *  - majorVersion\n *  - messageName\n *\n * If allowLegacyDidSovPrefixMismatch is true (default) it will allow for the case where the incoming message type still has the legacy\n * did:sov:BzCbsNYhMrjHiqZDTUASHg;spec did prefix, but the expected message type does not. This only works for incoming messages with a prefix\n * of did:sov:BzCbsNYhMrjHiqZDTUASHg;spec and the expected message type having a prefix value of https:/didcomm.org\n *\n * @example\n * const incomingMessageType = parseMessageType('https://didcomm.org/connections/1.0/request')\n * const expectedMessageType = parseMessageType('https://didcomm.org/connections/1.4/request')\n *\n * // Returns true because the incoming message type is equal to the expected message type, except for\n * // the minor version, which is lower\n * const isIncomingMessageTypeSupported = supportsIncomingMessageType(incomingMessageType, expectedMessageType)\n *\n * @example\n * const incomingMessageType = parseMessageType('did:sov:BzCbsNYhMrjHiqZDTUASHg;spec/connections/1.0/request')\n * const expectedMessageType = parseMessageType('https://didcomm.org/connections/1.0/request')\n *\n * // Returns true because the incoming message type is equal to the expected message type, except for\n * // the legacy did sov prefix.\n * const isIncomingMessageTypeSupported = supportsIncomingMessageType(incomingMessageType, expectedMessageType)\n */\nexport function supportsIncomingMessageType(\n  incomingMessageType: ParsedMessageType,\n  expectedMessageType: ParsedMessageType,\n  { allowLegacyDidSovPrefixMismatch = true }: { allowLegacyDidSovPrefixMismatch?: boolean } = {}\n) {\n  const incomingDocumentUri = allowLegacyDidSovPrefixMismatch\n    ? replaceLegacyDidSovPrefix(incomingMessageType.documentUri)\n    : incomingMessageType.documentUri\n\n  const documentUriMatches = expectedMessageType.documentUri === incomingDocumentUri\n  const protocolNameMatches = expectedMessageType.protocolName === incomingMessageType.protocolName\n  const majorVersionMatches = expectedMessageType.protocolMajorVersion === incomingMessageType.protocolMajorVersion\n  const messageNameMatches = expectedMessageType.messageName === incomingMessageType.messageName\n\n  // Everything besides the minor version must match\n  return documentUriMatches && protocolNameMatches && majorVersionMatches && messageNameMatches\n}\n\nexport function canHandleMessageType(\n  messageClass: { type: ParsedMessageType },\n  messageType: ParsedMessageType\n): boolean {\n  return supportsIncomingMessageType(messageClass.type, messageType)\n}\n\n/**\n * class-validator decorator to check if the string message type value matches with the\n * expected message type. This uses {@link supportsIncomingMessageType}.\n */\nexport function IsValidMessageType(\n  messageType: ParsedMessageType,\n  validationOptions?: ValidationOptions\n): PropertyDecorator {\n  return ValidateBy(\n    {\n      name: 'isValidMessageType',\n      constraints: [messageType],\n      validator: {\n        validate: (value, args: ValidationArguments): boolean => {\n          const [expectedMessageType] = args.constraints as [ParsedMessageType]\n\n          // Type must be string\n          if (typeof value !== 'string') {\n            return false\n          }\n\n          const incomingMessageType = parseMessageType(value)\n          return supportsIncomingMessageType(incomingMessageType, expectedMessageType)\n        },\n        defaultMessage: buildMessage(\n          (eachPrefix) =>\n            `${eachPrefix}$property does not match the expected message type (only minor version may be lower)`,\n          validationOptions\n        ),\n      },\n    },\n    validationOptions\n  )\n}\n\nexport function replaceLegacyDidSovPrefixOnMessage(message: DidCommPlaintextMessage | Record<string, unknown>) {\n  message['@type'] = replaceLegacyDidSovPrefix(message['@type'] as string)\n}\n\nexport function replaceNewDidCommPrefixWithLegacyDidSovOnMessage(message: Record<string, unknown>) {\n  message['@type'] = replaceNewDidCommPrefixWithLegacyDidSov(message['@type'] as string)\n}\n\nexport function replaceLegacyDidSovPrefix(messageType: string) {\n  const didSovPrefix = 'did:sov:BzCbsNYhMrjHiqZDTUASHg;spec'\n  const didCommPrefix = 'https://didcomm.org'\n\n  if (messageType.startsWith(didSovPrefix)) {\n    return messageType.replace(didSovPrefix, didCommPrefix)\n  }\n\n  return messageType\n}\n\nexport function replaceNewDidCommPrefixWithLegacyDidSov(messageType: string) {\n  const didSovPrefix = 'did:sov:BzCbsNYhMrjHiqZDTUASHg;spec'\n  const didCommPrefix = 'https://didcomm.org'\n\n  if (messageType.startsWith(didCommPrefix)) {\n    return messageType.replace(didCommPrefix, didSovPrefix)\n  }\n\n  return messageType\n}\n"],"mappings":"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"}