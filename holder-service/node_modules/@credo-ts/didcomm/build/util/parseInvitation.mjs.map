{"version":3,"file":"parseInvitation.mjs","names":[],"sources":["../../src/util/parseInvitation.ts"],"sourcesContent":["import type { AgentDependencies } from '@credo-ts/core'\n\nimport { CredoError, JsonEncoder, JsonTransformer, MessageValidator } from '@credo-ts/core'\nimport queryString from 'query-string'\n\nimport { DidCommMessage } from '../DidCommMessage'\nimport { DidCommConnectionInvitationMessage } from '../modules/connections/messages'\nimport { convertToNewInvitation } from '../modules/oob/converters'\nimport { OutOfBandDidCommService } from '../modules/oob/domain/OutOfBandDidCommService'\nimport { DidCommInvitationType, DidCommOutOfBandInvitation } from '../modules/oob/messages'\n\nimport { parseMessageType, supportsIncomingMessageType } from './messageType'\n\nconst fetchShortUrl = async (invitationUrl: string, dependencies: AgentDependencies) => {\n  const abortController = new AbortController()\n  const id = setTimeout(() => abortController.abort(), 15000)\n  let response: Response\n  try {\n    response = await dependencies.fetch(invitationUrl, {\n      method: 'GET',\n      headers: {\n        Accept: 'application/json',\n        'Content-Type': 'application/json',\n      },\n    })\n  } catch (error) {\n    throw new CredoError(`Get request failed on provided url: ${error.message}`, { cause: error })\n  }\n  clearTimeout(id)\n  return response\n}\n\n/**\n * Parses a JSON containing an invitation message and returns an DidCommOutOfBandInvitation instance\n *\n * @param invitationJson JSON object containing message\n * @returns DidCommOutOfBandInvitation\n */\nexport const parseInvitationJson = (invitationJson: Record<string, unknown>): DidCommOutOfBandInvitation => {\n  const messageType = invitationJson['@type'] as string\n\n  if (!messageType) {\n    throw new CredoError('Invitation is not a valid DIDComm message')\n  }\n\n  const parsedMessageType = parseMessageType(messageType)\n  if (supportsIncomingMessageType(parsedMessageType, DidCommOutOfBandInvitation.type)) {\n    const invitation = JsonTransformer.fromJSON(invitationJson, DidCommOutOfBandInvitation)\n    MessageValidator.validateSync(invitation)\n    invitation.invitationType = DidCommInvitationType.OutOfBand\n    return invitation\n  }\n  if (supportsIncomingMessageType(parsedMessageType, DidCommConnectionInvitationMessage.type)) {\n    const invitation = JsonTransformer.fromJSON(invitationJson, DidCommConnectionInvitationMessage)\n    MessageValidator.validateSync(invitation)\n    const outOfBandInvitation = convertToNewInvitation(invitation)\n    outOfBandInvitation.invitationType = DidCommInvitationType.Connection\n    return outOfBandInvitation\n  }\n  if (invitationJson['~service']) {\n    // This is probably a legacy connectionless invitation\n    return transformLegacyConnectionlessInvitationToOutOfBandInvitation(invitationJson)\n  }\n  throw new CredoError(`Invitation with '@type' ${parsedMessageType.messageTypeUri} not supported.`)\n}\n\n/**\n * Parses URL containing encoded invitation and returns invitation message.\n *\n * @param invitationUrl URL containing encoded invitation\n *\n * @returns DidCommOutOfBandInvitation\n */\nexport const parseInvitationUrl = (invitationUrl: string): DidCommOutOfBandInvitation => {\n  const parsedUrl = queryString.parseUrl(invitationUrl).query\n\n  const encodedInvitation = parsedUrl.oob ?? parsedUrl.c_i ?? parsedUrl.d_m\n\n  if (typeof encodedInvitation === 'string') {\n    const invitationJson = JsonEncoder.fromBase64(encodedInvitation) as Record<string, unknown>\n    return parseInvitationJson(invitationJson)\n  }\n  throw new CredoError(\n    'InvitationUrl is invalid. It needs to contain one, and only one, of the following parameters: `oob`, `c_i` or `d_m`.'\n  )\n}\n\n// This currently does not follow the RFC because of issues with fetch, currently uses a janky work around\nexport const oobInvitationFromShortUrl = async (response: Response): Promise<DidCommOutOfBandInvitation> => {\n  if (response) {\n    if (response.headers.get('Content-Type')?.startsWith('application/json') && response.ok) {\n      const invitationJson = (await response.json()) as Record<string, unknown>\n      return parseInvitationJson(invitationJson)\n    }\n    if (response.url) {\n      // The following if else is for here for trinsic shorten urls\n      // Because the redirect targets a deep link the automatic redirect does not occur\n      let responseUrl: string\n      const location = response.headers.get('Location')\n      if ((response.status === 302 || response.status === 301) && location) responseUrl = location\n      else responseUrl = response.url\n\n      return parseInvitationUrl(responseUrl)\n    }\n  }\n  throw new CredoError('HTTP request time out or did not receive valid response')\n}\n\nexport function transformLegacyConnectionlessInvitationToOutOfBandInvitation(messageJson: Record<string, unknown>) {\n  const agentMessage = JsonTransformer.fromJSON(messageJson, DidCommMessage)\n\n  // ~service is required for legacy connectionless invitations\n  if (!agentMessage.service) {\n    throw new CredoError('Invalid legacy connectionless invitation url. Missing ~service decorator.')\n  }\n\n  // This destructuring removes the ~service property from the message, and\n  // we can can use messageWithoutService to create the out of band invitation\n  const { '~service': service, ...messageWithoutService } = messageJson\n\n  // transform into out of band invitation\n  const invitation = new DidCommOutOfBandInvitation({\n    services: [OutOfBandDidCommService.fromResolvedDidCommService(agentMessage.service.resolvedDidCommService)],\n  })\n\n  invitation.invitationType = DidCommInvitationType.Connectionless\n  invitation.addRequest(JsonTransformer.fromJSON(messageWithoutService, DidCommMessage))\n\n  return invitation\n}\n\n/**\n * Parses URL containing encoded invitation and returns invitation message. Compatible with\n * parsing short Urls\n *\n * @param invitationUrl URL containing encoded invitation\n *\n * @param dependencies Agent dependencies containing fetch\n *\n * @returns DidCommOutOfBandInvitation\n */\nexport const parseInvitationShortUrl = async (\n  invitationUrl: string,\n  dependencies: AgentDependencies\n): Promise<DidCommOutOfBandInvitation> => {\n  const parsedUrl = queryString.parseUrl(invitationUrl).query\n  if (parsedUrl.oob || parsedUrl.c_i) {\n    return parseInvitationUrl(invitationUrl)\n  }\n  // Legacy connectionless invitation\n  if (parsedUrl.d_m) {\n    const messageJson = JsonEncoder.fromBase64(parsedUrl.d_m as string)\n    return transformLegacyConnectionlessInvitationToOutOfBandInvitation(messageJson)\n  }\n  try {\n    const outOfBandInvitation = await oobInvitationFromShortUrl(await fetchShortUrl(invitationUrl, dependencies))\n    outOfBandInvitation.invitationType = DidCommInvitationType.OutOfBand\n    return outOfBandInvitation\n  } catch (_error) {\n    throw new CredoError(\n      'InvitationUrl is invalid. It needs to contain one, and only one, of the following parameters: `oob`, `c_i` or `d_m`, or be valid shortened URL'\n    )\n  }\n}\n"],"mappings":"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"}