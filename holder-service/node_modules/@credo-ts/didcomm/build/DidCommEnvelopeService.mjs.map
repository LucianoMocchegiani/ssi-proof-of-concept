{"version":3,"file":"DidCommEnvelopeService.mjs","names":[],"sources":["../src/DidCommEnvelopeService.ts"],"sourcesContent":["import {\n  AgentContext,\n  CredoError,\n  InjectionSymbols,\n  inject,\n  injectable,\n  JsonEncoder,\n  Kms,\n  type Logger,\n  RecordNotFoundError,\n  TypedArrayEncoder,\n} from '@credo-ts/core'\nimport type { DidCommMessage } from './DidCommMessage'\nimport { DidCommModuleConfig } from './DidCommModuleConfig'\nimport { getResolvedDidcommServiceWithSigningKeyId } from './modules/connections/services/helpers'\nimport { DidCommOutOfBandRole } from './modules/oob/domain/DidCommOutOfBandRole'\nimport { DidCommOutOfBandRepository } from './modules/oob/repository/DidCommOutOfBandRepository'\nimport { DidCommOutOfBandRecordMetadataKeys } from './modules/oob/repository/outOfBandRecordMetadataTypes'\nimport { DidCommForwardMessage } from './modules/routing/messages/DidCommForwardMessage'\nimport { DidCommMediatorRoutingRepository } from './modules/routing/repository/DidCommMediatorRoutingRepository'\nimport { DidCommDocumentService } from './services/DidCommDocumentService'\nimport type { DidCommEncryptedMessage, DidCommPlaintextMessage } from './types'\n\nexport interface EnvelopeKeys {\n  recipientKeys: Kms.PublicJwk<Kms.Ed25519PublicJwk>[]\n  routingKeys: Kms.PublicJwk<Kms.Ed25519PublicJwk>[]\n  senderKey: Kms.PublicJwk<Kms.Ed25519PublicJwk> | null\n}\n\n@injectable()\nexport class DidCommEnvelopeService {\n  private logger: Logger\n  private didcommDocumentService: DidCommDocumentService\n\n  public constructor(@inject(InjectionSymbols.Logger) logger: Logger, didcommDocumentService: DidCommDocumentService) {\n    this.logger = logger\n    this.didcommDocumentService = didcommDocumentService\n  }\n\n  private async encryptDidcommV1Message(\n    agentContext: AgentContext,\n    message: DidCommPlaintextMessage,\n    recipientKeys: Kms.PublicJwk<Kms.Ed25519PublicJwk>[],\n    senderKey?: Kms.PublicJwk<Kms.Ed25519PublicJwk> | null\n  ): Promise<DidCommEncryptedMessage> {\n    const kms = agentContext.dependencyManager.resolve(Kms.KeyManagementApi)\n    // Generally we would never generate the content encryption key outside of the KMS\n    // However how DIDcommV1 is specified to calcualte the aad we need the encrypted content\n    // encryption key, and thus we can't use the normal combined key agrement + encryption flow\n    const contentEncryptionKey = kms.randomBytes({ length: 32 })\n\n    const recipients: Array<{\n      encrypted_key: string\n      header: {\n        kid: string\n\n        // In case of Authcrypt\n        sender?: string\n        iv?: string\n      }\n    }> = []\n\n    for (const recipientKey of recipientKeys) {\n      let encryptedSender: string | undefined\n\n      if (senderKey) {\n        // Encrypt the sender\n        const { encrypted } = await kms.encrypt({\n          key: {\n            keyAgreement: {\n              algorithm: 'ECDH-HSALSA20',\n              // DIDComm v1 uses Ed25519 keys but encryption happens with X25519 keys\n              externalPublicJwk: recipientKey.convertTo(Kms.X25519PublicJwk).toJson(),\n            },\n          },\n          encryption: {\n            algorithm: 'XSALSA20-POLY1305',\n          },\n          data: TypedArrayEncoder.fromString(TypedArrayEncoder.toBase58(senderKey.publicKey.publicKey)),\n        })\n\n        encryptedSender = TypedArrayEncoder.toBase64URL(encrypted)\n      }\n\n      // Encrypt the key\n      const { encrypted, iv } = await kms.encrypt({\n        key: {\n          keyAgreement: {\n            algorithm: 'ECDH-HSALSA20',\n            externalPublicJwk: recipientKey.convertTo(Kms.X25519PublicJwk).toJson(),\n\n            // Sender key only needed for Authcrypt\n            keyId: senderKey?.keyId,\n          },\n        },\n        data: contentEncryptionKey,\n        encryption: {\n          algorithm: 'XSALSA20-POLY1305',\n        },\n      })\n\n      recipients.push({\n        encrypted_key: TypedArrayEncoder.toBase64URL(encrypted),\n        header: {\n          kid: TypedArrayEncoder.toBase58(recipientKey.publicKey.publicKey),\n          iv: iv ? TypedArrayEncoder.toBase64URL(iv) : undefined,\n          sender: encryptedSender,\n        },\n      })\n    }\n\n    const protectedString = JsonEncoder.toBase64URL({\n      enc: 'xchacha20poly1305_ietf',\n      typ: 'JWM/1.0',\n      alg: senderKey ? 'Authcrypt' : 'Anoncrypt',\n      recipients,\n    })\n\n    // Perofrm the actual encryption\n    const { encrypted, iv, tag } = await kms.encrypt({\n      encryption: {\n        algorithm: 'C20P',\n        aad: TypedArrayEncoder.fromString(protectedString),\n      },\n      data: JsonEncoder.toBuffer(message),\n      key: {\n        privateJwk: {\n          kty: 'oct',\n          k: TypedArrayEncoder.toBase64URL(contentEncryptionKey),\n        },\n      },\n    })\n\n    if (!iv || !tag) {\n      throw new CredoError(\"Expected 'iv' and 'tag' to be defined\")\n    }\n\n    return {\n      ciphertext: TypedArrayEncoder.toBase64URL(encrypted),\n      iv: TypedArrayEncoder.toBase64URL(iv),\n      tag: TypedArrayEncoder.toBase64URL(tag),\n      protected: protectedString,\n    } satisfies DidCommEncryptedMessage\n  }\n\n  private async decryptDidcommV1Message(agentContext: AgentContext, encryptedMessage: DidCommEncryptedMessage) {\n    const kms = agentContext.dependencyManager.resolve(Kms.KeyManagementApi)\n    const protectedJson = JsonEncoder.fromBase64(encryptedMessage.protected)\n\n    const alg = protectedJson.alg as 'Anoncrypt' | 'Authcrypt'\n    if (alg !== 'Anoncrypt' && alg !== 'Authcrypt') {\n      throw new CredoError(`Unsupported pack algorithm: ${alg}`)\n    }\n\n    if (protectedJson.enc !== 'xchacha20poly1305_ietf') {\n      throw new CredoError(`Unsupported enc algorithm: ${protectedJson.enc}`)\n    }\n\n    let recipientKey: Kms.PublicJwk<Kms.Ed25519PublicJwk> | null = null\n    let recipient: {\n      header: {\n        kid: string\n        iv?: string\n        sender?: string\n      }\n      encrypted_key: string\n    } | null = null\n\n    for (const _recipient of protectedJson.recipients) {\n      recipientKey = await this.extractOurRecipientKeyWithKeyId(agentContext, _recipient)\n\n      if (recipientKey) {\n        recipient = _recipient\n      }\n    }\n\n    if (!recipientKey || !recipient) {\n      throw new CredoError('No corresponding recipient key found')\n    }\n\n    if (alg === 'Authcrypt' && (!recipient.header.sender || !recipient.header.iv)) {\n      throw new CredoError('Sender and iv header values are required for Authcrypt')\n    }\n\n    let senderPublicJwk: Kms.PublicJwk<Kms.Ed25519PublicJwk> | undefined\n    if (recipient.header.sender) {\n      const { data } = await kms.decrypt({\n        key: {\n          keyAgreement: {\n            algorithm: 'ECDH-HSALSA20',\n            keyId: recipientKey.keyId,\n          },\n        },\n        decryption: {\n          algorithm: 'XSALSA20-POLY1305',\n        },\n        encrypted: TypedArrayEncoder.fromBase64(recipient.header.sender),\n      })\n\n      senderPublicJwk = Kms.PublicJwk.fromPublicKey({\n        crv: 'Ed25519',\n        kty: 'OKP',\n        publicKey: TypedArrayEncoder.fromBase58(TypedArrayEncoder.toUtf8String(data)),\n      })\n    }\n\n    // Perofrm the actual decryption\n    const { data: contentEncryptionKey } = await kms.decrypt({\n      decryption: {\n        algorithm: 'XSALSA20-POLY1305',\n        iv: recipient.header.iv ? TypedArrayEncoder.fromBase64(recipient.header.iv) : undefined,\n      },\n      encrypted: TypedArrayEncoder.fromBase64(recipient.encrypted_key),\n      key: {\n        keyAgreement: {\n          algorithm: 'ECDH-HSALSA20',\n          keyId: recipientKey.keyId,\n\n          // Optionally we have a sender\n          externalPublicJwk: senderPublicJwk?.convertTo(Kms.X25519PublicJwk).toJson(),\n        },\n      },\n    })\n\n    const { data: message } = await kms.decrypt({\n      decryption: {\n        algorithm: 'C20P',\n        iv: TypedArrayEncoder.fromBase64(encryptedMessage.iv),\n        tag: TypedArrayEncoder.fromBase64(encryptedMessage.tag),\n        aad: TypedArrayEncoder.fromString(encryptedMessage.protected),\n      },\n      key: {\n        privateJwk: {\n          kty: 'oct',\n          k: TypedArrayEncoder.toBase64URL(contentEncryptionKey),\n        },\n      },\n      encrypted: TypedArrayEncoder.fromBase64(encryptedMessage.ciphertext),\n    })\n\n    return {\n      plaintextMessage: JsonEncoder.fromBuffer(message),\n      senderKey: senderPublicJwk,\n      recipientKey,\n    }\n  }\n\n  public async packMessage(\n    agentContext: AgentContext,\n    payload: DidCommMessage,\n    keys: EnvelopeKeys\n  ): Promise<DidCommEncryptedMessage> {\n    const didcommConfig = agentContext.dependencyManager.resolve(DidCommModuleConfig)\n\n    const { routingKeys, senderKey } = keys\n    let recipientKeys = keys.recipientKeys\n\n    // pass whether we want to use legacy did sov prefix\n    const message = payload.toJSON({ useDidSovPrefixWhereAllowed: didcommConfig.useDidSovPrefixWhereAllowed })\n\n    this.logger.debug(`Pack outbound message ${message['@type']}`)\n\n    let encryptedMessage = await this.encryptDidcommV1Message(agentContext, message, recipientKeys, senderKey)\n\n    // If the message has routing keys (mediator) pack for each mediator\n    for (const routingKey of routingKeys) {\n      const forwardMessage = new DidCommForwardMessage({\n        // Forward to first recipient key\n        to: TypedArrayEncoder.toBase58(recipientKeys[0].publicKey.publicKey),\n        message: encryptedMessage,\n      })\n      recipientKeys = [routingKey]\n      this.logger.debug('Forward message created', forwardMessage)\n\n      const forwardJson = forwardMessage.toJSON({\n        useDidSovPrefixWhereAllowed: didcommConfig.useDidSovPrefixWhereAllowed,\n      })\n\n      // Forward messages are anon packed\n      encryptedMessage = await this.encryptDidcommV1Message(agentContext, forwardJson, [routingKey])\n    }\n\n    this.logger.debug(`Packed outbound message ${message['@type']}`, {\n      routingKeys: routingKeys.map((routingKey) => routingKey.fingerprint),\n    })\n\n    return encryptedMessage\n  }\n\n  public async unpackMessage(\n    agentContext: AgentContext,\n    encryptedMessage: DidCommEncryptedMessage\n  ): Promise<DecryptedDidCommMessageContext> {\n    const decryptedMessage = await this.decryptDidcommV1Message(agentContext, encryptedMessage)\n    return decryptedMessage\n  }\n\n  private async extractOurRecipientKeyWithKeyId(\n    agentContext: AgentContext,\n    recipient: {\n      header: {\n        kid: string\n      }\n    }\n  ): Promise<Kms.PublicJwk<Kms.Ed25519PublicJwk> | null> {\n    const kms = agentContext.resolve(Kms.KeyManagementApi)\n\n    const publicKey = Kms.PublicJwk.fromPublicKey({\n      kty: 'OKP',\n      crv: 'Ed25519',\n      publicKey: TypedArrayEncoder.fromBase58(recipient.header.kid),\n    })\n\n    // We need to find the associated did based on the recipient key\n    // so we can extract the kms key id from the did record.\n    try {\n      const { didDocument, keys } = await this.didcommDocumentService.resolveCreatedDidDocumentWithKeysByRecipientKey(\n        agentContext,\n        publicKey\n      )\n\n      const verificationMethod = didDocument.findVerificationMethodByPublicKey(publicKey)\n      const kmsKeyId = keys?.find(({ didDocumentRelativeKeyId }) =>\n        verificationMethod.id.endsWith(didDocumentRelativeKeyId)\n      )?.kmsKeyId\n\n      agentContext.config.logger.debug(\n        `Found did '${didDocument.id}' for recipient key '${publicKey.fingerprint}' for incoming didcomm message`\n      )\n\n      publicKey.keyId = kmsKeyId ?? publicKey.legacyKeyId\n      return publicKey\n    } catch (error) {\n      // If there is no did record yet, we first look at the mediator routing record\n      const mediatorRoutingRepository = agentContext.dependencyManager.resolve(DidCommMediatorRoutingRepository)\n      if (error instanceof RecordNotFoundError) {\n        const mediatorRoutingRecord = await mediatorRoutingRepository.findSingleByQuery(agentContext, {\n          routingKeyFingerprints: [publicKey.fingerprint],\n        })\n\n        if (mediatorRoutingRecord) {\n          agentContext.config.logger.debug(\n            `Found mediator routing record with id '${mediatorRoutingRecord.id}' for recipient key '${publicKey.fingerprint}' for incoming didcomm message`\n          )\n\n          const routingKey = mediatorRoutingRecord.routingKeysWithKeyId.find((routingKey) =>\n            publicKey.equals(routingKey)\n          )\n\n          // This should not happen as we only get here if the tag matches\n          if (!routingKey) {\n            throw new CredoError(\n              `Expected to find key with fingerprint '${publicKey.fingerprint}' in routing keys of mediator routing record '${mediatorRoutingRecord.id}'`\n            )\n          }\n\n          if (routingKey) {\n            return routingKey\n          }\n        }\n\n        //  If there is no mediator routing record, we look at the out of band record\n        const outOfBandRepository = agentContext.dependencyManager.resolve(DidCommOutOfBandRepository)\n        const outOfBandRecord = await outOfBandRepository.findSingleByQuery(agentContext, {\n          $or: [\n            // In case we are the creator of the out of band invitation we can query based on\n            // out of band invitation recipient key fingerprint\n            {\n              role: DidCommOutOfBandRole.Sender,\n              recipientKeyFingerprints: [publicKey.fingerprint],\n            },\n            // In case we are the receiver of the out of band invitation we need to query\n            // for the recipient routing fingerprint\n            {\n              role: DidCommOutOfBandRole.Receiver,\n              recipientRoutingKeyFingerprint: publicKey.fingerprint,\n            },\n          ],\n        })\n\n        if (outOfBandRecord?.role === DidCommOutOfBandRole.Sender) {\n          agentContext.config.logger.debug(\n            `Found out of band record with id '${outOfBandRecord.id}' and role '${outOfBandRecord.role}' for recipient key '${publicKey.fingerprint}' for incoming didcomm message`\n          )\n\n          for (const service of outOfBandRecord.outOfBandInvitation.getInlineServices()) {\n            const resolvedService = getResolvedDidcommServiceWithSigningKeyId(\n              service,\n              outOfBandRecord.invitationInlineServiceKeys\n            )\n            const _recipientKey = resolvedService.recipientKeys.find((recipientKey) => recipientKey.equals(publicKey))\n\n            if (_recipientKey) {\n              return _recipientKey\n            }\n          }\n        } else if (outOfBandRecord?.role === DidCommOutOfBandRole.Receiver) {\n          agentContext.config.logger.debug(\n            `Found out of band record with id '${outOfBandRecord.id}' and role '${outOfBandRecord.role}' for recipient key '${publicKey.fingerprint}' for incoming didcomm message`\n          )\n\n          // If there is still no key we need to look at the metadata\n          const recipieintRouting = outOfBandRecord.metadata.get(DidCommOutOfBandRecordMetadataKeys.RecipientRouting)\n          if (recipieintRouting?.recipientKeyFingerprint === publicKey.fingerprint) {\n            publicKey.keyId = recipieintRouting.recipientKeyId ?? publicKey.legacyKeyId\n            return publicKey\n          }\n        }\n\n        // If there is no did found, no out of band record found, and not mediator routing record\n        // this is either:\n        //  - a connectionless oob exchange initiated before we added key ids.\n        //  - a message for a mediator, where the mediator routing record is created before we added key ids\n        //\n        // We will check if the public key exists based on the base58 encoded public key. We can remove this flow once we create a migration\n        // that optimizes this flow.\n        const kmsJwkPublic = await kms\n          .getPublicKey({\n            keyId: publicKey.legacyKeyId,\n          })\n          .catch((error) => {\n            if (error instanceof Kms.KeyManagementKeyNotFoundError) return null\n            throw error\n          })\n        if (kmsJwkPublic) {\n          agentContext.config.logger.debug(\n            `Found public key with legacy key id '${publicKey.legacyKeyId}' for recipient key '${publicKey.fingerprint}' for incoming didcomm message`\n          )\n\n          publicKey.keyId = publicKey.legacyKeyId\n          return publicKey\n        }\n      }\n    }\n\n    // no match found\n    return null\n  }\n}\n\nexport interface DecryptedDidCommMessageContext {\n  plaintextMessage: DidCommPlaintextMessage\n  senderKey?: Kms.PublicJwk<Kms.Ed25519PublicJwk>\n  recipientKey: Kms.PublicJwk<Kms.Ed25519PublicJwk>\n}\n"],"mappings":"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"}