{"version":3,"file":"DidCommMessageSender.mjs","names":[],"sources":["../src/DidCommMessageSender.ts"],"sourcesContent":["import {\n  AgentContext,\n  CredoError,\n  DidKey,\n  DidsApi,\n  didKeyToEd25519PublicJwk,\n  EventEmitter,\n  getPublicJwkFromVerificationMethod,\n  injectable,\n  Kms,\n  MessageValidator,\n  type ResolvedDidCommService,\n  utils,\n  verkeyToDidKey,\n} from '@credo-ts/core'\nimport { DID_COMM_TRANSPORT_QUEUE } from './constants'\nimport type { EnvelopeKeys } from './DidCommEnvelopeService'\nimport { DidCommEnvelopeService } from './DidCommEnvelopeService'\nimport type { DidCommMessageSentEvent } from './DidCommEvents'\nimport { DidCommEventTypes } from './DidCommEvents'\nimport type { DidCommMessage } from './DidCommMessage'\nimport { DidCommModuleConfig } from './DidCommModuleConfig'\nimport type { DidCommTransportSession } from './DidCommTransportService'\nimport { DidCommTransportService } from './DidCommTransportService'\nimport { ReturnRouteTypes } from './decorators/transport/TransportDecorator'\nimport { MessageSendingError } from './errors'\nimport { DidCommOutboundMessageContext, OutboundMessageSendStatus } from './models'\nimport type { DidCommConnectionRecord } from './modules/connections/repository'\nimport type { DidCommOutOfBandRecord } from './modules/oob/repository'\nimport { DidCommDocumentService } from './services/DidCommDocumentService'\nimport type { DidCommEncryptedMessage, DidCommOutboundPackage } from './types'\n\nexport interface TransportPriorityOptions {\n  schemes: string[]\n  restrictive?: boolean\n}\n\n@injectable()\nexport class DidCommMessageSender {\n  private envelopeService: DidCommEnvelopeService\n  private transportService: DidCommTransportService\n  private didCommModuleConfig: DidCommModuleConfig\n  private didCommDocumentService: DidCommDocumentService\n  private eventEmitter: EventEmitter\n\n  public constructor(\n    envelopeService: DidCommEnvelopeService,\n    transportService: DidCommTransportService,\n    didCommModuleConfig: DidCommModuleConfig,\n    didCommDocumentService: DidCommDocumentService,\n    eventEmitter: EventEmitter\n  ) {\n    this.envelopeService = envelopeService\n    this.transportService = transportService\n    this.didCommModuleConfig = didCommModuleConfig\n    this.didCommDocumentService = didCommDocumentService\n    this.eventEmitter = eventEmitter\n  }\n\n  public async packMessage(\n    agentContext: AgentContext,\n    {\n      keys,\n      message,\n      endpoint,\n    }: {\n      keys: EnvelopeKeys\n      message: DidCommMessage\n      endpoint: string\n    }\n  ): Promise<DidCommOutboundPackage> {\n    const encryptedMessage = await this.envelopeService.packMessage(agentContext, message, keys)\n\n    return {\n      payload: encryptedMessage,\n      responseRequested: message.hasAnyReturnRoute(),\n      endpoint,\n    }\n  }\n\n  private async sendMessageToSession(\n    agentContext: AgentContext,\n    session: DidCommTransportSession,\n    message: DidCommMessage\n  ) {\n    agentContext.config.logger.debug(`Packing message and sending it via existing session ${session.type}...`)\n    if (!session.keys) {\n      throw new CredoError(`There are no keys for the given ${session.type} transport session.`)\n    }\n    const encryptedMessage = await this.envelopeService.packMessage(agentContext, message, session.keys)\n    agentContext.config.logger.debug('Sending message')\n    await session.send(agentContext, encryptedMessage)\n  }\n\n  public async sendPackage(\n    agentContext: AgentContext,\n    {\n      connection,\n      encryptedMessage,\n      recipientKey,\n      options,\n    }: {\n      connection: DidCommConnectionRecord\n      recipientKey: string\n      encryptedMessage: DidCommEncryptedMessage\n      options?: { transportPriority?: TransportPriorityOptions }\n    }\n  ) {\n    const errors: Error[] = []\n\n    // Try to send to already open session\n    const session = this.transportService.findSessionByConnectionId(connection.id)\n    if (session?.inboundMessage?.hasReturnRouting()) {\n      try {\n        await session.send(agentContext, encryptedMessage)\n        return\n      } catch (error) {\n        errors.push(error)\n        agentContext.config.logger.debug(\n          `Sending packed message via session failed with error: ${error.message}.`,\n          error\n        )\n      }\n    }\n\n    // Retrieve DIDComm services\n    const { services, queueService } = await this.retrieveServicesByConnection(\n      agentContext,\n      connection,\n      options?.transportPriority\n    )\n\n    if (this.didCommModuleConfig.outboundTransports.length === 0 && !queueService) {\n      throw new CredoError('Agent has no outbound transport!')\n    }\n\n    // Loop trough all available services and try to send the message\n    for (const service of services) {\n      agentContext.config.logger.debug('Sending outbound message to service:', { service })\n      try {\n        const protocolScheme = utils.getProtocolScheme(service.serviceEndpoint)\n        for (const transport of this.didCommModuleConfig.outboundTransports) {\n          if (transport.supportedSchemes.includes(protocolScheme)) {\n            await transport.sendMessage({\n              payload: encryptedMessage,\n              endpoint: service.serviceEndpoint,\n              connectionId: connection.id,\n            })\n            break\n          }\n        }\n        return\n      } catch (error) {\n        agentContext.config.logger.debug(\n          `Sending outbound message to service with id ${service.id} failed with the following error:`,\n          {\n            message: error.message,\n            error: error,\n          }\n        )\n      }\n    }\n\n    // We didn't succeed to send the message over open session, or directly to serviceEndpoint\n    // If the other party shared a queue service endpoint in their did doc we queue the message\n    if (queueService) {\n      agentContext.config.logger.debug(\n        `Queue packed message for connection ${connection.id} (${connection.theirLabel})`\n      )\n      await this.didCommModuleConfig.queueTransportRepository.addMessage(agentContext, {\n        connectionId: connection.id,\n        recipientDids: [verkeyToDidKey(recipientKey)],\n        payload: encryptedMessage,\n      })\n      return\n    }\n\n    // Message is undeliverable\n    agentContext.config.logger.error(\n      `Message is undeliverable to connection ${connection.id} (${connection.theirLabel})`,\n      {\n        message: encryptedMessage,\n        errors,\n        connection,\n      }\n    )\n    throw new CredoError(`Message is undeliverable to connection ${connection.id} (${connection.theirLabel})`)\n  }\n\n  public async sendMessage(\n    outboundMessageContext: DidCommOutboundMessageContext,\n    options?: {\n      transportPriority?: TransportPriorityOptions\n    }\n  ) {\n    const { agentContext, connection, outOfBand, message } = outboundMessageContext\n    const errors: Error[] = []\n\n    if (outboundMessageContext.isOutboundServiceMessage()) {\n      return this.sendMessageToService(outboundMessageContext)\n    }\n\n    if (!connection) {\n      agentContext.config.logger.error('Outbound message has no associated connection')\n      this.emitMessageSentEvent(outboundMessageContext, OutboundMessageSendStatus.Undeliverable)\n      throw new MessageSendingError('Outbound message has no associated connection', {\n        outboundMessageContext,\n      })\n    }\n\n    agentContext.config.logger.debug('Send outbound message', {\n      message,\n      connectionId: connection.id,\n    })\n\n    const session = this.findSessionForOutboundContext(outboundMessageContext)\n\n    if (session) {\n      agentContext.config.logger.debug(\n        `Found session with return routing for message '${message.id}' (connection '${connection.id}'`\n      )\n\n      try {\n        await this.sendMessageToSession(agentContext, session, message)\n        this.emitMessageSentEvent(outboundMessageContext, OutboundMessageSendStatus.SentToSession)\n        return\n      } catch (error) {\n        errors.push(error)\n        agentContext.config.logger.debug(\n          `Sending an outbound message via session failed with error: ${error.message}.`,\n          error\n        )\n      }\n    }\n\n    // Retrieve DIDComm services\n    let services: ResolvedDidCommService[] = []\n    let queueService: ResolvedDidCommService | undefined\n\n    try {\n      ;({ services, queueService } = await this.retrieveServicesByConnection(\n        agentContext,\n        connection,\n        options?.transportPriority,\n        outOfBand\n      ))\n    } catch (error) {\n      agentContext.config.logger.error(`Unable to retrieve services for connection '${connection.id}. ${error.message}`)\n      this.emitMessageSentEvent(outboundMessageContext, OutboundMessageSendStatus.Undeliverable)\n      throw new MessageSendingError(`Unable to retrieve services for connection '${connection.id}`, {\n        outboundMessageContext,\n        cause: error,\n      })\n    }\n\n    if (!connection.did) {\n      agentContext.config.logger.error(\n        `Unable to send message using connection '${connection.id}' that doesn't have a did`\n      )\n      this.emitMessageSentEvent(outboundMessageContext, OutboundMessageSendStatus.Undeliverable)\n      throw new MessageSendingError(\n        `Unable to send message using connection '${connection.id}' that doesn't have a did`,\n        { outboundMessageContext }\n      )\n    }\n\n    const dids = agentContext.resolve(DidsApi)\n    const { didDocument, keys } = await dids.resolveCreatedDidDocumentWithKeys(connection.did).catch((error) => {\n      agentContext.config.logger.error(\n        `Unable to send message using connection '${connection.id}', unable to resolve did`,\n        {\n          error,\n        }\n      )\n      this.emitMessageSentEvent(outboundMessageContext, OutboundMessageSendStatus.Undeliverable)\n      throw new MessageSendingError(\n        `Unable to send message using connection '${connection.id}'. Unble to resolve did`,\n        { outboundMessageContext, cause: error }\n      )\n    })\n\n    const authentication = didDocument.authentication\n      ?.map((a) => {\n        const verificationMethod = typeof a === 'string' ? didDocument.dereferenceVerificationMethod(a) : a\n        const publicJwk = getPublicJwkFromVerificationMethod(verificationMethod)\n        const kmsKeyId = keys?.find((key) => verificationMethod.id.endsWith(key.didDocumentRelativeKeyId))?.kmsKeyId\n\n        // Set stored key id, or fallback to legacy key id\n        publicJwk.keyId = kmsKeyId ?? publicJwk.legacyKeyId\n\n        return { verificationMethod, publicJwk, kmsKeyId }\n      })\n      .filter((v): v is typeof v & { publicJwk: Kms.PublicJwk<Kms.Ed25519PublicJwk> } =>\n        v.publicJwk.is(Kms.Ed25519PublicJwk)\n      )\n\n    // We take the first one with a kms key id. Otherwise we pick the first\n    const senderVerificationMethod = authentication?.find((a) => a.kmsKeyId !== undefined) ?? authentication?.[0]\n    if (!senderVerificationMethod) {\n      throw new MessageSendingError(\n        `Unable to determine sender key for did ${connection.did}, no available Ed25519 keys`,\n        {\n          outboundMessageContext,\n        }\n      )\n    }\n\n    // If the returnRoute is already set we won't override it. This allows to set the returnRoute manually if this is desired.\n    const shouldAddReturnRoute =\n      message.transport?.returnRoute === undefined && !this.transportService.hasInboundEndpoint(didDocument)\n\n    // Loop trough all available services and try to send the message\n    for (const service of services) {\n      try {\n        // Enable return routing if the our did document does not have any inbound endpoint for given sender key\n        await this.sendToService(\n          new DidCommOutboundMessageContext(message, {\n            agentContext,\n            serviceParams: {\n              service,\n              senderKey: senderVerificationMethod.publicJwk,\n              returnRoute: shouldAddReturnRoute,\n            },\n            connection,\n          })\n        )\n        this.emitMessageSentEvent(outboundMessageContext, OutboundMessageSendStatus.SentToTransport)\n        return\n      } catch (error) {\n        errors.push(error)\n        agentContext.config.logger.debug(\n          `Sending outbound message to service with id ${service.id} failed with the following error:`,\n          {\n            message: error.message,\n            error: error,\n          }\n        )\n      }\n    }\n\n    // We didn't succeed to send the message over open session, or directly to serviceEndpoint\n    // If the other party shared a queue service endpoint in their did doc we queue the message\n    if (queueService && message.allowQueueTransport) {\n      agentContext.config.logger.debug(`Queue message for connection ${connection.id} (${connection.theirLabel})`)\n\n      const keys = {\n        recipientKeys: queueService.recipientKeys,\n        routingKeys: queueService.routingKeys,\n        senderKey: senderVerificationMethod.publicJwk,\n      }\n\n      const encryptedMessage = await this.envelopeService.packMessage(agentContext, message, keys)\n      await this.didCommModuleConfig.queueTransportRepository.addMessage(agentContext, {\n        connectionId: connection.id,\n        recipientDids: keys.recipientKeys.map((item) => new DidKey(item).did),\n        payload: encryptedMessage,\n      })\n\n      this.emitMessageSentEvent(outboundMessageContext, OutboundMessageSendStatus.QueuedForPickup)\n\n      return\n    }\n\n    // Message is undeliverable\n    agentContext.config.logger.error(\n      `Message is undeliverable to connection ${connection.id} (${connection.theirLabel})`,\n      {\n        message,\n        errors,\n        connection,\n      }\n    )\n    this.emitMessageSentEvent(outboundMessageContext, OutboundMessageSendStatus.Undeliverable)\n\n    throw new MessageSendingError(\n      `Message is undeliverable to connection ${connection.id} (${connection.theirLabel}). \\n\\nReasons:\\n\\t- ${errors.map((e) => e.message).join('\\n\\t-')}`,\n      { outboundMessageContext }\n    )\n  }\n\n  private async sendMessageToService(outboundMessageContext: DidCommOutboundMessageContext) {\n    const session = this.findSessionForOutboundContext(outboundMessageContext)\n\n    if (session) {\n      outboundMessageContext.agentContext.config.logger.debug(\n        `Found session with return routing for message '${outboundMessageContext.message.id}'`\n      )\n      try {\n        await this.sendMessageToSession(outboundMessageContext.agentContext, session, outboundMessageContext.message)\n        this.emitMessageSentEvent(outboundMessageContext, OutboundMessageSendStatus.SentToSession)\n        return\n      } catch (error) {\n        outboundMessageContext.agentContext.config.logger.debug(\n          `Sending an outbound message via session failed with error: ${error.message}.`,\n          error\n        )\n      }\n    }\n\n    // If there is no session try sending to service instead\n    try {\n      await this.sendToService(outboundMessageContext)\n      this.emitMessageSentEvent(outboundMessageContext, OutboundMessageSendStatus.SentToTransport)\n    } catch (error) {\n      outboundMessageContext.agentContext.config.logger.error(\n        `Message is undeliverable to service with id ${outboundMessageContext.serviceParams?.service.id}: ${error.message}`,\n        {\n          message: outboundMessageContext.message,\n          error,\n        }\n      )\n      this.emitMessageSentEvent(outboundMessageContext, OutboundMessageSendStatus.Undeliverable)\n\n      throw new MessageSendingError(\n        `Message is undeliverable to service with id ${outboundMessageContext.serviceParams?.service.id}: ${error.message}`,\n        { outboundMessageContext }\n      )\n    }\n  }\n\n  private async sendToService(outboundMessageContext: DidCommOutboundMessageContext) {\n    const { agentContext, message, serviceParams, connection } = outboundMessageContext\n\n    if (!serviceParams) {\n      throw new CredoError('No service parameters found in outbound message context')\n    }\n    const { service, senderKey, returnRoute } = serviceParams\n\n    if (this.didCommModuleConfig.outboundTransports.length === 0) {\n      throw new CredoError('Agent has no outbound transport!')\n    }\n\n    agentContext.config.logger.debug('Sending outbound message to service:', {\n      messageId: message.id,\n      service: { ...service, recipientKeys: 'omitted...', routingKeys: 'omitted...' },\n    })\n\n    const keys = {\n      recipientKeys: service.recipientKeys,\n      routingKeys: service.routingKeys,\n      senderKey,\n    }\n\n    // Set return routing for message if requested\n    if (returnRoute) {\n      message.setReturnRouting(ReturnRouteTypes.all)\n    }\n\n    try {\n      MessageValidator.validateSync(message)\n    } catch (error) {\n      agentContext.config.logger.error(\n        `Aborting sending outbound message ${message.type} to ${service.serviceEndpoint}. Message validation failed`,\n        {\n          errors: error,\n          message: message.toJSON(),\n        }\n      )\n\n      throw error\n    }\n\n    const outboundPackage = await this.packMessage(agentContext, { message, keys, endpoint: service.serviceEndpoint })\n    outboundPackage.endpoint = service.serviceEndpoint\n    outboundPackage.connectionId = connection?.id\n    for (const transport of this.didCommModuleConfig.outboundTransports) {\n      const protocolScheme = utils.getProtocolScheme(service.serviceEndpoint)\n      if (!protocolScheme) {\n        agentContext.config.logger.warn('Service does not have a protocol scheme.')\n      } else if (transport.supportedSchemes.includes(protocolScheme)) {\n        await transport.sendMessage(outboundPackage)\n        return\n      }\n    }\n    throw new MessageSendingError(`Unable to send message to service: ${service.serviceEndpoint}`, {\n      outboundMessageContext,\n    })\n  }\n\n  private findSessionForOutboundContext(outboundContext: DidCommOutboundMessageContext) {\n    let session: DidCommTransportSession | undefined\n\n    // Use session id from outbound context if present, or use the session from the inbound message context\n    const sessionId = outboundContext.sessionId ?? outboundContext.inboundMessageContext?.sessionId\n\n    // Try to find session by id\n    if (sessionId) {\n      session = this.transportService.findSessionById(sessionId)\n    }\n\n    // Try to find session by connection id\n    if (!session && outboundContext.connection?.id) {\n      session = this.transportService.findSessionByConnectionId(outboundContext.connection.id)\n    }\n\n    return session?.inboundMessage?.hasAnyReturnRoute() ? session : null\n  }\n\n  private async retrieveServicesByConnection(\n    agentContext: AgentContext,\n    connection: DidCommConnectionRecord,\n    transportPriority?: TransportPriorityOptions,\n    outOfBand?: DidCommOutOfBandRecord\n  ) {\n    agentContext.config.logger.debug(\n      `Retrieving services for connection '${connection.id}' (${connection.theirLabel})`,\n      {\n        transportPriority,\n        connection,\n      }\n    )\n\n    let didCommServices: ResolvedDidCommService[] = []\n\n    if (connection.theirDid) {\n      agentContext.config.logger.debug(`Resolving services for connection theirDid ${connection.theirDid}.`)\n      didCommServices = await this.didCommDocumentService.resolveServicesFromDid(agentContext, connection.theirDid)\n    } else if (outOfBand) {\n      agentContext.config.logger.debug(`Resolving services from out-of-band record ${outOfBand.id}.`)\n      if (connection.isRequester) {\n        for (const service of outOfBand.outOfBandInvitation.getServices()) {\n          // Resolve dids to DIDDocs to retrieve services\n          if (typeof service === 'string') {\n            agentContext.config.logger.debug(`Resolving services for did ${service}.`)\n            didCommServices.push(...(await this.didCommDocumentService.resolveServicesFromDid(agentContext, service)))\n          } else {\n            // Out of band inline service contains keys encoded as did:key references\n            didCommServices.push({\n              id: service.id,\n              recipientKeys: service.recipientKeys.map(didKeyToEd25519PublicJwk),\n              routingKeys: service.routingKeys?.map(didKeyToEd25519PublicJwk) || [],\n              serviceEndpoint: service.serviceEndpoint,\n            })\n          }\n        }\n      }\n    }\n\n    // Separate queue service out\n    let services = didCommServices.filter((s) => !isDidCommTransportQueue(s.serviceEndpoint))\n    const queueService = didCommServices.find((s) => isDidCommTransportQueue(s.serviceEndpoint))\n\n    // If restrictive will remove services not listed in schemes list\n    if (transportPriority?.restrictive) {\n      services = services.filter((service) => {\n        const serviceSchema = utils.getProtocolScheme(service.serviceEndpoint)\n        return transportPriority.schemes.includes(serviceSchema)\n      })\n    }\n\n    // If transport priority is set we will sort services by our priority\n    if (transportPriority?.schemes) {\n      services = services.sort((a, b) => {\n        const aScheme = utils.getProtocolScheme(a.serviceEndpoint)\n        const bScheme = utils.getProtocolScheme(b.serviceEndpoint)\n        return transportPriority?.schemes.indexOf(aScheme) - transportPriority?.schemes.indexOf(bScheme)\n      })\n    }\n\n    agentContext.config.logger.debug(\n      `Retrieved ${services.length} services for message to connection '${connection.id}'(${connection.theirLabel})'`,\n      { hasQueueService: queueService !== undefined, transportPriority }\n    )\n    return { services, queueService }\n  }\n\n  private emitMessageSentEvent(\n    outboundMessageContext: DidCommOutboundMessageContext,\n    status: OutboundMessageSendStatus\n  ) {\n    const { agentContext } = outboundMessageContext\n    this.eventEmitter.emit<DidCommMessageSentEvent>(agentContext, {\n      type: DidCommEventTypes.DidCommMessageSent,\n      payload: {\n        message: outboundMessageContext,\n        status,\n      },\n    })\n  }\n}\n\nexport function isDidCommTransportQueue(serviceEndpoint: string): serviceEndpoint is typeof DID_COMM_TRANSPORT_QUEUE {\n  return serviceEndpoint === DID_COMM_TRANSPORT_QUEUE\n}\n"],"mappings":"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"}