import { DidCommOutOfBandRole } from "./modules/oob/domain/DidCommOutOfBandRole.mjs";
import { ServiceDecorator } from "./decorators/service/ServiceDecorator.mjs";
import { DidCommInvitationType } from "./modules/oob/messages/DidCommOutOfBandInvitation.mjs";
import { DidCommOutOfBandRepository } from "./modules/oob/repository/DidCommOutOfBandRepository.mjs";
import { DidCommOutOfBandRecordMetadataKeys } from "./modules/oob/repository/outOfBandRecordMetadataTypes.mjs";
import { DidCommOutboundMessageContext } from "./models/DidCommOutboundMessageContext.mjs";
import "./models/index.mjs";
import { DidCommOutOfBandService } from "./modules/oob/DidCommOutOfBandService.mjs";
import { DidCommRoutingService } from "./modules/routing/services/DidCommRoutingService.mjs";
import "./modules/oob/index.mjs";
import "./modules/routing/index.mjs";
import { DidCommMessageRepository } from "./repository/DidCommMessageRepository.mjs";
import { DidCommMessageRole } from "./repository/DidCommMessageRole.mjs";
import "./repository/index.mjs";
import { CredoError, Kms, utils } from "@credo-ts/core";

//#region src/getDidCommOutboundMessageContext.ts
/**
* Maybe these methods should be moved to a service, but that would require
* extra injection in the sender functions, and I'm not 100% sure what would
* be the best place to host these.
*/
/**
* Get the outbound message context for a message. Will use the connection record if available,
* and otherwise try to create a connectionless message context.
*/
async function getOutboundDidCommMessageContext(agentContext, { message, connectionRecord, associatedRecord, lastReceivedMessage, lastSentMessage }) {
	if (connectionRecord) {
		agentContext.config.logger.debug(`Creating outbound message context for message ${message.id} with connection ${connectionRecord.id}`);
		return new DidCommOutboundMessageContext(message, {
			agentContext,
			associatedRecord,
			connection: connectionRecord
		});
	}
	if (!lastReceivedMessage) throw new CredoError("No connection record and no lastReceivedMessage was supplied. For connection-less exchanges the lastReceivedMessage is required.");
	if (!associatedRecord) throw new CredoError("No associated record was supplied. This is required for connection-less exchanges to store the associated ~service decorator on the message.");
	return getConnectionlessOutboundMessageContext(agentContext, {
		message,
		associatedRecord,
		lastReceivedMessage,
		lastSentMessage
	});
}
async function getConnectionlessOutboundMessageContext(agentContext, { message, lastReceivedMessage, lastSentMessage, associatedRecord }) {
	agentContext.config.logger.debug(`Creating outbound message context for message ${message.id} using connection-less exchange`);
	const outOfBandRecord = await getOutOfBandRecordForMessage(agentContext, message);
	let { recipientService, ourService } = await getServicesForMessage(agentContext, {
		lastReceivedMessage,
		lastSentMessage,
		message,
		outOfBandRecord
	});
	if (!lastSentMessage) ourService = await createOurService(agentContext, {
		outOfBandRecord,
		message
	});
	if (!ourService) throw new CredoError(`Could not determine our service for connection-less exchange for message ${message.id}.`);
	if (!recipientService) throw new CredoError(`Could not determine recipient service for connection-less exchange for message ${message.id}.`);
	await addExchangeDataToMessage(agentContext, {
		message,
		ourService,
		outOfBandRecord,
		associatedRecord
	});
	return new DidCommOutboundMessageContext(message, {
		agentContext,
		associatedRecord,
		serviceParams: {
			service: recipientService,
			senderKey: ourService.recipientKeys[0],
			returnRoute: true
		}
	});
}
/**
* Retrieves the out of band record associated with the message based on the thread id of the message.
*/
async function getOutOfBandRecordForMessage(agentContext, message) {
	agentContext.config.logger.debug(`Looking for out-of-band record for message ${message.id} with thread id ${message.threadId} and type ${message.type}`);
	return await agentContext.dependencyManager.resolve(DidCommOutOfBandRepository).findSingleByQuery(agentContext, { invitationRequestsThreadIds: [message.threadId] }) ?? void 0;
}
/**
* Returns the services to use for the message. When available it will extract the services from the
* lastSentMessage and lastReceivedMessage. If not available it will try to extract the services from
* the out of band record.
*
* If the required services and fields are not available, an error will be thrown.
*/
async function getServicesForMessage(agentContext, { lastSentMessage, lastReceivedMessage, message, outOfBandRecord }) {
	let ourService = lastSentMessage?.service?.resolvedDidCommService;
	let recipientService = lastReceivedMessage.service?.resolvedDidCommService;
	const outOfBandService = agentContext.dependencyManager.resolve(DidCommOutOfBandService);
	if (outOfBandRecord?.role === DidCommOutOfBandRole.Sender) {
		if (!ourService) ourService = await outOfBandService.getResolvedServiceForOutOfBandServices(agentContext, outOfBandRecord.outOfBandInvitation.getServices(), outOfBandRecord.invitationInlineServiceKeys);
		if (!recipientService) throw new CredoError("Could not find a service to send the message to. Please make sure the connection has a service or provide a service to send the message to.");
		if (!lastSentMessage) throw new CredoError("Must have lastSentMessage when out of band record has role Sender");
	} else if (outOfBandRecord?.role === DidCommOutOfBandRole.Receiver) {
		if (!recipientService) recipientService = await outOfBandService.getResolvedServiceForOutOfBandServices(agentContext, outOfBandRecord.outOfBandInvitation.getServices());
		if (lastSentMessage && !ourService) throw new CredoError("Could not find a service to send the message to. Please make sure the connection has a service or provide a service to send the message to.");
		const oobRecordRecipientRouting = outOfBandRecord?.metadata.get(DidCommOutOfBandRecordMetadataKeys.RecipientRouting);
		if (oobRecordRecipientRouting && ourService) ourService.recipientKeys[0].keyId = oobRecordRecipientRouting.recipientKeyId ?? ourService.recipientKeys[0].legacyKeyId;
	} else {
		if (lastSentMessage && !ourService) {
			agentContext.config.logger.error(`No out of band record associated and missing our service for connection-less exchange for message ${message.id}, while previous message has already been sent.`);
			throw new CredoError(`No out of band record associated and missing our service for connection-less exchange for message ${message.id}, while previous message has already been sent.`);
		}
		if (!recipientService) {
			agentContext.config.logger.error(`No out of band record associated and missing recipient service for connection-less exchange for message ${message.id}.`);
			throw new CredoError(`No out of band record associated and missing recipient service for connection-less exchange for message ${message.id}.`);
		}
	}
	return {
		ourService,
		recipientService
	};
}
/**
* Creates a new service for us as the sender to be used in a connection-less exchange.
*
* Will creating routing, which takes into account mediators, and will optionally extract
* routing configuration from the out of band record if available.
*/
async function createOurService(agentContext, { outOfBandRecord, message }) {
	agentContext.config.logger.debug(`No previous sent message in thread for outbound message ${message.id} with type ${message.type}, setting up routing`);
	let routing;
	const oobRecordRecipientRouting = outOfBandRecord?.metadata.get(DidCommOutOfBandRecordMetadataKeys.RecipientRouting);
	if (oobRecordRecipientRouting) {
		const recipientPublicJwk = Kms.PublicJwk.fromFingerprint(oobRecordRecipientRouting.recipientKeyFingerprint);
		recipientPublicJwk.keyId = oobRecordRecipientRouting.recipientKeyId ?? recipientPublicJwk.legacyKeyId;
		routing = {
			recipientKey: recipientPublicJwk,
			routingKeys: oobRecordRecipientRouting.routingKeyFingerprints.map((fingerprint) => Kms.PublicJwk.fromFingerprint(fingerprint)),
			endpoints: oobRecordRecipientRouting.endpoints,
			mediatorId: oobRecordRecipientRouting.mediatorId
		};
	}
	if (!routing) {
		routing = await agentContext.dependencyManager.resolve(DidCommRoutingService).getRouting(agentContext, { mediatorId: outOfBandRecord?.mediatorId });
		if (outOfBandRecord) {
			agentContext.config.logger.debug("Storing routing for out of band invitation.");
			outOfBandRecord.metadata.set(DidCommOutOfBandRecordMetadataKeys.RecipientRouting, {
				recipientKeyFingerprint: routing.recipientKey.fingerprint,
				recipientKeyId: routing.recipientKey.keyId,
				routingKeyFingerprints: routing.routingKeys.map((key) => key.fingerprint),
				endpoints: routing.endpoints,
				mediatorId: routing.mediatorId
			});
			outOfBandRecord.setTags({ recipientRoutingKeyFingerprint: routing.recipientKey.fingerprint });
			await agentContext.resolve(DidCommOutOfBandRepository).update(agentContext, outOfBandRecord);
		}
	}
	return {
		id: utils.uuid(),
		serviceEndpoint: routing.endpoints[0],
		recipientKeys: [routing.recipientKey],
		routingKeys: routing.routingKeys
	};
}
async function addExchangeDataToMessage(agentContext, { message, ourService, outOfBandRecord, associatedRecord }) {
	const legacyInvitationMetadata = outOfBandRecord?.metadata.get(DidCommOutOfBandRecordMetadataKeys.LegacyInvitation);
	if (outOfBandRecord && legacyInvitationMetadata?.legacyInvitationType !== DidCommInvitationType.Connectionless) if (!message.thread) message.setThread({ parentThreadId: outOfBandRecord.outOfBandInvitation.id });
	else message.thread.parentThreadId = outOfBandRecord.outOfBandInvitation.id;
	message.service = ServiceDecorator.fromResolvedDidCommService(ourService);
	await agentContext.dependencyManager.resolve(DidCommMessageRepository).saveOrUpdateAgentMessage(agentContext, {
		agentMessage: message,
		role: DidCommMessageRole.Sender,
		associatedRecordId: associatedRecord.id
	});
}

//#endregion
export { getOutboundDidCommMessageContext };
//# sourceMappingURL=getDidCommOutboundMessageContext.mjs.map