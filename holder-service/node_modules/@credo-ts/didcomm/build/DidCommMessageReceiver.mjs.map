{"version":3,"file":"DidCommMessageReceiver.mjs","names":[],"sources":["../src/DidCommMessageReceiver.ts"],"sourcesContent":["import type { AgentContext } from '@credo-ts/core'\nimport {\n  type AgentContextProvider,\n  CredoError,\n  InjectionSymbols,\n  inject,\n  injectable,\n  JsonTransformer,\n  type Logger,\n} from '@credo-ts/core'\nimport { DidCommDispatcher } from './DidCommDispatcher'\nimport type { DecryptedDidCommMessageContext } from './DidCommEnvelopeService'\nimport { DidCommEnvelopeService } from './DidCommEnvelopeService'\nimport { DidCommMessage } from './DidCommMessage'\nimport { DidCommMessageHandlerRegistry } from './DidCommMessageHandlerRegistry'\nimport { DidCommMessageSender } from './DidCommMessageSender'\nimport type { DidCommTransportSession } from './DidCommTransportService'\nimport { DidCommTransportService } from './DidCommTransportService'\nimport { DidCommProblemReportError } from './errors'\nimport { DidCommProblemReportMessage } from './messages'\nimport { DidCommInboundMessageContext, DidCommOutboundMessageContext, DidCommProblemReportReason } from './models'\nimport type { DidCommConnectionRecord } from './modules/connections/repository'\nimport { DidCommConnectionService } from './modules/connections/services'\nimport type { DidCommEncryptedMessage, DidCommPlaintextMessage } from './types'\nimport { isValidJweStructure } from './util/JWE'\nimport { canHandleMessageType, parseMessageType, replaceLegacyDidSovPrefixOnMessage } from './util/messageType'\n\n@injectable()\nexport class DidCommMessageReceiver {\n  private envelopeService: DidCommEnvelopeService\n  private transportService: DidCommTransportService\n  private messageSender: DidCommMessageSender\n  private dispatcher: DidCommDispatcher\n  private logger: Logger\n  private connectionService: DidCommConnectionService\n  private messageHandlerRegistry: DidCommMessageHandlerRegistry\n  private agentContextProvider: AgentContextProvider\n\n  public constructor(\n    envelopeService: DidCommEnvelopeService,\n    transportService: DidCommTransportService,\n    messageSender: DidCommMessageSender,\n    connectionService: DidCommConnectionService,\n    dispatcher: DidCommDispatcher,\n    messageHandlerRegistry: DidCommMessageHandlerRegistry,\n    @inject(InjectionSymbols.AgentContextProvider) agentContextProvider: AgentContextProvider,\n    @inject(InjectionSymbols.Logger) logger: Logger\n  ) {\n    this.envelopeService = envelopeService\n    this.transportService = transportService\n    this.messageSender = messageSender\n    this.connectionService = connectionService\n    this.dispatcher = dispatcher\n    this.messageHandlerRegistry = messageHandlerRegistry\n    this.agentContextProvider = agentContextProvider\n    this.logger = logger\n  }\n\n  /**\n   * Receive and handle an inbound DIDComm message. It will determine the agent context, decrypt the message, transform it\n   * to it's corresponding message class and finally dispatch it to the dispatcher.\n   *\n   * @param inboundMessage the message to receive and handle\n   */\n  public async receiveMessage(\n    inboundMessage: unknown,\n    {\n      session,\n      connection,\n      contextCorrelationId,\n      receivedAt,\n    }: {\n      session?: DidCommTransportSession\n      connection?: DidCommConnectionRecord\n      contextCorrelationId?: string\n      receivedAt?: Date\n    } = {}\n  ) {\n    this.logger.debug('Agent received message')\n\n    // Find agent context for the inbound message\n    const agentContext = await this.agentContextProvider.getContextForInboundMessage(inboundMessage, {\n      contextCorrelationId,\n    })\n\n    try {\n      if (this.isEncryptedMessage(inboundMessage)) {\n        await this.receiveEncryptedMessage(agentContext, inboundMessage as DidCommEncryptedMessage, session, receivedAt)\n      } else if (this.isPlaintextMessage(inboundMessage)) {\n        await this.receivePlaintextMessage(agentContext, inboundMessage, connection, receivedAt)\n      } else {\n        throw new CredoError('Unable to parse incoming message: unrecognized format')\n      }\n    } finally {\n      // Always end the session for the agent context after handling the message.\n      await agentContext.endSession()\n    }\n  }\n\n  private async receivePlaintextMessage(\n    agentContext: AgentContext,\n    plaintextMessage: DidCommPlaintextMessage,\n    connection?: DidCommConnectionRecord,\n    receivedAt?: Date\n  ) {\n    const message = await this.transformAndValidate(agentContext, plaintextMessage)\n    const messageContext = new DidCommInboundMessageContext(message, { connection, agentContext, receivedAt })\n    await this.dispatcher.dispatch(messageContext)\n  }\n\n  private async receiveEncryptedMessage(\n    agentContext: AgentContext,\n    encryptedMessage: DidCommEncryptedMessage,\n    session?: DidCommTransportSession,\n    receivedAt?: Date\n  ) {\n    const decryptedMessage = await this.decryptMessage(agentContext, encryptedMessage)\n    const { plaintextMessage, senderKey, recipientKey } = decryptedMessage\n\n    this.logger.info(\n      `Received message with type '${plaintextMessage['@type']}', recipient key ${recipientKey?.fingerprint} and sender key ${senderKey?.fingerprint}`,\n      plaintextMessage\n    )\n\n    const connection = await this.findConnectionByMessageKeys(agentContext, decryptedMessage)\n\n    const message = await this.transformAndValidate(agentContext, plaintextMessage, connection)\n\n    const messageContext = new DidCommInboundMessageContext(message, {\n      // Only make the connection available in message context if the connection is ready\n      // To prevent unwanted usage of unready connections. Connections can still be retrieved from\n      // Storage if the specific protocol allows an unready connection to be used.\n      connection: connection?.isReady ? connection : undefined,\n      senderKey,\n      recipientKey,\n      agentContext,\n      receivedAt,\n      encryptedMessage,\n    })\n\n    // We want to save a session if there is a chance of returning outbound message via inbound transport.\n    // That can happen when inbound message has `return_route` set to `all` or `thread`.\n    // If `return_route` defines just `thread`, we decide later whether to use session according to outbound message `threadId`.\n    if (senderKey && recipientKey && message.hasAnyReturnRoute() && session) {\n      this.logger.debug(`Storing session for inbound message '${message.id}'`)\n      const keys = {\n        recipientKeys: [senderKey],\n        routingKeys: [],\n        senderKey: recipientKey,\n      }\n      session.keys = keys\n      session.inboundMessage = message\n      // We allow unready connections to be attached to the session as we want to be able to\n      // use return routing to make connections. This is especially useful for creating connections\n      // with mediators when you don't have a public endpoint yet.\n      session.connectionId = connection?.id\n      messageContext.sessionId = session.id\n      this.transportService.saveSession(session)\n    } else if (session) {\n      // No need to wait for session to stay open if we're not actually going to respond to the message.\n      await session.close()\n    }\n\n    await this.dispatcher.dispatch(messageContext)\n  }\n\n  /**\n   * Decrypt a message using the envelope service.\n   *\n   * @param message the received inbound message to decrypt\n   */\n  private async decryptMessage(\n    agentContext: AgentContext,\n    message: DidCommEncryptedMessage\n  ): Promise<DecryptedDidCommMessageContext> {\n    try {\n      return await this.envelopeService.unpackMessage(agentContext, message)\n    } catch (error) {\n      this.logger.error('Error while decrypting message', {\n        error,\n        encryptedMessage: message,\n        errorMessage: error instanceof Error ? error.message : error,\n      })\n      throw error\n    }\n  }\n\n  private isPlaintextMessage(message: unknown): message is DidCommPlaintextMessage {\n    if (typeof message !== 'object' || message == null) {\n      return false\n    }\n    // If the message has a @type field we assume the message is in plaintext and it is not encrypted.\n    return '@type' in message\n  }\n\n  private isEncryptedMessage(message: unknown): message is DidCommEncryptedMessage {\n    // If the message does has valid JWE structure, we can assume the message is encrypted.\n    return isValidJweStructure(message)\n  }\n\n  private async transformAndValidate(\n    agentContext: AgentContext,\n    plaintextMessage: DidCommPlaintextMessage,\n    connection?: DidCommConnectionRecord | null\n  ): Promise<DidCommMessage> {\n    let message: DidCommMessage\n    try {\n      message = await this.transformMessage(plaintextMessage)\n    } catch (error) {\n      if (connection) await this.sendProblemReportMessage(agentContext, error.message, connection, plaintextMessage)\n      throw error\n    }\n    return message\n  }\n\n  private async findConnectionByMessageKeys(\n    agentContext: AgentContext,\n    { recipientKey, senderKey }: DecryptedDidCommMessageContext\n  ): Promise<DidCommConnectionRecord | null> {\n    // We only fetch connections that are sent in AuthCrypt mode\n    if (!recipientKey || !senderKey) return null\n\n    // Try to find the did records that holds the sender and recipient keys\n    return this.connectionService.findByKeys(agentContext, {\n      senderKey,\n      recipientKey,\n    })\n  }\n\n  /**\n   * Transform an plaintext DIDComm message into it's corresponding message class. Will look at all message types in the registered handlers.\n   *\n   * @param message the plaintext message for which to transform the message in to a class instance\n   */\n  private async transformMessage(message: DidCommPlaintextMessage): Promise<DidCommMessage> {\n    // replace did:sov:BzCbsNYhMrjHiqZDTUASHg;spec prefix for message type with https://didcomm.org\n    replaceLegacyDidSovPrefixOnMessage(message)\n\n    const messageType = message['@type']\n    const MessageClass = this.messageHandlerRegistry.getMessageClassForMessageType(messageType) ?? DidCommMessage\n\n    // Cast the plain JSON object to specific instance of Message extended from DidCommMessage\n    let messageTransformed: DidCommMessage\n    try {\n      messageTransformed = JsonTransformer.fromJSON(message, MessageClass)\n    } catch (error) {\n      this.logger.error(`Error validating message ${message['@type']}`, {\n        errors: error,\n        message: JSON.stringify(message),\n      })\n      throw new DidCommProblemReportError(`Error validating message ${message['@type']}`, {\n        problemCode: DidCommProblemReportReason.MessageParseFailure,\n      })\n    }\n    return messageTransformed\n  }\n\n  /**\n   * Send the problem report message (https://didcomm.org/notification/1.0/problem-report) to the recipient.\n   * @param message error message to send\n   * @param connection connection to send the message to\n   * @param plaintextMessage received inbound message\n   */\n  private async sendProblemReportMessage(\n    agentContext: AgentContext,\n    message: string,\n    connection: DidCommConnectionRecord,\n    plaintextMessage: DidCommPlaintextMessage\n  ) {\n    const messageType = parseMessageType(plaintextMessage['@type'])\n    if (canHandleMessageType(DidCommProblemReportMessage, messageType)) {\n      throw new CredoError(`Not sending problem report in response to problem report: ${message}`)\n    }\n    const problemReportMessage = new DidCommProblemReportMessage({\n      description: {\n        en: message,\n        code: DidCommProblemReportReason.MessageParseFailure,\n      },\n    })\n    problemReportMessage.setThread({\n      parentThreadId: plaintextMessage['@id'],\n    })\n    const outboundMessageContext = new DidCommOutboundMessageContext(problemReportMessage, { agentContext, connection })\n    if (outboundMessageContext) {\n      await this.messageSender.sendMessage(outboundMessageContext)\n    }\n  }\n}\n"],"mappings":"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"}