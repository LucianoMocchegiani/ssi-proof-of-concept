{"version":3,"file":"DefaultAgentContextProvider.mjs","names":[],"sources":["../../../src/agent/context/DefaultAgentContextProvider.ts"],"sourcesContent":["import { CredoError } from '../../error'\nimport { injectable } from '../../plugins'\nimport { AgentContext } from './AgentContext'\nimport type { AgentContextProvider } from './AgentContextProvider'\n\n/**\n * Default implementation of AgentContextProvider.\n *\n * Holds a single `AgentContext` instance that will be used for all messages, i.e. a\n * a single tenant agent.\n */\n@injectable()\nexport class DefaultAgentContextProvider implements AgentContextProvider {\n  private agentContext: AgentContext\n\n  public constructor(agentContext: AgentContext) {\n    this.agentContext = agentContext\n  }\n\n  public async getAgentContextForContextCorrelationId(contextCorrelationId: string): Promise<AgentContext> {\n    if (contextCorrelationId !== this.agentContext.contextCorrelationId) {\n      throw new CredoError(\n        `Could not get agent context for contextCorrelationId '${contextCorrelationId}'. Only contextCorrelationId '${this.agentContext.contextCorrelationId}' is supported.`\n      )\n    }\n\n    return this.agentContext\n  }\n\n  public async getContextForInboundMessage(\n    // We don't need to look at the message as we always use the same context in the default agent context provider\n    _: unknown,\n    options?: { contextCorrelationId?: string }\n  ): Promise<AgentContext> {\n    // This will throw an error if the contextCorrelationId does not match with the contextCorrelationId of the agent context property of this class.\n    if (options?.contextCorrelationId) {\n      return this.getAgentContextForContextCorrelationId(options.contextCorrelationId)\n    }\n\n    return this.agentContext\n  }\n\n  public async endSessionForAgentContext(agentContext: AgentContext) {\n    // Throw an error if the context correlation id does not match to prevent misuse.\n    if (agentContext.contextCorrelationId !== this.agentContext.contextCorrelationId) {\n      throw new CredoError(\n        `Could not end session for agent context with contextCorrelationId '${agentContext.contextCorrelationId}'. Only contextCorrelationId '${this.agentContext.contextCorrelationId}' is provided by this provider.`\n      )\n    }\n\n    // We won't dispose the agent context as we don't keep track of the total number of sessions for the root agent context.\n  }\n\n  public async deleteAgentContext(agentContext: AgentContext): Promise<void> {\n    // Throw an error if the context correlation id does not match to prevent misuse.\n    if (agentContext.contextCorrelationId !== this.agentContext.contextCorrelationId) {\n      throw new CredoError(\n        `Could not delete agent context with contextCorrelationId '${agentContext.contextCorrelationId}'. Only contextCorrelationId '${this.agentContext.contextCorrelationId}' is provided by this provider.`\n      )\n    }\n\n    await agentContext.dependencyManager.deleteAgentContext(agentContext)\n  }\n}\n"],"mappings":";;;;;;;;;;;AAYO,wCAAM,4BAA4D;CAGvE,AAAO,YAAY,cAA4B;AAC7C,OAAK,eAAe;;CAGtB,MAAa,uCAAuC,sBAAqD;AACvG,MAAI,yBAAyB,KAAK,aAAa,qBAC7C,OAAM,IAAI,WACR,yDAAyD,qBAAqB,gCAAgC,KAAK,aAAa,qBAAqB,iBACtJ;AAGH,SAAO,KAAK;;CAGd,MAAa,4BAEX,GACA,SACuB;AAEvB,MAAI,SAAS,qBACX,QAAO,KAAK,uCAAuC,QAAQ,qBAAqB;AAGlF,SAAO,KAAK;;CAGd,MAAa,0BAA0B,cAA4B;AAEjE,MAAI,aAAa,yBAAyB,KAAK,aAAa,qBAC1D,OAAM,IAAI,WACR,sEAAsE,aAAa,qBAAqB,gCAAgC,KAAK,aAAa,qBAAqB,iCAChL;;CAML,MAAa,mBAAmB,cAA2C;AAEzE,MAAI,aAAa,yBAAyB,KAAK,aAAa,qBAC1D,OAAM,IAAI,WACR,6DAA6D,aAAa,qBAAqB,gCAAgC,KAAK,aAAa,qBAAqB,iCACvK;AAGH,QAAM,aAAa,kBAAkB,mBAAmB,aAAa;;;0CAlDxE,YAAY"}