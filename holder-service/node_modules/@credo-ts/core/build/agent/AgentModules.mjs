

import { KeyManagementModule } from "../modules/kms/KeyManagementModule.mjs";
import "../modules/kms/index.mjs";
import { X509Module } from "../modules/x509/X509Module.mjs";
import "../modules/x509/index.mjs";
import { SingleContextStorageLruCache } from "../modules/cache/singleContextLruCache/SingleContextStorageLruCache.mjs";
import { CacheModule } from "../modules/cache/CacheModule.mjs";
import "../modules/cache/index.mjs";
import { DidsModule } from "../modules/dids/DidsModule.mjs";
import "../modules/dids/index.mjs";
import { W3cCredentialsModule } from "../modules/vc/W3cCredentialsModule.mjs";
import "../modules/vc/index.mjs";
import { MdocModule } from "../modules/mdoc/MdocModule.mjs";
import { SdJwtVcModule } from "../modules/sd-jwt-vc/SdJwtVcModule.mjs";
import "../modules/sd-jwt-vc/index.mjs";
import { DcqlModule } from "../modules/dcql/DcqlModule.mjs";
import { DifPresentationExchangeModule } from "../modules/dif-presentation-exchange/DifPresentationExchangeModule.mjs";
import "../modules/dif-presentation-exchange/index.mjs";
import { GenericRecordsModule } from "../modules/generic-records/GenericRecordsModule.mjs";
import "../modules/generic-records/index.mjs";

//#region src/agent/AgentModules.ts
/**
* Method to get the default agent modules to be registered on any agent instance. It doens't configure the modules in any way,
* and if that's needed the user needs to provide the module in the agent constructor
*/
function getDefaultAgentModules() {
	return {
		dcql: () => new DcqlModule(),
		genericRecords: () => new GenericRecordsModule(),
		dids: () => new DidsModule(),
		w3cCredentials: () => new W3cCredentialsModule(),
		cache: () => new CacheModule({ cache: new SingleContextStorageLruCache({ limit: 500 }) }),
		pex: () => new DifPresentationExchangeModule(),
		sdJwtVc: () => new SdJwtVcModule(),
		x509: () => new X509Module(),
		mdoc: () => new MdocModule(),
		kms: () => new KeyManagementModule({})
	};
}
/**
* Extend the provided modules object with the default agent modules. If the modules property already contains a module with the same
* name as a default module, the module won't be added to the extended module object. This allows users of the framework to override
* the modules with custom configuration. The agent constructor type ensures you can't provide a different module for a key that registered
* on the default agent.
*/
function extendModulesWithDefaultModules(modules) {
	const defaultAgentModules = getDefaultAgentModules();
	const defaultAgentModuleKeys = Object.keys(defaultAgentModules);
	const defaultModules = [];
	const customModules = Object.entries(modules ?? {}).filter(([key]) => !defaultAgentModuleKeys.includes(key));
	for (const [moduleKey, getConfiguredModule] of Object.entries(defaultAgentModules)) defaultModules.push([moduleKey, modules?.[moduleKey] ?? getConfiguredModule()]);
	return Object.fromEntries([...defaultModules, ...customModules]);
}
/**
* Get the agent api object based on the modules registered in the dependency manager. For each registered module on the
* dependency manager, the method will extract the api class from the module, resolve it and assign it to the module key
* as provided in the agent constructor (or the {@link getDefaultAgentModules} method).
*
* Modules that don't have an api class defined ({@link Module.api} is undefined) will be ignored and won't be added to the
* api object.
*
* If the api of a module is passed in the `excluded` array, the api will not be added to the resulting api object.
*
* @example
* If the dependency manager has the following modules configured:
* ```ts
* {
*   connections: DidCommConnectionsModule
*   indy: IndyModule
* }
* ```
*
* And we call the `getAgentApi` method like this:
* ```ts
* const api = getAgentApi(dependencyManager)
* ```
*
* the resulting agent api will look like:
*
* ```ts
* {
*   connections: ConnectionsApi
* }
* ```
*
* The `indy` module has been ignored because it doesn't define an api class.
*/
function getAgentApi(dependencyManager, excludedApis = []) {
	return Object.entries(dependencyManager.registeredModules).reduce((api, [moduleKey, module]) => {
		if (!module.api) return api;
		const apiInstance = dependencyManager.resolve(module.api);
		if (excludedApis.includes(apiInstance)) return api;
		return {
			...api,
			[moduleKey]: apiInstance
		};
	}, {});
}

//#endregion
export { extendModulesWithDefaultModules, getAgentApi };
//# sourceMappingURL=AgentModules.mjs.map