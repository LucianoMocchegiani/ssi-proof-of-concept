{"version":3,"file":"transformers.mjs","names":[],"sources":["../../src/utils/transformers.ts"],"sourcesContent":["import { Transform, TransformationType } from 'class-transformer'\nimport type { ValidationOptions } from 'class-validator'\nimport { buildMessage, isString, ValidateBy } from 'class-validator'\n\nimport { Metadata } from '../storage/Metadata'\n\n/*\n * Decorator that transforms to and from a metadata instance.\n */\nexport function MetadataTransformer() {\n  return Transform(({ value, type }) => {\n    if (type === TransformationType.CLASS_TO_PLAIN) {\n      return { ...value.data }\n    }\n\n    if (type === TransformationType.PLAIN_TO_CLASS) {\n      return new Metadata(value)\n    }\n\n    if (type === TransformationType.CLASS_TO_CLASS) {\n      return new Metadata({ ...value.data })\n    }\n  })\n}\n\n/**\n * Decorator that transforms to and from a date instance.\n */\nexport function DateTransformer() {\n  return Transform(({ value, type }) => {\n    if (value === undefined) return undefined\n    if (type === TransformationType.CLASS_TO_PLAIN) {\n      return value.toISOString()\n    }\n\n    if (type === TransformationType.PLAIN_TO_CLASS) {\n      return new Date(value)\n    }\n\n    if (type === TransformationType.CLASS_TO_CLASS) {\n      return new Date(value.getTime())\n    }\n  })\n}\n\n/**\n * Checks if a given value is a Map\n */\nexport function IsMap(validationOptions?: ValidationOptions): PropertyDecorator {\n  return ValidateBy(\n    {\n      name: 'isMap',\n      validator: {\n        validate: (value: unknown): boolean => value instanceof Map,\n        defaultMessage: buildMessage((eachPrefix) => `${eachPrefix}$property must be a Map`, validationOptions),\n      },\n    },\n    validationOptions\n  )\n}\n\n/**\n * Checks if a given value is a string or string array.\n */\nexport function IsStringOrStringArray(validationOptions?: Omit<ValidationOptions, 'each'>): PropertyDecorator {\n  return ValidateBy(\n    {\n      name: 'isStringOrStringArray',\n      validator: {\n        validate: (value): boolean => isString(value) || (Array.isArray(value) && value.every((v) => isString(v))),\n        defaultMessage: buildMessage(\n          (eachPrefix) => `${eachPrefix}$property must be a string or string array`,\n          validationOptions\n        ),\n      },\n    },\n    validationOptions\n  )\n}\n"],"mappings":";;;;;;;AASA,SAAgB,sBAAsB;AACpC,QAAO,WAAW,EAAE,OAAO,WAAW;AACpC,MAAI,SAAS,mBAAmB,eAC9B,QAAO,EAAE,GAAG,MAAM,MAAM;AAG1B,MAAI,SAAS,mBAAmB,eAC9B,QAAO,IAAI,SAAS,MAAM;AAG5B,MAAI,SAAS,mBAAmB,eAC9B,QAAO,IAAI,SAAS,EAAE,GAAG,MAAM,MAAM,CAAC;GAExC;;;;;AAMJ,SAAgB,kBAAkB;AAChC,QAAO,WAAW,EAAE,OAAO,WAAW;AACpC,MAAI,UAAU,OAAW,QAAO;AAChC,MAAI,SAAS,mBAAmB,eAC9B,QAAO,MAAM,aAAa;AAG5B,MAAI,SAAS,mBAAmB,eAC9B,QAAO,IAAI,KAAK,MAAM;AAGxB,MAAI,SAAS,mBAAmB,eAC9B,QAAO,IAAI,KAAK,MAAM,SAAS,CAAC;GAElC;;;;;AAsBJ,SAAgB,sBAAsB,mBAAwE;AAC5G,QAAO,WACL;EACE,MAAM;EACN,WAAW;GACT,WAAW,UAAmB,SAAS,MAAM,IAAK,MAAM,QAAQ,MAAM,IAAI,MAAM,OAAO,MAAM,SAAS,EAAE,CAAC;GACzG,gBAAgB,cACb,eAAe,GAAG,WAAW,6CAC9B,kBACD;GACF;EACF,EACD,kBACD"}