{"version":3,"file":"deepEquality.mjs","names":[],"sources":["../../src/utils/deepEquality.ts"],"sourcesContent":["import { areObjectsEqual } from './objectEquality'\n\n// biome-ignore lint/suspicious/noExplicitAny: no explanation\nexport function deepEquality(x: any, y: any): boolean {\n  // We do a simple equals here to check primitives, functions, regex, etc.\n  // This will only happen if the typing of the function is ignored\n  const isXSimpleEqualY = simpleEqual(x, y)\n  if (isXSimpleEqualY !== undefined) return isXSimpleEqualY\n\n  if (!(x instanceof Map) || !(y instanceof Map)) return areObjectsEqual(x, y)\n\n  const xMap = x as Map<string, unknown>\n  const yMap = y as Map<string, unknown>\n\n  // At this point we are sure we have two instances of a Map\n  const xKeys = Array.from(xMap.keys())\n  const yKeys = Array.from(yMap.keys())\n\n  // Keys from both maps are not equal, content has not been verified, yet\n  if (!equalsIgnoreOrder(xKeys, yKeys)) return false\n\n  // Here we recursively check whether the value of xMap is equals to the value of yMap\n  return Array.from(xMap.entries()).every(([key, xVal]) => deepEquality(xVal, yMap.get(key)))\n}\n\n/**\n * @note This will only work for primitive array equality\n */\nexport function equalsIgnoreOrder<Item = string>(a: Array<Item>, b: Array<Item>): boolean {\n  if (a.length !== b.length) return false\n  return a.every((k) => b.includes(k))\n}\n\n/**\n * @note This will only work for primitive array equality\n */\nexport function equalsWithOrder<Item = string>(lhs: Array<Item>, rhs: Array<Item>): boolean {\n  if (lhs.length !== rhs.length) return false\n  return lhs.every((k, i) => k === rhs[i])\n}\n\n// We take any here as we have to check some properties, they will be undefined if they do not exist\n// biome-ignore lint/suspicious/noExplicitAny: no explanation\nfunction simpleEqual(x: any, y: any) {\n  // short circuit for easy equality\n  if (x === y) return true\n\n  if ((x === null || x === undefined) && (y === null || y === undefined)) return x === y\n\n  // after this just checking type of one would be enough\n  if (x.constructor !== y.constructor) return false\n\n  // if they are functions, they should exactly refer to same one (because of closures)\n  if (x instanceof Function) return x === y\n\n  // if they are regexps, they should exactly refer to same one (it is hard to better equality check on current ES)\n  if (x instanceof RegExp) return x === y\n\n  if (x.valueOf && y.valueOf && x.valueOf() === y.valueOf()) return true\n\n  // if they are dates, they must had equal valueOf\n  if (x instanceof Date || y instanceof Date) return false\n}\n"],"mappings":";;;;;AAGA,SAAgB,aAAa,GAAQ,GAAiB;CAGpD,MAAM,kBAAkB,YAAY,GAAG,EAAE;AACzC,KAAI,oBAAoB,OAAW,QAAO;AAE1C,KAAI,EAAE,aAAa,QAAQ,EAAE,aAAa,KAAM,QAAO,gBAAgB,GAAG,EAAE;CAE5E,MAAM,OAAO;CACb,MAAM,OAAO;AAOb,KAAI,CAAC,kBAJS,MAAM,KAAK,KAAK,MAAM,CAAC,EACvB,MAAM,KAAK,KAAK,MAAM,CAAC,CAGD,CAAE,QAAO;AAG7C,QAAO,MAAM,KAAK,KAAK,SAAS,CAAC,CAAC,OAAO,CAAC,KAAK,UAAU,aAAa,MAAM,KAAK,IAAI,IAAI,CAAC,CAAC;;;;;AAM7F,SAAgB,kBAAiC,GAAgB,GAAyB;AACxF,KAAI,EAAE,WAAW,EAAE,OAAQ,QAAO;AAClC,QAAO,EAAE,OAAO,MAAM,EAAE,SAAS,EAAE,CAAC;;;;;AAMtC,SAAgB,gBAA+B,KAAkB,KAA2B;AAC1F,KAAI,IAAI,WAAW,IAAI,OAAQ,QAAO;AACtC,QAAO,IAAI,OAAO,GAAG,MAAM,MAAM,IAAI,GAAG;;AAK1C,SAAS,YAAY,GAAQ,GAAQ;AAEnC,KAAI,MAAM,EAAG,QAAO;AAEpB,MAAK,MAAM,QAAQ,MAAM,YAAe,MAAM,QAAQ,MAAM,QAAY,QAAO,MAAM;AAGrF,KAAI,EAAE,gBAAgB,EAAE,YAAa,QAAO;AAG5C,KAAI,aAAa,SAAU,QAAO,MAAM;AAGxC,KAAI,aAAa,OAAQ,QAAO,MAAM;AAEtC,KAAI,EAAE,WAAW,EAAE,WAAW,EAAE,SAAS,KAAK,EAAE,SAAS,CAAE,QAAO;AAGlE,KAAI,aAAa,QAAQ,aAAa,KAAM,QAAO"}