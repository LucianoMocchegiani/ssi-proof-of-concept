

import { asArray } from "./array.mjs";
import { ValidateBy, buildMessage, isInstance, isString } from "class-validator";

//#region src/utils/validators.ts
/**
* Checks if the value is a string or the specified instance
*/
function IsStringOrInstance(targetType, validationOptions) {
	return ValidateBy({
		name: "IsStringOrInstance",
		constraints: [targetType],
		validator: {
			validate: (value, args) => isString(value) || isInstance(value, args?.constraints[0]),
			defaultMessage: buildMessage((eachPrefix, args) => {
				if (args?.constraints[0]) return `${eachPrefix}$property must be of type string or instance of ${args.constraints[0].name}`;
				return `${eachPrefix}IsStringOrInstance decorator expects an object as value, but got falsy value.`;
			}, validationOptions)
		}
	}, validationOptions);
}
function IsInstanceOrArrayOfInstances(validationOptions) {
	const classTypes = asArray(validationOptions.classType);
	const allowEmptyArray = validationOptions.allowEmptyArray ?? false;
	return ValidateBy({
		name: "isInstanceOrArrayOfInstances",
		validator: {
			validate: (values) => {
				if (!values) return false;
				if (Array.isArray(values) && values.length === 0) return allowEmptyArray;
				return asArray(values).every((value) => classTypes.some((classType) => isInstance(value, classType)));
			},
			defaultMessage: buildMessage((eachPrefix) => `${eachPrefix}$property value must be an instance of, or an array of instances containing ${classTypes.map((c) => c.name).join(", ")}`, validationOptions)
		}
	}, validationOptions);
}
function IsStringOrInstanceOrArrayOfInstances(validationOptions) {
	const classTypes = asArray(validationOptions.classType);
	const allowEmptyArray = validationOptions.allowEmptyArray ?? false;
	return ValidateBy({
		name: "IsStringOrInstanceOrArrayOfInstances",
		validator: {
			validate: (values) => {
				if (isString(values)) return true;
				if (!values) return false;
				if (Array.isArray(values) && values.length === 0) return allowEmptyArray;
				return asArray(values).every((value) => classTypes.some((classType) => isInstance(value, classType)));
			},
			defaultMessage: buildMessage((eachPrefix) => `${eachPrefix}$property value must be a string, an instance of, or an array of instances containing ${classTypes.map((c) => c.name).join(", ")}`, validationOptions)
		}
	}, validationOptions);
}
const UriValidator = /\w+:(\/?\/?)[^\s]+/;
function isUri(value) {
	return UriValidator.test(value);
}
function IsUri(validationOptions) {
	return ValidateBy({
		name: "isUri",
		validator: {
			validate: (value) => isUri(value),
			defaultMessage: buildMessage((eachPrefix) => `${eachPrefix}$property must be an URI (that matches regex: ${UriValidator.source})`, validationOptions)
		}
	}, validationOptions);
}
function IsNever(validationOptions) {
	return ValidateBy({
		name: "IsNever",
		validator: {
			validate: (values) => typeof values === "undefined",
			defaultMessage: buildMessage((eachPrefix) => `${eachPrefix}$property is forbidden.`, validationOptions)
		}
	}, validationOptions);
}

//#endregion
export { IsInstanceOrArrayOfInstances, IsNever, IsStringOrInstance, IsStringOrInstanceOrArrayOfInstances, IsUri, UriValidator, isUri };
//# sourceMappingURL=validators.mjs.map