{"version":3,"file":"zod.mjs","names":[],"sources":["../../src/utils/zod.ts"],"sourcesContent":["import { z } from 'zod'\n\nimport { ZodValidationError } from '../error'\nimport type { AnyUint8Array } from '../types'\n\n// biome-ignore lint/suspicious/noExplicitAny: no explanation\nexport type zBaseSchema = z.Schema<any, any, any>\n\nexport function zParseWithErrorHandling<Schema extends zBaseSchema>(\n  schema: Schema,\n  data: unknown,\n  customErrorMessage?: string\n): z.output<Schema> {\n  const parseResult = schema.safeParse(data)\n\n  if (!parseResult.success) {\n    throw new ZodValidationError(\n      customErrorMessage ?? `Error validating schema with data ${JSON.stringify(data)}`,\n      parseResult.error\n    )\n  }\n\n  return parseResult.data\n}\n\nconst zUniqueArray = <const TItem extends zBaseSchema>(item: TItem) =>\n  z.array(item).refine((a) => new Set<(typeof a)[number]>(a).size === a.length, 'Array must have unique values')\n\nconst zOptionalToUndefined = <const TItem extends zBaseSchema>(item: TItem) =>\n  z.optional(item.transform(() => undefined))\n\nconst zBase64Url = z.string().regex(/[a-zA-Z0-9_-]+/, 'Must be a base64url string')\n\nconst zAnyUint8Array = z.instanceof<{ new (): AnyUint8Array }>(Uint8Array)\n\nexport { zUniqueArray, zOptionalToUndefined, zBase64Url, zAnyUint8Array }\n"],"mappings":";;;;;;;AAQA,SAAgB,wBACd,QACA,MACA,oBACkB;CAClB,MAAM,cAAc,OAAO,UAAU,KAAK;AAE1C,KAAI,CAAC,YAAY,QACf,OAAM,IAAI,mBACR,sBAAsB,qCAAqC,KAAK,UAAU,KAAK,IAC/E,YAAY,MACb;AAGH,QAAO,YAAY;;AAGrB,MAAM,gBAAiD,SACrD,EAAE,MAAM,KAAK,CAAC,QAAQ,MAAM,IAAI,IAAwB,EAAE,CAAC,SAAS,EAAE,QAAQ,gCAAgC;AAEhH,MAAM,wBAAyD,SAC7D,EAAE,SAAS,KAAK,gBAAgB,OAAU,CAAC;AAE7C,MAAM,aAAa,EAAE,QAAQ,CAAC,MAAM,kBAAkB,6BAA6B;AAEnF,MAAM,iBAAiB,EAAE,WAAsC,WAAW"}