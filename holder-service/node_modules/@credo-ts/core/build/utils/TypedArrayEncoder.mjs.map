{"version":3,"file":"TypedArrayEncoder.mjs","names":[],"sources":["../../src/utils/TypedArrayEncoder.ts"],"sourcesContent":["import type { AnyUint8Array, Uint8ArrayBuffer } from '../types'\nimport { decodeFromBase58, encodeToBase58 } from './base58'\nimport { base64ToBase64URL } from './base64'\nimport { Buffer } from './buffer'\n\n// biome-ignore lint/complexity/noStaticOnlyClass: no explanation\nexport class TypedArrayEncoder {\n  /**\n   * Encode buffer into base64 string.\n   *\n   * @param buffer the buffer to encode into base64 string\n   */\n  public static toBase64(buffer: Buffer | AnyUint8Array) {\n    return Buffer.from(buffer).toString('base64')\n  }\n\n  /**\n   * Encode buffer into base64url string.\n   *\n   * @param buffer the buffer to encode into base64url string\n   */\n  public static toBase64URL(buffer: Buffer | AnyUint8Array) {\n    return base64ToBase64URL(TypedArrayEncoder.toBase64(buffer))\n  }\n\n  /**\n   * Encode buffer into base58 string.\n   *\n   * @param buffer the buffer to encode into base58 string\n   */\n  public static toBase58(buffer: Buffer | AnyUint8Array) {\n    return encodeToBase58(buffer)\n  }\n\n  /**\n   * Decode base64 string into buffer. Also supports base64url\n   *\n   * @param base64 the base64 or base64url string to decode into buffer format\n   */\n  public static fromBase64(base64: string) {\n    return Buffer.from(base64, 'base64')\n  }\n\n  /**\n   * Decode base58 string into buffer\n   *\n   * @param base58 the base58 string to decode into buffer format\n   */\n  public static fromBase58(base58: string) {\n    return Buffer.from(decodeFromBase58(base58))\n  }\n\n  /**\n   * Encode buffer into base64 string.\n   *\n   * @param buffer the buffer to encode into base64 string\n   */\n  public static toHex(buffer: Buffer | AnyUint8Array) {\n    return Buffer.from(buffer).toString('hex')\n  }\n\n  /**\n   * Decode hex string into buffer\n   *\n   * @param hex the hex string to decode into buffer format\n   */\n  public static fromHex(hex: string) {\n    return Buffer.from(hex, 'hex')\n  }\n\n  /**\n   * Decode string into buffer.\n   *\n   * @param str the string to decode into buffer format\n   */\n  public static fromString(str: string): Uint8ArrayBuffer {\n    return Buffer.from(str)\n  }\n\n  public static toUtf8String(buffer: Buffer | AnyUint8Array) {\n    return Buffer.from(buffer).toString()\n  }\n\n  public static concat(entries: AnyUint8Array[]): Uint8ArrayBuffer {\n    return Buffer.concat(entries)\n  }\n\n  public static equals(firstBuffer: AnyUint8Array, otherBuffer: AnyUint8Array): boolean {\n    return Buffer.from(firstBuffer).equals(otherBuffer)\n  }\n\n  /**\n   * Check whether an array is byte, or typed, array\n   *\n   * @param array unknown The array that has to be checked\n   *\n   * @returns A boolean if the array is a byte array\n   */\n  public static isTypedArray(array: unknown): boolean {\n    // Checks whether the static property 'BYTES_PER_ELEMENT' exists on the provided array.\n    // This has to be done, since the TypedArrays, e.g. Uint8Array and Float32Array, do not\n    // extend a single base class\n    return 'BYTES_PER_ELEMENT' in (array as Record<string, unknown>)\n  }\n}\n"],"mappings":";;;;;;;AAMA,IAAa,oBAAb,MAAa,kBAAkB;;;;;;CAM7B,OAAc,SAAS,QAAgC;AACrD,SAAO,OAAO,KAAK,OAAO,CAAC,SAAS,SAAS;;;;;;;CAQ/C,OAAc,YAAY,QAAgC;AACxD,SAAO,kBAAkB,kBAAkB,SAAS,OAAO,CAAC;;;;;;;CAQ9D,OAAc,SAAS,QAAgC;AACrD,SAAO,eAAe,OAAO;;;;;;;CAQ/B,OAAc,WAAW,QAAgB;AACvC,SAAO,OAAO,KAAK,QAAQ,SAAS;;;;;;;CAQtC,OAAc,WAAW,QAAgB;AACvC,SAAO,OAAO,KAAK,iBAAiB,OAAO,CAAC;;;;;;;CAQ9C,OAAc,MAAM,QAAgC;AAClD,SAAO,OAAO,KAAK,OAAO,CAAC,SAAS,MAAM;;;;;;;CAQ5C,OAAc,QAAQ,KAAa;AACjC,SAAO,OAAO,KAAK,KAAK,MAAM;;;;;;;CAQhC,OAAc,WAAW,KAA+B;AACtD,SAAO,OAAO,KAAK,IAAI;;CAGzB,OAAc,aAAa,QAAgC;AACzD,SAAO,OAAO,KAAK,OAAO,CAAC,UAAU;;CAGvC,OAAc,OAAO,SAA4C;AAC/D,SAAO,OAAO,OAAO,QAAQ;;CAG/B,OAAc,OAAO,aAA4B,aAAqC;AACpF,SAAO,OAAO,KAAK,YAAY,CAAC,OAAO,YAAY;;;;;;;;;CAUrD,OAAc,aAAa,OAAyB;AAIlD,SAAO,uBAAwB"}