{"version":3,"file":"MultiHashEncoder.mjs","names":[],"sources":["../../src/utils/MultiHashEncoder.ts"],"sourcesContent":["import type { HashName } from '../crypto/hashes'\n\nimport { Hasher } from '../crypto/hashes'\nimport type { AnyUint8Array, Uint8ArrayBuffer } from '../types'\nimport { TypedArrayEncoder } from './TypedArrayEncoder'\nimport { VarintEncoder } from './VarintEncoder'\n\ntype MultiHashNameMap = {\n  [key in HashName]: number\n}\n\ntype MultiHashCodeMap = {\n  [key: number]: HashName\n}\n\nconst multiHashNameMap: MultiHashNameMap = {\n  'sha-1': 0x11,\n  'sha-256': 0x12,\n  'sha-512': 0x13,\n  'sha-384': 0x20,\n}\n\nconst multiHashCodeMap: MultiHashCodeMap = Object.entries(multiHashNameMap).reduce(\n  // biome-ignore lint/performance/noAccumulatingSpread: no explanation\n  (map, [hashName, hashCode]) => ({ ...map, [hashCode]: hashName }),\n  {}\n)\n\n// biome-ignore lint/complexity/noStaticOnlyClass: no explanation\nexport class MultiHashEncoder {\n  /**\n   *\n   * Encodes a buffer into a hash\n   *\n   * @param buffer the buffer that has to be encoded\n   * @param hashName the hashing algorithm, 'sha-256'\n   *\n   * @returns a multihash\n   */\n  public static encode(data: AnyUint8Array, hashName: HashName): Uint8ArrayBuffer {\n    const hash = Hasher.hash(data, hashName)\n    const hashCode = multiHashNameMap[hashName]\n\n    const hashPrefix = VarintEncoder.encode(hashCode)\n    const hashLengthPrefix = VarintEncoder.encode(hash.length)\n\n    return TypedArrayEncoder.concat([hashPrefix, hashLengthPrefix, hash])\n  }\n\n  /**\n   *\n   * Decodes the multihash\n   *\n   * @param data the multihash that has to be decoded\n   *\n   * @returns object with the data and the hashing algorithm\n   */\n  public static decode(data: AnyUint8Array): { data: Uint8ArrayBuffer; hashName: string } {\n    const [hashPrefix, hashPrefixByteLength] = VarintEncoder.decode(data)\n    const withoutHashPrefix = data.slice(hashPrefixByteLength)\n\n    const [, lengthPrefixByteLength] = VarintEncoder.decode(withoutHashPrefix)\n    const withoutLengthPrefix = withoutHashPrefix.slice(lengthPrefixByteLength)\n\n    const hashName = multiHashCodeMap[hashPrefix]\n\n    if (!hashName) {\n      throw new Error(`Unsupported hash code 0x${hashPrefix.toString(16)}`)\n    }\n\n    return {\n      data: new Uint8Array(withoutLengthPrefix),\n      hashName: multiHashCodeMap[hashPrefix],\n    }\n  }\n\n  /**\n   *\n   * Validates if it is a valid mulithash\n   *\n   * @param data the multihash that needs to be validated\n   *\n   * @returns a boolean whether the multihash is valid\n   */\n  public static isValid(data: AnyUint8Array): boolean {\n    try {\n      MultiHashEncoder.decode(data)\n      return true\n    } catch (_e) {\n      return false\n    }\n  }\n}\n"],"mappings":";;;;;;;;AAeA,MAAM,mBAAqC;CACzC,SAAS;CACT,WAAW;CACX,WAAW;CACX,WAAW;CACZ;AAED,MAAM,mBAAqC,OAAO,QAAQ,iBAAiB,CAAC,QAEzE,KAAK,CAAC,UAAU,eAAe;CAAE,GAAG;EAAM,WAAW;CAAU,GAChE,EAAE,CACH;AAGD,IAAa,mBAAb,MAAa,iBAAiB;;;;;;;;;;CAU5B,OAAc,OAAO,MAAqB,UAAsC;EAC9E,MAAM,OAAO,OAAO,KAAK,MAAM,SAAS;EACxC,MAAM,WAAW,iBAAiB;EAElC,MAAM,aAAa,cAAc,OAAO,SAAS;EACjD,MAAM,mBAAmB,cAAc,OAAO,KAAK,OAAO;AAE1D,SAAO,kBAAkB,OAAO;GAAC;GAAY;GAAkB;GAAK,CAAC;;;;;;;;;;CAWvE,OAAc,OAAO,MAAmE;EACtF,MAAM,CAAC,YAAY,wBAAwB,cAAc,OAAO,KAAK;EACrE,MAAM,oBAAoB,KAAK,MAAM,qBAAqB;EAE1D,MAAM,GAAG,0BAA0B,cAAc,OAAO,kBAAkB;EAC1E,MAAM,sBAAsB,kBAAkB,MAAM,uBAAuB;AAI3E,MAAI,CAFa,iBAAiB,YAGhC,OAAM,IAAI,MAAM,2BAA2B,WAAW,SAAS,GAAG,GAAG;AAGvE,SAAO;GACL,MAAM,IAAI,WAAW,oBAAoB;GACzC,UAAU,iBAAiB;GAC5B;;;;;;;;;;CAWH,OAAc,QAAQ,MAA8B;AAClD,MAAI;AACF,oBAAiB,OAAO,KAAK;AAC7B,UAAO;WACA,IAAI;AACX,UAAO"}