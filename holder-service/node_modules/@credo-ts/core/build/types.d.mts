import { Logger } from "./logger/Logger.mjs";
import { Ed25519PublicJwk } from "./modules/kms/jwk/kty/okp/Ed25519PublicJwk.mjs";
import { PublicJwk } from "./modules/kms/jwk/PublicJwk.mjs";
import "./modules/kms/index.mjs";

//#region src/types.d.ts
interface InitConfig {
  logger?: Logger;
  autoUpdateStorageOnStartup?: boolean;
  /**
   * Allow insecure http urls in places where this is usually required.
   * Unsecure http urls may still be allowed in places where this is not checked (e.g. didcomm)
   *
   * For some flows this config option is set globally, which means that different agent configurations
   * will fight for the configuration. It is meant as a local development option.
   *
   * Use with caution
   *
   * @default false
   */
  allowInsecureHttpUrls?: boolean;
  /**
   * The allowed skew in seconds that should be allowed for validity time of a credentials and other signed
   * objects (e.g. StatusList). Mobile devices especially can run a bit behind actual time, making validity
   * checks fail based on a milliseconds / seconds.
   *
   * NOTE: this does currently only affects JWT based objects and credentials:
   * - Token Status List
   * - SD-JWT VC
   * - W3C VCDM 1.1 and 2.0 with JWT/SD-JWT
   *
   * It does not cover
   * - W3C VCDM 1.1 JSON-LD
   * - mDOC
   *
   * @default 30
   */
  validitySkewSeconds?: number;
}
type JsonValue = string | number | boolean | null | JsonObject | JsonArray;
type JsonArray = Array<JsonValue>;
interface JsonObject {
  [property: string]: JsonValue;
}
/**
 * Typescript 5.7/5.9 made the Uint8Array generic. This causes a lot of type errors
 * and is also not backwards compatible with older TypeScript versions.
 *
 * This type util infers the return type, so that in older versions the non generic
 * Uint8Array is used, and in newer version the generic Uint8Array is used.
 *
 * See https://github.com/microsoft/typescript/issues/62240
 */
type Uint8ArrayBuffer = ReturnType<typeof Uint8Array.from>;
type AnyUint8Array = Uint8Array;
/**
 * Create an exclusive or, setting the other params to 'never' which helps with
 * type narrowing
 *
 * @example
 * ```
 * type Options = XOR<{ name: string }, { dateOfBirth: Date }>
 *
 * type Options =
 *  | { name: string; dateOfBirth?: never }
 *  | { name?: never; dateOfBirth: Date }
 * ```
 */
type XOR<T, U> = (T & { [P in keyof Omit<U, keyof T>]?: never }) | (U & { [P in keyof Omit<T, keyof U>]?: never });
interface ResolvedDidCommService {
  id: string;
  serviceEndpoint: string;
  recipientKeys: PublicJwk<Ed25519PublicJwk>[];
  routingKeys: PublicJwk<Ed25519PublicJwk>[];
}
declare const isJsonObject: (value: unknown) => value is JsonObject;
type SingleOrArray<T> = T | T[];
type Optional<T, K extends keyof T> = Pick<Partial<T>, K> & Omit<T, K>;
type CanBePromise<T> = T | Promise<T>;
type NonEmptyArray<T> = [T, ...T[]];
declare function mapNonEmptyArray<U, M extends (item: U, index: number) => unknown>(array: NonEmptyArray<U>, mapFunction: M): NonEmptyArray<ReturnType<M>>;
declare function isNonEmptyArray<U>(array: U[]): array is NonEmptyArray<U>;
//#endregion
export { AnyUint8Array, CanBePromise, InitConfig, JsonArray, JsonObject, JsonValue, NonEmptyArray, Optional, ResolvedDidCommService, SingleOrArray, Uint8ArrayBuffer, XOR, isJsonObject, isNonEmptyArray, mapNonEmptyArray };
//# sourceMappingURL=types.d.mts.map