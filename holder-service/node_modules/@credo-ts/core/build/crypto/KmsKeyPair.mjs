

import { CredoError } from "../error/CredoError.mjs";
import "../error/index.mjs";
import { MessageValidator } from "../utils/MessageValidator.mjs";
import { JsonTransformer } from "../utils/JsonTransformer.mjs";
import "../utils/index.mjs";
import "../agent/index.mjs";
import { KeyManagementApi } from "../modules/kms/KeyManagementApi.mjs";
import "../modules/kms/index.mjs";
import { VerificationMethod } from "../modules/dids/domain/verificationMethod/VerificationMethod.mjs";
import { getPublicJwkFromVerificationMethod } from "../modules/dids/domain/key-type/keyDidMapping.mjs";
import "../modules/dids/index.mjs";
import { LdKeyPair } from "../modules/vc/data-integrity/models/LdKeyPair.mjs";

//#region src/crypto/KmsKeyPair.ts
function createKmsKeyPairClass(agentContext) {
	return class KmsKeyPair extends LdKeyPair {
		constructor(options) {
			super(options);
			this.type = "KmsKeyPair";
			this.publicJwk = options.publicJwk;
		}
		static async generate() {
			throw new Error("Not implemented");
		}
		fingerprint() {
			throw new Error("Method not implemented.");
		}
		verifyFingerprint(_fingerprint) {
			throw new Error("Method not implemented.");
		}
		static async from(verificationMethod) {
			const vMethod = JsonTransformer.fromJSON(verificationMethod, VerificationMethod);
			MessageValidator.validateSync(vMethod);
			const publicJwk = getPublicJwkFromVerificationMethod(vMethod);
			return new KmsKeyPair({
				id: vMethod.id,
				controller: vMethod.controller,
				publicJwk
			});
		}
		/**
		* This method returns a wrapped wallet.sign method. The method is being wrapped so we can covert between Uint8Array and Buffer. This is to make it compatible with the external signature libraries.
		*/
		signer() {
			const wrappedSign = async (data) => {
				if (Array.isArray(data.data)) throw new CredoError("Signing array of data entries is not supported");
				return (await agentContext.dependencyManager.resolve(KeyManagementApi).sign({
					data: data.data,
					keyId: this.publicJwk.keyId,
					algorithm: this.publicJwk.signatureAlgorithm
				})).signature;
			};
			return { sign: wrappedSign.bind(this) };
		}
		/**
		* This method returns a wrapped wallet.verify method. The method is being wrapped so we can covert between Uint8Array and Buffer. This is to make it compatible with the external signature libraries.
		*/
		verifier() {
			const wrappedVerify = async (data) => {
				if (Array.isArray(data.data)) throw new CredoError("Verifying array of data entries is not supported");
				const { verified } = await agentContext.dependencyManager.resolve(KeyManagementApi).verify({
					data: data.data,
					signature: data.signature,
					key: { publicJwk: this.publicJwk.toJson() },
					algorithm: this.publicJwk.signatureAlgorithm
				});
				return verified;
			};
			return { verify: wrappedVerify.bind(this) };
		}
		get publicKeyBuffer() {
			const publicKey = this.publicJwk.publicKey;
			if (publicKey.kty === "RSA") throw new CredoError(`kty 'RSA' not supported for publicKeyBuffer`);
			return publicKey.publicKey;
		}
	};
}

//#endregion
export { createKmsKeyPairClass };
//# sourceMappingURL=KmsKeyPair.mjs.map