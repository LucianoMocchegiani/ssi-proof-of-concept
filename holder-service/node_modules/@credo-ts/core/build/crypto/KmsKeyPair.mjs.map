{"version":3,"file":"KmsKeyPair.mjs","names":[],"sources":["../../src/crypto/KmsKeyPair.ts"],"sourcesContent":["import { AgentContext } from '../agent'\nimport { CredoError } from '../error'\nimport { VerificationMethod } from '../modules/dids'\nimport { getPublicJwkFromVerificationMethod } from '../modules/dids/domain/key-type/keyDidMapping'\nimport { KeyManagementApi, PublicJwk } from '../modules/kms'\nimport type { LdKeyPairOptions } from '../modules/vc/data-integrity/models/LdKeyPair'\nimport { LdKeyPair } from '../modules/vc/data-integrity/models/LdKeyPair'\nimport type { AnyUint8Array, Uint8ArrayBuffer } from '../types'\nimport { JsonTransformer, MessageValidator } from '../utils'\n\ninterface KmsKeyPairOptions extends LdKeyPairOptions {\n  publicJwk: PublicJwk\n}\n\nexport function createKmsKeyPairClass(agentContext: AgentContext) {\n  return class KmsKeyPair extends LdKeyPair {\n    public publicJwk: PublicJwk\n    public type = 'KmsKeyPair'\n\n    public constructor(options: KmsKeyPairOptions) {\n      super(options)\n      this.publicJwk = options.publicJwk\n    }\n\n    public static async generate(): Promise<KmsKeyPair> {\n      throw new Error('Not implemented')\n    }\n\n    public fingerprint(): string {\n      throw new Error('Method not implemented.')\n    }\n\n    public verifyFingerprint(_fingerprint: string): boolean {\n      throw new Error('Method not implemented.')\n    }\n\n    public static async from(verificationMethod: VerificationMethod): Promise<KmsKeyPair> {\n      const vMethod = JsonTransformer.fromJSON(verificationMethod, VerificationMethod)\n      MessageValidator.validateSync(vMethod)\n      const publicJwk = getPublicJwkFromVerificationMethod(vMethod)\n\n      return new KmsKeyPair({\n        id: vMethod.id,\n        controller: vMethod.controller,\n        publicJwk,\n      })\n    }\n\n    /**\n     * This method returns a wrapped wallet.sign method. The method is being wrapped so we can covert between Uint8Array and Buffer. This is to make it compatible with the external signature libraries.\n     */\n    public signer(): { sign: (data: { data: AnyUint8Array | AnyUint8Array[] }) => Promise<Uint8ArrayBuffer> } {\n      // wrap function for conversion\n      const wrappedSign = async (data: { data: AnyUint8Array | AnyUint8Array[] }): Promise<Uint8ArrayBuffer> => {\n        if (Array.isArray(data.data)) {\n          throw new CredoError('Signing array of data entries is not supported')\n        }\n        const kms = agentContext.dependencyManager.resolve(KeyManagementApi)\n\n        const result = await kms.sign({\n          data: data.data,\n          keyId: this.publicJwk.keyId,\n          algorithm: this.publicJwk.signatureAlgorithm,\n        })\n\n        return result.signature\n      }\n\n      return {\n        sign: wrappedSign.bind(this),\n      }\n    }\n\n    /**\n     * This method returns a wrapped wallet.verify method. The method is being wrapped so we can covert between Uint8Array and Buffer. This is to make it compatible with the external signature libraries.\n     */\n    public verifier(): {\n      verify: (data: { data: AnyUint8Array | AnyUint8Array[]; signature: AnyUint8Array }) => Promise<boolean>\n    } {\n      const wrappedVerify = async (data: {\n        data: AnyUint8Array | AnyUint8Array[]\n        signature: AnyUint8Array\n      }): Promise<boolean> => {\n        if (Array.isArray(data.data)) {\n          throw new CredoError('Verifying array of data entries is not supported')\n        }\n        const kms = agentContext.dependencyManager.resolve(KeyManagementApi)\n\n        const { verified } = await kms.verify({\n          data: data.data,\n          signature: data.signature,\n          key: {\n            publicJwk: this.publicJwk.toJson(),\n          },\n          algorithm: this.publicJwk.signatureAlgorithm,\n        })\n\n        return verified\n      }\n      return {\n        verify: wrappedVerify.bind(this),\n      }\n    }\n\n    public get publicKeyBuffer(): Uint8ArrayBuffer {\n      const publicKey = this.publicJwk.publicKey\n\n      if (publicKey.kty === 'RSA') {\n        throw new CredoError(`kty 'RSA' not supported for publicKeyBuffer`)\n      }\n\n      return publicKey.publicKey as Uint8ArrayBuffer\n    }\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;AAcA,SAAgB,sBAAsB,cAA4B;AAChE,QAAO,MAAM,mBAAmB,UAAU;EAIxC,AAAO,YAAY,SAA4B;AAC7C,SAAM,QAAQ;QAHT,OAAO;AAIZ,QAAK,YAAY,QAAQ;;EAG3B,aAAoB,WAAgC;AAClD,SAAM,IAAI,MAAM,kBAAkB;;EAGpC,AAAO,cAAsB;AAC3B,SAAM,IAAI,MAAM,0BAA0B;;EAG5C,AAAO,kBAAkB,cAA+B;AACtD,SAAM,IAAI,MAAM,0BAA0B;;EAG5C,aAAoB,KAAK,oBAA6D;GACpF,MAAM,UAAU,gBAAgB,SAAS,oBAAoB,mBAAmB;AAChF,oBAAiB,aAAa,QAAQ;GACtC,MAAM,YAAY,mCAAmC,QAAQ;AAE7D,UAAO,IAAI,WAAW;IACpB,IAAI,QAAQ;IACZ,YAAY,QAAQ;IACpB;IACD,CAAC;;;;;EAMJ,AAAO,SAAmG;GAExG,MAAM,cAAc,OAAO,SAA+E;AACxG,QAAI,MAAM,QAAQ,KAAK,KAAK,CAC1B,OAAM,IAAI,WAAW,iDAAiD;AAUxE,YANe,MAFH,aAAa,kBAAkB,QAAQ,iBAAiB,CAE3C,KAAK;KAC5B,MAAM,KAAK;KACX,OAAO,KAAK,UAAU;KACtB,WAAW,KAAK,UAAU;KAC3B,CAAC,EAEY;;AAGhB,UAAO,EACL,MAAM,YAAY,KAAK,KAAK,EAC7B;;;;;EAMH,AAAO,WAEL;GACA,MAAM,gBAAgB,OAAO,SAGL;AACtB,QAAI,MAAM,QAAQ,KAAK,KAAK,CAC1B,OAAM,IAAI,WAAW,mDAAmD;IAI1E,MAAM,EAAE,aAAa,MAFT,aAAa,kBAAkB,QAAQ,iBAAiB,CAErC,OAAO;KACpC,MAAM,KAAK;KACX,WAAW,KAAK;KAChB,KAAK,EACH,WAAW,KAAK,UAAU,QAAQ,EACnC;KACD,WAAW,KAAK,UAAU;KAC3B,CAAC;AAEF,WAAO;;AAET,UAAO,EACL,QAAQ,cAAc,KAAK,KAAK,EACjC;;EAGH,IAAW,kBAAoC;GAC7C,MAAM,YAAY,KAAK,UAAU;AAEjC,OAAI,UAAU,QAAQ,MACpB,OAAM,IAAI,WAAW,8CAA8C;AAGrE,UAAO,UAAU"}