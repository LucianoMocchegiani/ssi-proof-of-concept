import { KnownJwaSignatureAlgorithm } from "../modules/kms/jwk/jwa.mjs";
import { AnyUint8Array } from "../types.mjs";
import { EncodedX509Certificate } from "../modules/x509/X509ServiceOptions.mjs";
import { JwtPayload } from "./jose/jwt/JwtPayload.mjs";
import "../modules/x509/index.mjs";
import { JwsSigner, JwsSignerWithJwk } from "./JwsSigner.mjs";
import { Jws, JwsDetachedFormat, JwsFlattenedFormat, JwsGeneralFormat, JwsProtectedHeaderOptions } from "./JwsTypes.mjs";
import "./jose/jwt/index.mjs";
import "../modules/kms/index.mjs";
import { AgentContext } from "../agent/context/AgentContext.mjs";
import "../agent/index.mjs";

//#region src/crypto/JwsService.d.ts
declare class JwsService {
  private createJwsBase;
  createJws(agentContext: AgentContext, {
    payload,
    keyId,
    header,
    protectedHeaderOptions
  }: CreateJwsOptions): Promise<JwsGeneralFormat>;
  /**
   *  @see {@link https://www.rfc-editor.org/rfc/rfc7515#section-3.1}
   * */
  createJwsCompact(agentContext: AgentContext, {
    payload,
    keyId,
    protectedHeaderOptions
  }: CreateCompactJwsOptions): Promise<string>;
  /**
   * Verify a JWS
   */
  verifyJws(agentContext: AgentContext, {
    jws,
    resolveJwsSigner,
    trustedCertificates,
    jwsSigner: expectedJwsSigner,
    allowedJwsSignerMethods
  }: VerifyJwsOptions): Promise<VerifyJwsResult>;
  private buildProtected;
  private verifyJwsSigner;
  private jwsSignerFromJws;
}
interface CreateJwsOptions {
  payload: AnyUint8Array | JwtPayload;
  keyId: string;
  header: Record<string, unknown>;
  protectedHeaderOptions: JwsProtectedHeaderOptions;
}
type CreateCompactJwsOptions = Omit<CreateJwsOptions, 'header'>;
interface VerifyJwsOptions {
  jws: Jws;
  /**
   * The expected signer of the JWS. If provided the signer won't be dynamically
   * detected based on the values in the JWS.
   */
  jwsSigner?: JwsSignerWithJwk;
  /**
   * Allowed jws signer methods when dynamically inferring the jws signer method.
   */
  allowedJwsSignerMethods?: JwsSigner['method'][];
  resolveJwsSigner?: JwsSignerResolver;
  trustedCertificates?: EncodedX509Certificate[];
}
type JwsSignerResolver = (options: {
  jws: JwsDetachedFormat;
  payload: string;
  protectedHeader: {
    alg: KnownJwaSignatureAlgorithm;
    jwk?: string;
    kid?: string;
    [key: string]: unknown;
  };
}) => Promise<JwsSignerWithJwk> | JwsSignerWithJwk;
interface VerifyJwsResult {
  isValid: boolean;
  jwsSigners: JwsSignerWithJwk[];
  jws: JwsFlattenedFormat;
}
//#endregion
export { JwsService };
//# sourceMappingURL=JwsService.d.mts.map