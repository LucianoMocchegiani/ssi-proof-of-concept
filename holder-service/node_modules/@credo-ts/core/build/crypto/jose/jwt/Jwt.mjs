

import { CredoError } from "../../../error/CredoError.mjs";
import "../../../error/index.mjs";
import { TypedArrayEncoder } from "../../../utils/TypedArrayEncoder.mjs";
import { JsonEncoder } from "../../../utils/JsonEncoder.mjs";
import "../../../utils/index.mjs";
import { JwtPayload } from "./JwtPayload.mjs";
import { replaceError } from "../../../logger/replaceError.mjs";

//#region src/crypto/jose/jwt/Jwt.ts
var Jwt = class Jwt {
	constructor(options) {
		this.serializedJwt = options.serializedJwt;
		this.payload = options.payload;
		this.header = options.header;
		this.signature = options.signature;
	}
	static fromSerializedJwt(serializedJwt) {
		if (typeof serializedJwt !== "string" || !Jwt.format.test(serializedJwt)) throw new CredoError(`Invalid JWT. '${serializedJwt}' does not match JWT regex`);
		const [header, payload, signature] = serializedJwt.split(".");
		try {
			return new Jwt({
				header: JsonEncoder.fromBase64(header),
				payload: JwtPayload.fromJson(JsonEncoder.fromBase64(payload)),
				signature: TypedArrayEncoder.fromBase64(signature),
				serializedJwt
			});
		} catch (error) {
			throw new CredoError(`Invalid JWT. ${error instanceof Error ? error.message : JSON.stringify(error, replaceError)}`);
		}
	}
};
Jwt.format = /^[A-Za-z0-9-_=]+\.[A-Za-z0-9-_=]+\.?[A-Za-z0-9-_.+/=]*$/;

//#endregion
export { Jwt };
//# sourceMappingURL=Jwt.mjs.map