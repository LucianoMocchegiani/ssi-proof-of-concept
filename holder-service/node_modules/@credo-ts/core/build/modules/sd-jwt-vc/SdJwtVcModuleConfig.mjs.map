{"version":3,"file":"SdJwtVcModuleConfig.mjs","names":[],"sources":["../../../src/modules/sd-jwt-vc/SdJwtVcModuleConfig.ts"],"sourcesContent":["import type { SdJwtVcTypeMetadata } from './typeMetadata'\n\nexport type CustomTypeMetadataResolverOptions = {\n  /**\n   * Whether the vct value is a vct from an `extends` field.\n   */\n  isExtendedVct: boolean\n\n  /**\n   * Configuration option provided to the resolve method. The custom resolver\n   * is expected to adhere to this, and return undefined if set to `false` and\n   * a fetch error occurs. This value is also provided to the `defaultResolver`.\n   *\n   * If you want to override the default behavior, the custom resolver can ignore\n   * this value\n   */\n  throwErrorOnFetchError?: boolean\n\n  /**\n   * Configuration option provided to the resolve method. The custom resolver\n   * is expected to adhere to this, and return undefined if set to `false` and\n   * an unsupported vct value is provided. This value is also provided to the\n   * `defaultResolver`.\n   *\n   * If you want to override the default behavior, the custom resolver can ignore\n   * this value\n   */\n  throwErrorOnUnsupportedVctValue?: boolean\n\n  /**\n   * The default resolver for Type Metadata. This will only return a value\n   * if the `vct` is an HTTPS URL.\n   *\n   * You can use this in your custom resolver, to avoid re-implementing\n   * the default HTTPS resolving of Type Metadata.\n   *\n   * NOTE: the default resolver only fetches the document and extracts\n   * the JSON payload. Validation only happens AFTER returning the document\n   * from the custom resolver.\n   */\n  defaultResolver: (\n    options: Pick<CustomTypeMetadataResolverOptions, 'throwErrorOnFetchError' | 'throwErrorOnUnsupportedVctValue'>\n  ) => Promise<Record<string, unknown> | undefined>\n}\n\n/**\n * Custom vct resolver for SD-JWT Type Metadata.\n *\n * The returned value is validated after the it is returned. For this reason the type\n * is Record<string, unknown>. If an invalid document is returned this will cause the\n * resolving to fail.\n *\n * An integrity field (`vct#integrity` or `extends#integrity`) field is optionally provided.\n * If provided, you MUST verify the integrity based on the resolved document in the custom\n * resolver implementation due to the integrity requiring against the raw structure, as parsing\n * to JSON might change the structure of the document, resulting in an invalid hash. When using\n * the `defaultResolver` callback this is handled for HTTPS documents by default. For custom\n * resolve documents you can use the `IntegrityVerifier` class exported from `@credo-ts/core`.\n *\n * The `isExtendedVct` indicates whether the vct value is extracted from the `extends` field\n * of an extending Type Metadata object.\n *\n * The resolver can return undefined to indicate there's no Type Metadata. If the resolving should\n * fail due to the VCT url not being resolvable, you can also throw an error.\n *\n * When `isExtendedVct` is true, the method MUST always return a Type Metadata object, as the\n * VCT is then referenced by another Type Metadata document and is thus intended to be resolved.\n */\nexport type CustomTypeMetadataResolver = (\n  vct: string,\n  integrity: string | undefined,\n  options: CustomTypeMetadataResolverOptions\n) => Promise<SdJwtVcTypeMetadata | Record<string, unknown> | undefined>\n\nexport interface SdJwtVcModuleConfigOptions {\n  /**\n   * @see {@link CustomTypeMetadataResolver}\n   */\n  customTypeMetadataResolver?: CustomTypeMetadataResolver\n}\n\n/**\n * @public\n */\nexport class SdJwtVcModuleConfig {\n  private options: SdJwtVcModuleConfigOptions\n\n  public constructor(options?: SdJwtVcModuleConfigOptions) {\n    this.options = options ?? {}\n  }\n\n  public get customTypeMetadataResolver() {\n    return this.options.customTypeMetadataResolver\n  }\n}\n"],"mappings":";;;;;;AAoFA,IAAa,sBAAb,MAAiC;CAG/B,AAAO,YAAY,SAAsC;AACvD,OAAK,UAAU,WAAW,EAAE;;CAG9B,IAAW,6BAA6B;AACtC,SAAO,KAAK,QAAQ"}