

import { AgentContext } from "../../agent/context/AgentContext.mjs";
import { injectable } from "../../plugins/index.mjs";
import { __decorateMetadata } from "../../_virtual/_@oxc-project_runtime@0.110.0/helpers/decorateMetadata.mjs";
import { __decorate } from "../../_virtual/_@oxc-project_runtime@0.110.0/helpers/decorate.mjs";
import "../../agent/index.mjs";
import { SdJwtVcService } from "./SdJwtVcService.mjs";

//#region src/modules/sd-jwt-vc/SdJwtVcApi.ts
var _ref, _ref2;
let SdJwtVcApi = class SdJwtVcApi {
	constructor(agentContext, sdJwtVcService) {
		this.agentContext = agentContext;
		this.sdJwtVcService = sdJwtVcService;
	}
	async sign(options) {
		return await this.sdJwtVcService.sign(this.agentContext, options);
	}
	/**
	*
	* Create a compact presentation of the sd-jwt.
	* This presentation can be send in- or out-of-band to the verifier.
	*
	* Also, whether to include the holder key binding.
	*/
	async present(options) {
		return await this.sdJwtVcService.present(this.agentContext, options);
	}
	/**
	*
	* Verify an incoming sd-jwt. It will check whether everything is valid, but also returns parts of the validation.
	*
	* For example, you might still want to continue with a flow if not all the claims are included, but the signature is valid.
	*
	*/
	async verify(options) {
		return await this.sdJwtVcService.verify(this.agentContext, options);
	}
	/**
	* Fetches the type metadata for the `vct`. The default resolver only supports HTTPs,
	* but you can register a custom resolver on the SdJwtVcModule config.
	*
	* If the default resolver is used and fetching the VCT directly fails, it will fallback to the legacy vct path.
	* If both fail, an error will be thrown, unless `throwErrorOnFetchError` is set to `false`.
	*
	* The integrity will always be verified if the metadata was resolved. The `extends` keyword is
	* not resolved yet.
	*/
	async fetchTypeMetadata(sdJwtVc, options) {
		return this.sdJwtVcService.fetchTypeMetadata(this.agentContext, sdJwtVc, options);
	}
	/**
	* Get and validate a sd-jwt-vc from a serialized JWT.
	*/
	fromCompact(sdJwtVcCompact) {
		return this.sdJwtVcService.fromCompact(sdJwtVcCompact);
	}
	async store(options) {
		return await this.sdJwtVcService.store(this.agentContext, options);
	}
	async getById(id) {
		return await this.sdJwtVcService.getById(this.agentContext, id);
	}
	async getAll() {
		return await this.sdJwtVcService.getAll(this.agentContext);
	}
	async findAllByQuery(query, queryOptions) {
		return await this.sdJwtVcService.findByQuery(this.agentContext, query, queryOptions);
	}
	async deleteById(id) {
		return await this.sdJwtVcService.deleteById(this.agentContext, id);
	}
	async update(sdJwtVcRecord) {
		return await this.sdJwtVcService.update(this.agentContext, sdJwtVcRecord);
	}
};
SdJwtVcApi = __decorate([injectable(), __decorateMetadata("design:paramtypes", [typeof (_ref = typeof AgentContext !== "undefined" && AgentContext) === "function" ? _ref : Object, typeof (_ref2 = typeof SdJwtVcService !== "undefined" && SdJwtVcService) === "function" ? _ref2 : Object])], SdJwtVcApi);

//#endregion
export { SdJwtVcApi };
//# sourceMappingURL=SdJwtVcApi.mjs.map