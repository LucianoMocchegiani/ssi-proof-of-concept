

import { Hasher } from "../../crypto/hashes/Hasher.mjs";
import { ClaimFormat } from "../vc/models/ClaimFormat.mjs";
import "../../crypto/index.mjs";
import { parseHolderBindingFromCredential } from "./utils.mjs";
import "../vc/index.mjs";
import { decodeSdJwtSync, getClaimsSync } from "@sd-jwt/decode";

//#region src/modules/sd-jwt-vc/decodeSdJwtVc.ts
function sdJwtVcHasher(data, alg) {
	return Hasher.hash(typeof data === "string" ? data : new Uint8Array(data), alg);
}
function decodeSdJwtVc(compactSdJwtVc, typeMetadata) {
	const { jwt, disclosures, kbJwt } = decodeSdJwtSync(compactSdJwtVc, sdJwtVcHasher);
	const prettyClaims = getClaimsSync(jwt.payload, disclosures, sdJwtVcHasher);
	return {
		compact: compactSdJwtVc,
		header: jwt.header,
		payload: jwt.payload,
		holder: parseHolderBindingFromCredential(jwt.payload) ?? void 0,
		prettyClaims,
		claimFormat: ClaimFormat.SdJwtDc,
		encoded: compactSdJwtVc,
		kbJwt: kbJwt ? {
			payload: kbJwt.payload,
			header: kbJwt.header
		} : void 0,
		...typeMetadata && { typeMetadata }
	};
}

//#endregion
export { decodeSdJwtVc, sdJwtVcHasher };
//# sourceMappingURL=decodeSdJwtVc.mjs.map