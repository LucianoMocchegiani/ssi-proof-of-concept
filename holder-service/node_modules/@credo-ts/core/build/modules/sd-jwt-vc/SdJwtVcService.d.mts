import { Query, QueryOptions } from "../../storage/StorageService.mjs";
import { JsonObject } from "../../types.mjs";
import { ClaimFormat } from "../vc/models/ClaimFormat.mjs";
import { SdJwtVcHeader, SdJwtVcHolderBinding, SdJwtVcPayload, SdJwtVcPresentOptions, SdJwtVcSignOptions, SdJwtVcStoreOptions, SdJwtVcVerifyOptions } from "./SdJwtVcOptions.mjs";
import { SdJwtVcTypeMetadata } from "./typeMetadata.mjs";
import { SdJwtVcRecord } from "./repository/SdJwtVcRecord.mjs";
import { SdJwtVcRepository } from "./repository/SdJwtVcRepository.mjs";
import "./repository/index.mjs";
import "../vc/index.mjs";
import { AgentContext } from "../../agent/context/AgentContext.mjs";
import "../../agent/index.mjs";
import * as _sd_jwt_sd_jwt_vc0 from "@sd-jwt/sd-jwt-vc";
import { NonEmptyArray } from "@animo-id/pex";

//#region src/modules/sd-jwt-vc/SdJwtVcService.d.ts
interface SdJwtVc<Header extends SdJwtVcHeader = SdJwtVcHeader, Payload extends SdJwtVcPayload = SdJwtVcPayload> {
  /**
   * claim format is convenience method added to all credential instances
   */
  claimFormat: ClaimFormat.SdJwtDc;
  /**
   * encoded is convenience method added to all credential instances
   */
  encoded: string;
  compact: string;
  header: Header;
  /**
   * The holder of the credential
   */
  holder: SdJwtVcHolderBinding | undefined;
  payload: Payload;
  prettyClaims: Payload;
  kbJwt?: {
    header: Record<string, unknown>;
    payload: Record<string, unknown>;
  };
  /**
   * The key id in the KMS bound to this SD-JWT VC, used for presentations.
   *
   * This will only be set on the holder side if defined on the SdJwtVcRecord
   */
  kmsKeyId?: string;
  /**
   * The merged/resolved type metadata of the SD-JWT VC.
   */
  typeMetadata?: SdJwtVcTypeMetadata;
}
interface VerificationResult {
  isValid: boolean;
  isValidJwtPayload?: boolean;
  isSignatureValid?: boolean;
  isStatusValid?: boolean;
  isNotBeforeValid?: boolean;
  isExpiryTimeValid?: boolean;
  areRequiredClaimsIncluded?: boolean;
  isKeyBindingValid?: boolean;
  containsExpectedKeyBinding?: boolean;
  containsRequiredVcProperties?: boolean;
}
/**
 * @internal
 */
declare class SdJwtVcService {
  private sdJwtVcRepository;
  constructor(sdJwtVcRepository: SdJwtVcRepository);
  sign<Payload extends SdJwtVcPayload>(agentContext: AgentContext, options: SdJwtVcSignOptions<Payload>): Promise<SdJwtVc>;
  fromCompact<Header extends SdJwtVcHeader = SdJwtVcHeader, Payload extends SdJwtVcPayload = SdJwtVcPayload>(compactSdJwtVc: string, typeMetadata?: SdJwtVcTypeMetadata): SdJwtVc<Header, Payload>;
  applyDisclosuresForPayload(compactSdJwtVc: string, requestedPayload: JsonObject): SdJwtVc;
  present<Payload extends SdJwtVcPayload = SdJwtVcPayload>(agentContext: AgentContext, {
    sdJwtVc,
    presentationFrame,
    verifierMetadata,
    additionalPayload
  }: SdJwtVcPresentOptions<Payload>): Promise<string>;
  private assertValidX5cJwtIssuer;
  verify<Header extends SdJwtVcHeader = SdJwtVcHeader, Payload extends SdJwtVcPayload = SdJwtVcPayload>(agentContext: AgentContext, {
    compactSdJwtVc,
    keyBinding,
    requiredClaimKeys,
    fetchTypeMetadata,
    trustedCertificates,
    now
  }: SdJwtVcVerifyOptions): Promise<{
    isValid: true;
    sdJwtVc: SdJwtVc<Header, Payload>;
    /**
     * The full type metadata chain, can be used for further processing the type metadata.
     *
     * Only populated if `fetchTypeMetadata` is set to true, and the resolver returned a type
     * metadata document.
     */
    typeMetadataChain?: NonEmptyArray<SdJwtVcTypeMetadata>;
  } | {
    isValid: false;
    sdJwtVc?: SdJwtVc<Header, Payload>;
    error: Error;
  }>;
  /**
   * Resolve the type metadata for an SD-JWT instance.
   *
   * This method resolves the `vct` value, and any `extends` values.
   */
  fetchTypeMetadata(agentContext: AgentContext, sdJwtVc: SdJwtVc, {
    throwErrorOnFetchError,
    throwErrorOnUnsupportedVctValue
  }?: {
    throwErrorOnFetchError?: boolean;
    throwErrorOnUnsupportedVctValue?: boolean;
  }): Promise<_sd_jwt_sd_jwt_vc0.ResolvedTypeMetadata | undefined>;
  store(agentContext: AgentContext, options: SdJwtVcStoreOptions): Promise<SdJwtVcRecord>;
  getById(agentContext: AgentContext, id: string): Promise<SdJwtVcRecord>;
  getAll(agentContext: AgentContext): Promise<Array<SdJwtVcRecord>>;
  findByQuery(agentContext: AgentContext, query: Query<SdJwtVcRecord>, queryOptions?: QueryOptions): Promise<Array<SdJwtVcRecord>>;
  deleteById(agentContext: AgentContext, id: string): Promise<void>;
  update(agentContext: AgentContext, sdJwtVcRecord: SdJwtVcRecord): Promise<void>;
  private extractKeyFromIssuer;
  private parseIssuerFromCredential;
  private getBaseSdJwtConfig;
  private getStatusListFetcher;
  private getVctFetcher;
  private httpsTypeMetadataResolver;
}
//#endregion
export { SdJwtVc, SdJwtVcService, VerificationResult };
//# sourceMappingURL=SdJwtVcService.d.mts.map