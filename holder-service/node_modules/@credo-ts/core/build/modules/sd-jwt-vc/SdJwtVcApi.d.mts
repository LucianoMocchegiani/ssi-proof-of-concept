import { Query, QueryOptions } from "../../storage/StorageService.mjs";
import { SdJwtVcHeader, SdJwtVcPayload, SdJwtVcPresentOptions, SdJwtVcSignOptions, SdJwtVcStoreOptions, SdJwtVcVerifyOptions } from "./SdJwtVcOptions.mjs";
import { SdJwtVcTypeMetadata } from "./typeMetadata.mjs";
import { SdJwtVc, SdJwtVcService } from "./SdJwtVcService.mjs";
import { SdJwtVcRecord } from "./repository/SdJwtVcRecord.mjs";
import "./repository/index.mjs";
import { AgentContext } from "../../agent/context/AgentContext.mjs";
import "../../agent/index.mjs";
import { ResolvedTypeMetadata } from "@sd-jwt/sd-jwt-vc";
import * as _animo_id_pex0 from "@animo-id/pex";

//#region src/modules/sd-jwt-vc/SdJwtVcApi.d.ts
/**
 * @public
 */
declare class SdJwtVcApi {
  private agentContext;
  private sdJwtVcService;
  constructor(agentContext: AgentContext, sdJwtVcService: SdJwtVcService);
  sign<Payload extends SdJwtVcPayload>(options: SdJwtVcSignOptions<Payload>): Promise<SdJwtVc<SdJwtVcHeader, SdJwtVcPayload>>;
  /**
   *
   * Create a compact presentation of the sd-jwt.
   * This presentation can be send in- or out-of-band to the verifier.
   *
   * Also, whether to include the holder key binding.
   */
  present<Payload extends SdJwtVcPayload = SdJwtVcPayload>(options: SdJwtVcPresentOptions<Payload>): Promise<string>;
  /**
   *
   * Verify an incoming sd-jwt. It will check whether everything is valid, but also returns parts of the validation.
   *
   * For example, you might still want to continue with a flow if not all the claims are included, but the signature is valid.
   *
   */
  verify<Header extends SdJwtVcHeader, Payload extends SdJwtVcPayload>(options: SdJwtVcVerifyOptions): Promise<{
    isValid: true;
    sdJwtVc: SdJwtVc<Header, Payload>;
    typeMetadataChain?: _animo_id_pex0.NonEmptyArray<SdJwtVcTypeMetadata>;
  } | {
    isValid: false;
    sdJwtVc?: SdJwtVc<Header, Payload> | undefined;
    error: Error;
  }>;
  /**
   * Fetches the type metadata for the `vct`. The default resolver only supports HTTPs,
   * but you can register a custom resolver on the SdJwtVcModule config.
   *
   * If the default resolver is used and fetching the VCT directly fails, it will fallback to the legacy vct path.
   * If both fail, an error will be thrown, unless `throwErrorOnFetchError` is set to `false`.
   *
   * The integrity will always be verified if the metadata was resolved. The `extends` keyword is
   * not resolved yet.
   */
  fetchTypeMetadata(sdJwtVc: SdJwtVc, options?: {
    throwErrorOnFetchError?: boolean;
    throwErrorOnUnsupportedVctValue?: boolean;
  }): Promise<ResolvedTypeMetadata | undefined>;
  /**
   * Get and validate a sd-jwt-vc from a serialized JWT.
   */
  fromCompact<Header extends SdJwtVcHeader, Payload extends SdJwtVcPayload>(sdJwtVcCompact: string): SdJwtVc<Header, Payload>;
  store(options: SdJwtVcStoreOptions): Promise<SdJwtVcRecord>;
  getById(id: string): Promise<SdJwtVcRecord>;
  getAll(): Promise<Array<SdJwtVcRecord>>;
  findAllByQuery(query: Query<SdJwtVcRecord>, queryOptions?: QueryOptions): Promise<Array<SdJwtVcRecord>>;
  deleteById(id: string): Promise<void>;
  update(sdJwtVcRecord: SdJwtVcRecord): Promise<void>;
}
//#endregion
export { SdJwtVcApi };
//# sourceMappingURL=SdJwtVcApi.d.mts.map