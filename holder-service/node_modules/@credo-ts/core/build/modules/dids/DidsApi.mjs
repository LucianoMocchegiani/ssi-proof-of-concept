

import { CredoError } from "../../error/CredoError.mjs";
import { RecordNotFoundError } from "../../error/RecordNotFoundError.mjs";
import "../../error/index.mjs";
import { AgentContext } from "../../agent/context/AgentContext.mjs";
import { injectable } from "../../plugins/index.mjs";
import { __decorateMetadata } from "../../_virtual/_@oxc-project_runtime@0.110.0/helpers/decorateMetadata.mjs";
import { __decorate } from "../../_virtual/_@oxc-project_runtime@0.110.0/helpers/decorate.mjs";
import "../../agent/index.mjs";
import { KeyManagementApi } from "../kms/KeyManagementApi.mjs";
import "../kms/index.mjs";
import { getPublicJwkFromVerificationMethod } from "./domain/key-type/keyDidMapping.mjs";
import "./domain/index.mjs";
import { DidRecord } from "./repository/DidRecord.mjs";
import { DidRepository } from "./repository/DidRepository.mjs";
import "./repository/index.mjs";
import { getAlternativeDidsForPeerDid, isValidPeerDid } from "./methods/peer/didPeer.mjs";
import "./methods/index.mjs";
import { DidsModuleConfig } from "./DidsModuleConfig.mjs";
import { DidResolverService } from "./services/DidResolverService.mjs";
import { DidRegistrarService } from "./services/DidRegistrarService.mjs";
import "./services/index.mjs";
import { parseDid } from "@sphereon/ssi-types";

//#region src/modules/dids/DidsApi.ts
var _ref, _ref2, _ref3, _ref4, _ref5, _ref6;
let DidsApi = class DidsApi {
	constructor(didResolverService, didRegistrarService, didRepository, agentContext, config, _keyManagement) {
		this.didResolverService = didResolverService;
		this.didRegistrarService = didRegistrarService;
		this.didRepository = didRepository;
		this.agentContext = agentContext;
		this.config = config;
	}
	/**
	* Resolve a did to a did document.
	*
	* Follows the interface as defined in https://w3c-ccg.github.io/did-resolution/
	*/
	resolve(didUrl, options) {
		return this.didResolverService.resolve(this.agentContext, didUrl, options);
	}
	/**
	* Create, register and store a did and did document.
	*
	* Follows the interface as defined in https://identity.foundation/did-registration
	*/
	create(options) {
		return this.didRegistrarService.create(this.agentContext, options);
	}
	/**
	* Update an existing did document.
	*
	* Follows the interface as defined in https://identity.foundation/did-registration
	*/
	update(options) {
		return this.didRegistrarService.update(this.agentContext, options);
	}
	/**
	* Deactivate an existing did.
	*
	* Follows the interface as defined in https://identity.foundation/did-registration
	*/
	deactivate(options) {
		return this.didRegistrarService.deactivate(this.agentContext, options);
	}
	/**
	* Resolve a did to a did document. This won't return the associated metadata as defined
	* in the did resolution specification, and will throw an error if the did document could not
	* be resolved.
	*/
	resolveDidDocument(didUrl) {
		return this.didResolverService.resolveDidDocument(this.agentContext, didUrl);
	}
	/**
	* Get a list of all dids created by the agent. This will return a list of {@link DidRecord} objects.
	* Each document will have an id property with the value of the did. Optionally, it will contain a did document,
	* but this is only for documents that can't be resolved from the did itself or remotely.
	*
	* You can call `${@link DidsModule.resolve} to resolve the did document based on the did itself.
	*/
	getCreatedDids({ method, did } = {}) {
		return this.didRepository.getCreatedDids(this.agentContext, {
			method,
			did
		});
	}
	/**
	* Import an existing did that was created outside of the DidsApi. This will create a `DidRecord` for the did
	* and will allow the did to be used in other parts of the agent. If you need to create a new did document,
	* you can use the {@link DidsApi.create} method to create and register the did.
	*
	* If no `didDocument` is provided, the did document will be resolved using the did resolver. You can optionally provide a list
	* of private key buffer with the respective private key bytes. These keys will be stored in the wallet, and allows you to use the
	* did for other operations. Providing keys that already exist in the wallet is allowed, and those keys will be skipped from being
	* added to the wallet.
	*
	* By default, this method will throw an error if the did already exists in the wallet. You can override this behavior by setting
	* the `overwrite` option to `true`. This will update the did document in the record, and allows you to update the did over time.
	*/
	async import({ did, didDocument, keys = [], overwrite }) {
		if (didDocument && didDocument.id !== did) throw new CredoError(`Did document id ${didDocument.id} does not match did ${did}`);
		const existingDidRecord = await this.didRepository.findCreatedDid(this.agentContext, did);
		if (existingDidRecord && !overwrite) throw new CredoError(`A created did ${did} already exists. If you want to override the existing did, set the 'overwrite' option to update the did.`);
		if (!didDocument) didDocument = await this.resolveDidDocument(did);
		for (const key of keys) didDocument.dereferenceKey(key.didDocumentRelativeKeyId);
		if (existingDidRecord) {
			existingDidRecord.didDocument = didDocument;
			existingDidRecord.keys = keys;
			existingDidRecord.setTags({ alternativeDids: isValidPeerDid(didDocument.id) ? getAlternativeDidsForPeerDid(did) : void 0 });
			await this.didRepository.update(this.agentContext, existingDidRecord);
			return;
		}
		await this.didRepository.storeCreatedDid(this.agentContext, {
			did,
			didDocument,
			keys,
			tags: { alternativeDids: isValidPeerDid(didDocument.id) ? getAlternativeDidsForPeerDid(did) : void 0 }
		});
	}
	async resolveCreatedDidDocumentWithKeys(did) {
		const [didRecord] = await this.didRepository.getCreatedDids(this.agentContext, { did });
		if (!didRecord) throw new RecordNotFoundError(`Created did '${did}' not found`, { recordType: DidRecord.type });
		if (didRecord.didDocument) return {
			keys: didRecord.keys,
			didDocument: didRecord.didDocument
		};
		const didDocument = await this.didResolverService.resolveDidDocument(this.agentContext, didRecord.did);
		return {
			keys: didRecord.keys,
			didDocument
		};
	}
	async resolveVerificationMethodFromCreatedDidRecord(didUrl, allowedPurposes) {
		const parsedDid = parseDid(didUrl);
		const { didDocument, keys } = await this.resolveCreatedDidDocumentWithKeys(parsedDid.did);
		const verificationMethod = didDocument.dereferenceKey(didUrl, allowedPurposes);
		const publicJwk = getPublicJwkFromVerificationMethod(verificationMethod);
		publicJwk.keyId = keys?.find(({ didDocumentRelativeKeyId }) => verificationMethod.id.endsWith(didDocumentRelativeKeyId))?.kmsKeyId ?? publicJwk.legacyKeyId;
		return {
			verificationMethod,
			publicJwk
		};
	}
	get supportedResolverMethods() {
		return this.didResolverService.supportedMethods;
	}
	get supportedRegistrarMethods() {
		return this.didRegistrarService.supportedMethods;
	}
};
DidsApi = __decorate([injectable(), __decorateMetadata("design:paramtypes", [
	typeof (_ref = typeof DidResolverService !== "undefined" && DidResolverService) === "function" ? _ref : Object,
	typeof (_ref2 = typeof DidRegistrarService !== "undefined" && DidRegistrarService) === "function" ? _ref2 : Object,
	typeof (_ref3 = typeof DidRepository !== "undefined" && DidRepository) === "function" ? _ref3 : Object,
	typeof (_ref4 = typeof AgentContext !== "undefined" && AgentContext) === "function" ? _ref4 : Object,
	typeof (_ref5 = typeof DidsModuleConfig !== "undefined" && DidsModuleConfig) === "function" ? _ref5 : Object,
	typeof (_ref6 = typeof KeyManagementApi !== "undefined" && KeyManagementApi) === "function" ? _ref6 : Object
])], DidsApi);

//#endregion
export { DidsApi };
//# sourceMappingURL=DidsApi.mjs.map