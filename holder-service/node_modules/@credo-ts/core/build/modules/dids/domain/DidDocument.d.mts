import { Ed25519PublicJwk } from "../../kms/jwk/kty/okp/Ed25519PublicJwk.mjs";
import { X25519PublicJwk } from "../../kms/jwk/kty/okp/X25519PublicJwk.mjs";
import { PublicJwk } from "../../kms/jwk/PublicJwk.mjs";
import "../../kms/index.mjs";
import { DidDocumentService } from "./service/DidDocumentService.mjs";
import { DidCommV1Service } from "./service/DidCommV1Service.mjs";
import { IndyAgentService } from "./service/IndyAgentService.mjs";
import "./service/index.mjs";
import { VerificationMethod } from "./verificationMethod/VerificationMethod.mjs";
import "./verificationMethod/index.mjs";

//#region src/modules/dids/domain/DidDocument.d.ts
type DidPurpose = 'authentication' | 'keyAgreement' | 'assertionMethod' | 'capabilityInvocation' | 'capabilityDelegation';
type DidVerificationMethods = DidPurpose | 'verificationMethod';
interface DidDocumentOptions {
  context?: string | string[];
  id: string;
  alsoKnownAs?: string[];
  controller?: string | string[];
  verificationMethod?: VerificationMethod[];
  service?: DidDocumentService[];
  authentication?: Array<string | VerificationMethod>;
  assertionMethod?: Array<string | VerificationMethod>;
  keyAgreement?: Array<string | VerificationMethod>;
  capabilityInvocation?: Array<string | VerificationMethod>;
  capabilityDelegation?: Array<string | VerificationMethod>;
}
declare class DidDocument {
  context: string | string[];
  id: string;
  alsoKnownAs?: string[];
  controller?: string | string[];
  verificationMethod?: VerificationMethod[];
  service?: DidDocumentService[];
  authentication?: Array<string | VerificationMethod>;
  assertionMethod?: Array<string | VerificationMethod>;
  keyAgreement?: Array<string | VerificationMethod>;
  capabilityInvocation?: Array<string | VerificationMethod>;
  capabilityDelegation?: Array<string | VerificationMethod>;
  constructor(options: DidDocumentOptions);
  dereferenceVerificationMethod(keyId: string): VerificationMethod;
  dereferenceKey(keyId: string, allowedPurposes?: DidVerificationMethods[]): VerificationMethod;
  private matchKeyId;
  findVerificationMethodByPublicKey(publicJwk: PublicJwk, allowedPurposes?: DidVerificationMethods[]): VerificationMethod;
  /**
   * Returns all of the service endpoints matching the given type.
   *
   * @param type The type of service(s) to query.
   */
  getServicesByType<S extends DidDocumentService = DidDocumentService>(type: string): S[];
  /**
   * Returns all of the service endpoints matching the given class
   *
   * @param classType The class to query services.
   */
  getServicesByClassType<S extends DidDocumentService = DidDocumentService>(classType: new (...args: never[]) => S): S[];
  /**
   * Get all DIDComm services ordered by priority descending. This means the highest
   * priority will be the first entry.
   */
  get didCommServices(): Array<IndyAgentService | DidCommV1Service>;
  get recipientKeys(): PublicJwk<Ed25519PublicJwk | X25519PublicJwk>[];
  /**
   * Returns the recipient keys with their verification method matches
   *
   * We should probably deprecate recipientKeys in favour of this one
   */
  getRecipientKeysWithVerificationMethod<MapX25519ToEd25519 extends boolean>({
    mapX25519ToEd25519
  }: {
    mapX25519ToEd25519: MapX25519ToEd25519;
  }): Array<{
    verificationMethod: VerificationMethod;
    publicJwk: PublicJwk<MapX25519ToEd25519 extends true ? Ed25519PublicJwk : Ed25519PublicJwk | X25519PublicJwk>;
  }>;
  toJSON(): Record<string, any>;
  static fromJSON(didDocument: unknown): DidDocument;
}
/**
 * Extracting the verification method for signature type
 * @param type Signature type
 * @param didDocument DidDocument
 * @returns verification method
 */
declare function findVerificationMethodByKeyType(keyType: string, didDocument: DidDocument): Promise<VerificationMethod | null>;
//#endregion
export { DidDocument, DidPurpose, findVerificationMethodByKeyType };
//# sourceMappingURL=DidDocument.d.mts.map