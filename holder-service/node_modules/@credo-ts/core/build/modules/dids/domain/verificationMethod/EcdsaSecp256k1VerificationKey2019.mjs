

import { CredoError } from "../../../../error/CredoError.mjs";
import "../../../../error/index.mjs";
import { TypedArrayEncoder } from "../../../../utils/TypedArrayEncoder.mjs";
import "../../../../utils/index.mjs";
import { PublicJwk } from "../../../kms/jwk/PublicJwk.mjs";
import "../../../kms/index.mjs";
import { VerificationMethod } from "./VerificationMethod.mjs";

//#region src/modules/dids/domain/verificationMethod/EcdsaSecp256k1VerificationKey2019.ts
const VERIFICATION_METHOD_TYPE_ECDSA_SECP256K1_VERIFICATION_KEY_2019 = "EcdsaSecp256k1VerificationKey2019";
/**
* Get a EcdsaSecp256k1VerificationKey2019 verification method.
*/
function getEcdsaSecp256k1VerificationKey2019({ publicJwk, id, controller }) {
	return new VerificationMethod({
		id,
		type: VERIFICATION_METHOD_TYPE_ECDSA_SECP256K1_VERIFICATION_KEY_2019,
		controller,
		publicKeyBase58: TypedArrayEncoder.toBase58(publicJwk.publicKey.publicKey)
	});
}
/**
* Check whether a verification method is a EcdsaSecp256k1VerificationKey2019 verification method.
*/
function isEcdsaSecp256k1VerificationKey2019(verificationMethod) {
	return verificationMethod.type === VERIFICATION_METHOD_TYPE_ECDSA_SECP256K1_VERIFICATION_KEY_2019;
}
/**
* Get a public jwk from a EcdsaSecp256k1VerificationKey2019 verification method.
*/
function getPublicJwkFromEcdsaSecp256k1VerificationKey2019(verificationMethod) {
	if (!verificationMethod.publicKeyBase58) throw new CredoError("verification method is missing publicKeyBase58");
	return PublicJwk.fromPublicKey({
		kty: "EC",
		crv: "secp256k1",
		publicKey: TypedArrayEncoder.fromBase58(verificationMethod.publicKeyBase58)
	});
}

//#endregion
export { VERIFICATION_METHOD_TYPE_ECDSA_SECP256K1_VERIFICATION_KEY_2019, getEcdsaSecp256k1VerificationKey2019, getPublicJwkFromEcdsaSecp256k1VerificationKey2019, isEcdsaSecp256k1VerificationKey2019 };
//# sourceMappingURL=EcdsaSecp256k1VerificationKey2019.mjs.map