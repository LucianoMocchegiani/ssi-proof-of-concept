

import { InjectionSymbols } from "../../../constants.mjs";
import { inject, injectable } from "../../../plugins/index.mjs";
import { __decorateMetadata } from "../../../_virtual/_@oxc-project_runtime@0.110.0/helpers/decorateMetadata.mjs";
import { __decorate } from "../../../_virtual/_@oxc-project_runtime@0.110.0/helpers/decorate.mjs";
import { tryParseDid } from "../domain/parse.mjs";
import { __decorateParam } from "../../../_virtual/_@oxc-project_runtime@0.110.0/helpers/decorateParam.mjs";
import { DidsModuleConfig } from "../DidsModuleConfig.mjs";
import { DidResolverService } from "./DidResolverService.mjs";

//#region src/modules/dids/services/DidRegistrarService.ts
var _ref, _ref2;
let DidRegistrarService = class DidRegistrarService {
	constructor(logger, didsModuleConfig, didResolverService) {
		this.logger = logger;
		this.didsModuleConfig = didsModuleConfig;
		this.didResolverService = didResolverService;
	}
	async create(agentContext, options) {
		this.logger.debug(`creating did ${options.did ?? options.method}`);
		const errorResult = {
			didDocumentMetadata: {},
			didRegistrationMetadata: {},
			didState: {
				state: "failed",
				did: options.did
			}
		};
		if (!options.did && !options.method || options.did && options.method) return {
			...errorResult,
			didState: {
				...errorResult.didState,
				reason: "Either did OR method must be specified"
			}
		};
		const method = options.method ?? tryParseDid(options.did)?.method;
		if (!method) return {
			...errorResult,
			didState: {
				...errorResult.didState,
				reason: `Could not extract method from did ${options.did}`
			}
		};
		const registrar = this.findRegistrarForMethod(method);
		if (!registrar) return {
			...errorResult,
			didState: {
				...errorResult.didState,
				reason: `Unsupported did method: '${method}'`
			}
		};
		return await registrar.create(agentContext, options);
	}
	async update(agentContext, options) {
		this.logger.debug(`updating did ${options.did}`);
		const method = tryParseDid(options.did)?.method;
		const errorResult = {
			didDocumentMetadata: {},
			didRegistrationMetadata: {},
			didState: {
				state: "failed",
				did: options.did
			}
		};
		if (!method) return {
			...errorResult,
			didState: {
				...errorResult.didState,
				reason: `Could not extract method from did ${options.did}`
			}
		};
		const registrar = this.findRegistrarForMethod(method);
		if (!registrar) return {
			...errorResult,
			didState: {
				...errorResult.didState,
				reason: `Unsupported did method: '${method}'`
			}
		};
		await this.didResolverService.invalidateCacheForDid(agentContext, options.did);
		return await registrar.update(agentContext, options);
	}
	async deactivate(agentContext, options) {
		this.logger.debug(`deactivating did ${options.did}`);
		const errorResult = {
			didDocumentMetadata: {},
			didRegistrationMetadata: {},
			didState: {
				state: "failed",
				did: options.did
			}
		};
		const method = tryParseDid(options.did)?.method;
		if (!method) return {
			...errorResult,
			didState: {
				...errorResult.didState,
				reason: `Could not extract method from did ${options.did}`
			}
		};
		const registrar = this.findRegistrarForMethod(method);
		if (!registrar) return {
			...errorResult,
			didState: {
				...errorResult.didState,
				reason: `Unsupported did method: '${method}'`
			}
		};
		await this.didResolverService.invalidateCacheForDid(agentContext, options.did);
		return await registrar.deactivate(agentContext, options);
	}
	findRegistrarForMethod(method) {
		return this.didsModuleConfig.registrars.find((r) => r.supportedMethods.includes(method)) ?? null;
	}
	/**
	* Get all supported did methods for the did registrar.
	*/
	get supportedMethods() {
		return Array.from(new Set(this.didsModuleConfig.registrars.flatMap((r) => r.supportedMethods)));
	}
};
DidRegistrarService = __decorate([
	injectable(),
	__decorateParam(0, inject(InjectionSymbols.Logger)),
	__decorateMetadata("design:paramtypes", [
		Object,
		typeof (_ref = typeof DidsModuleConfig !== "undefined" && DidsModuleConfig) === "function" ? _ref : Object,
		typeof (_ref2 = typeof DidResolverService !== "undefined" && DidResolverService) === "function" ? _ref2 : Object
	])
], DidRegistrarService);

//#endregion
export { DidRegistrarService };
//# sourceMappingURL=DidRegistrarService.mjs.map