

import { InjectionSymbols } from "../../../constants.mjs";
import { CredoError } from "../../../error/CredoError.mjs";
import "../../../error/index.mjs";
import { JsonTransformer } from "../../../utils/JsonTransformer.mjs";
import "../../../utils/index.mjs";
import { inject, injectable } from "../../../plugins/index.mjs";
import { __decorateMetadata } from "../../../_virtual/_@oxc-project_runtime@0.110.0/helpers/decorateMetadata.mjs";
import { __decorate } from "../../../_virtual/_@oxc-project_runtime@0.110.0/helpers/decorate.mjs";
import { parseDid } from "../domain/parse.mjs";
import { DidDocument } from "../domain/DidDocument.mjs";
import "../domain/index.mjs";
import { __decorateParam } from "../../../_virtual/_@oxc-project_runtime@0.110.0/helpers/decorateParam.mjs";
import { CacheModuleConfig } from "../../cache/CacheModuleConfig.mjs";
import { DidRepository } from "../repository/DidRepository.mjs";
import "../repository/index.mjs";
import { DidsModuleConfig } from "../DidsModuleConfig.mjs";
import "../../cache/index.mjs";

//#region src/modules/dids/services/DidResolverService.ts
var _ref, _ref2;
let DidResolverService = class DidResolverService {
	constructor(logger, didsModuleConfig, didRepository) {
		this.logger = logger;
		this.didsModuleConfig = didsModuleConfig;
		this.didRepository = didRepository;
	}
	async resolve(agentContext, didUrl, options = {}) {
		this.logger.debug(`resolving didUrl ${didUrl}`);
		const result = {
			didResolutionMetadata: {},
			didDocument: null,
			didDocumentMetadata: {}
		};
		let parsed;
		try {
			parsed = parseDid(didUrl);
		} catch (_error) {
			return {
				...result,
				didResolutionMetadata: { error: "invalidDid" }
			};
		}
		const resolver = this.findResolver(parsed);
		if (!resolver) return {
			...result,
			didResolutionMetadata: {
				error: "unsupportedDidMethod",
				message: `No did resolver registered for did method ${parsed.method}`
			}
		};
		const { useCache = true, cacheDurationInSeconds = 300, persistInCache = true, useLocalCreatedDidRecord = true } = options;
		const cacheKey = this.getCacheKey(parsed.did);
		if (resolver.allowsCaching && useCache) {
			const cachedDidDocument = await agentContext.dependencyManager.resolve(CacheModuleConfig).cache.get(agentContext, cacheKey);
			if (cachedDidDocument) return {
				...cachedDidDocument,
				didDocument: JsonTransformer.fromJSON(cachedDidDocument.didDocument, DidDocument),
				didResolutionMetadata: {
					...cachedDidDocument.didResolutionMetadata,
					servedFromCache: true
				}
			};
		}
		if (resolver.allowsLocalDidRecord && useLocalCreatedDidRecord) {
			const [didRecord] = await this.didRepository.getCreatedDids(agentContext, { did: parsed.did });
			if (didRecord?.didDocument) return {
				didDocument: didRecord.didDocument,
				didDocumentMetadata: {},
				didResolutionMetadata: {
					servedFromCache: false,
					servedFromDidRecord: true
				}
			};
		}
		let resolutionResult = await resolver.resolve(agentContext, parsed.did, parsed, options);
		resolutionResult = {
			...resolutionResult,
			didResolutionMetadata: {
				...resolutionResult.didResolutionMetadata,
				resolutionTime: Date.now(),
				servedFromCache: resolutionResult.didResolutionMetadata.servedFromCache ?? false
			}
		};
		if (resolutionResult.didDocument && resolver.allowsCaching && persistInCache) await agentContext.dependencyManager.resolve(CacheModuleConfig).cache.set(agentContext, cacheKey, {
			...resolutionResult,
			didDocument: resolutionResult.didDocument.toJSON()
		}, cacheDurationInSeconds);
		return resolutionResult;
	}
	/**
	* Resolve a did document. This uses the default resolution options, and thus
	* will use caching if available.
	*/
	async resolveDidDocument(agentContext, did) {
		const { didDocument, didResolutionMetadata: { error, message } } = await this.resolve(agentContext, did);
		if (!didDocument) throw new CredoError(`Unable to resolve did document for did '${did}': ${error} ${message}`);
		return didDocument;
	}
	async invalidateCacheForDid(agentContext, did) {
		await agentContext.dependencyManager.resolve(CacheModuleConfig).cache.remove(agentContext, this.getCacheKey(did));
	}
	getCacheKey(did) {
		return `did:resolver:${did}`;
	}
	findResolver(parsed) {
		return this.didsModuleConfig.resolvers.find((r) => r.supportedMethods.includes(parsed.method)) ?? null;
	}
	/**
	* Get all supported did methods for the did resolver.
	*/
	get supportedMethods() {
		return Array.from(new Set(this.didsModuleConfig.resolvers.flatMap((r) => r.supportedMethods)));
	}
};
DidResolverService = __decorate([
	injectable(),
	__decorateParam(0, inject(InjectionSymbols.Logger)),
	__decorateMetadata("design:paramtypes", [
		Object,
		typeof (_ref = typeof DidsModuleConfig !== "undefined" && DidsModuleConfig) === "function" ? _ref : Object,
		typeof (_ref2 = typeof DidRepository !== "undefined" && DidRepository) === "function" ? _ref2 : Object
	])
], DidResolverService);

//#endregion
export { DidResolverService };
//# sourceMappingURL=DidResolverService.mjs.map