{"version":3,"file":"peerDidNumAlgo4.mjs","names":[],"sources":["../../../../../src/modules/dids/methods/peer/peerDidNumAlgo4.ts"],"sourcesContent":["import { CredoError } from '../../../../error'\nimport {\n  JsonEncoder,\n  JsonTransformer,\n  MultiBaseEncoder,\n  MultiHashEncoder,\n  TypedArrayEncoder,\n  VarintEncoder,\n} from '../../../../utils'\nimport { Buffer } from '../../../../utils/buffer'\nimport { DidDocument } from '../../domain'\nimport { parseDid } from '../../domain/parse'\n\nconst LONG_RE = /^did:peer:4(z[1-9a-km-zA-HJ-NP-Z]{46}):(z[1-9a-km-zA-HJ-NP-Z]{6,})$/\nconst SHORT_RE = /^did:peer:4(z[1-9a-km-zA-HJ-NP-Z]{46})$/\nconst JSON_MULTICODEC_VARINT = 0x0200\n\nexport const isShortFormDidPeer4 = (did: string) => SHORT_RE.test(did)\nexport const isLongFormDidPeer4 = (did: string) => LONG_RE.test(did)\n\nconst hashEncodedDocument = (encodedDocument: string) =>\n  MultiBaseEncoder.encode(\n    MultiHashEncoder.encode(TypedArrayEncoder.fromString(encodedDocument), 'sha-256'),\n    'base58btc'\n  )\n\nexport function getAlternativeDidsForNumAlgo4Did(did: string) {\n  const match = did.match(LONG_RE)\n  if (!match) return\n  const [, hash] = match\n  return [`did:peer:4${hash}`]\n}\n\nexport function didToNumAlgo4DidDocument(did: string) {\n  const parsed = parseDid(did)\n\n  const match = parsed.did.match(LONG_RE)\n  if (!match) {\n    throw new CredoError(`Invalid long form algo 4 did:peer: ${parsed.did}`)\n  }\n  const [, hash, encodedDocument] = match\n  if (hash !== hashEncodedDocument(encodedDocument)) {\n    throw new CredoError(`Hash is invalid for did: ${did}`)\n  }\n\n  const { data } = MultiBaseEncoder.decode(encodedDocument)\n  const [multiCodecValue] = VarintEncoder.decode(data.subarray(0, 2))\n  if (multiCodecValue !== JSON_MULTICODEC_VARINT) {\n    throw new CredoError('Not a JSON multicodec data')\n  }\n  const didDocumentJson = JsonEncoder.fromBuffer(data.subarray(2))\n\n  didDocumentJson.id = parsed.did\n  didDocumentJson.alsoKnownAs = [parsed.did.slice(0, did.lastIndexOf(':'))]\n\n  // Populate all verification methods without controller\n  const addControllerIfNotPresent = (item: unknown) => {\n    if (Array.isArray(item)) item.forEach(addControllerIfNotPresent)\n\n    if (item && typeof item === 'object' && (item as Record<string, unknown>).controller === undefined) {\n      ;(item as Record<string, unknown>).controller = parsed.did\n    }\n  }\n\n  addControllerIfNotPresent(didDocumentJson.verificationMethod)\n  addControllerIfNotPresent(didDocumentJson.authentication)\n  addControllerIfNotPresent(didDocumentJson.assertionMethod)\n  addControllerIfNotPresent(didDocumentJson.keyAgreement)\n  addControllerIfNotPresent(didDocumentJson.capabilityDelegation)\n  addControllerIfNotPresent(didDocumentJson.capabilityInvocation)\n\n  const didDocument = JsonTransformer.fromJSON(didDocumentJson, DidDocument)\n  return didDocument\n}\n\nexport function didDocumentToNumAlgo4Did(didDocument: DidDocument) {\n  const didDocumentJson = didDocument.toJSON()\n\n  // Build input document based on did document, without any\n  // reference to controller\n  const deleteControllerIfPresent = (item: unknown) => {\n    if (Array.isArray(item)) {\n      for (const method of item) {\n        if (method.controller === '#id' || method.controller === didDocument.id) method.controller = undefined\n      }\n    }\n  }\n  didDocumentJson.id = undefined\n  didDocumentJson.alsoKnownAs = undefined\n  deleteControllerIfPresent(didDocumentJson.verificationMethod)\n  deleteControllerIfPresent(didDocumentJson.authentication)\n  deleteControllerIfPresent(didDocumentJson.assertionMethod)\n  deleteControllerIfPresent(didDocumentJson.keyAgreement)\n  deleteControllerIfPresent(didDocumentJson.capabilityDelegation)\n  deleteControllerIfPresent(didDocumentJson.capabilityInvocation)\n\n  // Construct encoded document by prefixing did document with multicodec prefix for JSON\n  const buffer = Buffer.concat([\n    VarintEncoder.encode(JSON_MULTICODEC_VARINT),\n    TypedArrayEncoder.fromString(JSON.stringify(didDocumentJson)),\n  ])\n\n  const encodedDocument = MultiBaseEncoder.encode(buffer, 'base58btc')\n\n  const shortFormDid = `did:peer:4${hashEncodedDocument(encodedDocument)}`\n  const longFormDid = `${shortFormDid}:${encodedDocument}`\n\n  return { shortFormDid, longFormDid }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;AAaA,MAAM,UAAU;AAChB,MAAM,WAAW;AACjB,MAAM,yBAAyB;AAE/B,MAAa,uBAAuB,QAAgB,SAAS,KAAK,IAAI;AAGtE,MAAM,uBAAuB,oBAC3B,iBAAiB,OACf,iBAAiB,OAAO,kBAAkB,WAAW,gBAAgB,EAAE,UAAU,EACjF,YACD;AAEH,SAAgB,iCAAiC,KAAa;CAC5D,MAAM,QAAQ,IAAI,MAAM,QAAQ;AAChC,KAAI,CAAC,MAAO;CACZ,MAAM,GAAG,QAAQ;AACjB,QAAO,CAAC,aAAa,OAAO;;AAG9B,SAAgB,yBAAyB,KAAa;CACpD,MAAM,SAAS,SAAS,IAAI;CAE5B,MAAM,QAAQ,OAAO,IAAI,MAAM,QAAQ;AACvC,KAAI,CAAC,MACH,OAAM,IAAI,WAAW,sCAAsC,OAAO,MAAM;CAE1E,MAAM,GAAG,MAAM,mBAAmB;AAClC,KAAI,SAAS,oBAAoB,gBAAgB,CAC/C,OAAM,IAAI,WAAW,4BAA4B,MAAM;CAGzD,MAAM,EAAE,SAAS,iBAAiB,OAAO,gBAAgB;CACzD,MAAM,CAAC,mBAAmB,cAAc,OAAO,KAAK,SAAS,GAAG,EAAE,CAAC;AACnE,KAAI,oBAAoB,uBACtB,OAAM,IAAI,WAAW,6BAA6B;CAEpD,MAAM,kBAAkB,YAAY,WAAW,KAAK,SAAS,EAAE,CAAC;AAEhE,iBAAgB,KAAK,OAAO;AAC5B,iBAAgB,cAAc,CAAC,OAAO,IAAI,MAAM,GAAG,IAAI,YAAY,IAAI,CAAC,CAAC;CAGzE,MAAM,6BAA6B,SAAkB;AACnD,MAAI,MAAM,QAAQ,KAAK,CAAE,MAAK,QAAQ,0BAA0B;AAEhE,MAAI,QAAQ,OAAO,SAAS,YAAa,KAAiC,eAAe,OACtF,CAAC,KAAiC,aAAa,OAAO;;AAI3D,2BAA0B,gBAAgB,mBAAmB;AAC7D,2BAA0B,gBAAgB,eAAe;AACzD,2BAA0B,gBAAgB,gBAAgB;AAC1D,2BAA0B,gBAAgB,aAAa;AACvD,2BAA0B,gBAAgB,qBAAqB;AAC/D,2BAA0B,gBAAgB,qBAAqB;AAG/D,QADoB,gBAAgB,SAAS,iBAAiB,YAAY;;AAI5E,SAAgB,yBAAyB,aAA0B;CACjE,MAAM,kBAAkB,YAAY,QAAQ;CAI5C,MAAM,6BAA6B,SAAkB;AACnD,MAAI,MAAM,QAAQ,KAAK,EACrB;QAAK,MAAM,UAAU,KACnB,KAAI,OAAO,eAAe,SAAS,OAAO,eAAe,YAAY,GAAI,QAAO,aAAa;;;AAInG,iBAAgB,KAAK;AACrB,iBAAgB,cAAc;AAC9B,2BAA0B,gBAAgB,mBAAmB;AAC7D,2BAA0B,gBAAgB,eAAe;AACzD,2BAA0B,gBAAgB,gBAAgB;AAC1D,2BAA0B,gBAAgB,aAAa;AACvD,2BAA0B,gBAAgB,qBAAqB;AAC/D,2BAA0B,gBAAgB,qBAAqB;CAG/D,MAAM,SAAS,OAAO,OAAO,CAC3B,cAAc,OAAO,uBAAuB,EAC5C,kBAAkB,WAAW,KAAK,UAAU,gBAAgB,CAAC,CAC9D,CAAC;CAEF,MAAM,kBAAkB,iBAAiB,OAAO,QAAQ,YAAY;CAEpE,MAAM,eAAe,aAAa,oBAAoB,gBAAgB;AAGtE,QAAO;EAAE;EAAc,aAFH,GAAG,aAAa,GAAG;EAEH"}