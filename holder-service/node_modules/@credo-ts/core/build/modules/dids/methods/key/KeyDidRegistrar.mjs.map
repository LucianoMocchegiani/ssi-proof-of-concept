{"version":3,"file":"KeyDidRegistrar.mjs","names":[],"sources":["../../../../../src/modules/dids/methods/key/KeyDidRegistrar.ts"],"sourcesContent":["import type { AgentContext } from '../../../../agent'\nimport type { XOR } from '../../../../types'\nimport {\n  KeyManagementApi,\n  type KmsCreateKeyOptions,\n  type KmsCreateKeyTypeAssymetric,\n  type KmsJwkPublicAsymmetric,\n  PublicJwk,\n} from '../../../kms'\nimport { DidDocumentRole } from '../../domain/DidDocumentRole'\nimport type { DidRegistrar } from '../../domain/DidRegistrar'\nimport { DidRecord, DidRepository } from '../../repository'\nimport type { DidCreateOptions, DidCreateResult, DidDeactivateResult, DidUpdateResult } from '../../types'\nimport { DidKey } from './DidKey'\n\nexport class KeyDidRegistrar implements DidRegistrar {\n  public readonly supportedMethods = ['key']\n\n  public async create(agentContext: AgentContext, options: KeyDidCreateOptions): Promise<DidCreateResult> {\n    const didRepository = agentContext.dependencyManager.resolve(DidRepository)\n\n    try {\n      let publicJwk: KmsJwkPublicAsymmetric\n      let keyId: string\n      const kms = agentContext.dependencyManager.resolve(KeyManagementApi)\n\n      if (options.options.createKey) {\n        const createKeyResult = await kms.createKey(options.options.createKey)\n        publicJwk = createKeyResult.publicJwk\n        keyId = createKeyResult.keyId\n      } else {\n        const _publicJwk = await kms.getPublicKey({\n          keyId: options.options.keyId,\n        })\n        keyId = options.options.keyId\n        if (!_publicJwk) {\n          return {\n            didDocumentMetadata: {},\n            didRegistrationMetadata: {},\n            didState: {\n              state: 'failed',\n              reason: `notFound: key with key id '${options.options.keyId}' not found`,\n            },\n          }\n        }\n\n        if (_publicJwk.kty === 'oct') {\n          return {\n            didDocumentMetadata: {},\n            didRegistrationMetadata: {},\n            didState: {\n              state: 'failed',\n              reason: `notFound: key with key id '${options.options.keyId}' uses unsupported kty 'oct' for did:key`,\n            },\n          }\n        }\n\n        publicJwk = _publicJwk\n      }\n\n      const jwk = PublicJwk.fromPublicJwk(publicJwk)\n      const didKey = new DidKey(jwk)\n\n      // Save the did so we know we created it and can issue with it\n      const didRecord = new DidRecord({\n        did: didKey.did,\n        role: DidDocumentRole.Created,\n\n        keys: [\n          {\n            didDocumentRelativeKeyId: `#${didKey.publicJwk.fingerprint}`,\n            kmsKeyId: keyId,\n          },\n        ],\n      })\n      await didRepository.save(agentContext, didRecord)\n\n      return {\n        didDocumentMetadata: {},\n        didRegistrationMetadata: {},\n        didState: {\n          state: 'finished',\n          did: didKey.did,\n          didDocument: didKey.didDocument,\n          secret: {},\n        },\n      }\n    } catch (error) {\n      return {\n        didDocumentMetadata: {},\n        didRegistrationMetadata: {},\n        didState: {\n          state: 'failed',\n          reason: `unknownError: ${error.message}`,\n        },\n      }\n    }\n  }\n\n  public async update(): Promise<DidUpdateResult> {\n    return {\n      didDocumentMetadata: {},\n      didRegistrationMetadata: {},\n      didState: {\n        state: 'failed',\n        reason: 'notSupported: cannot update did:key did',\n      },\n    }\n  }\n\n  public async deactivate(): Promise<DidDeactivateResult> {\n    return {\n      didDocumentMetadata: {},\n      didRegistrationMetadata: {},\n      didState: {\n        state: 'failed',\n        reason: 'notSupported: cannot deactivate did:key did',\n      },\n    }\n  }\n}\n\nexport interface KeyDidCreateOptions extends DidCreateOptions {\n  method: 'key'\n  // For now we don't support creating a did:key with a did or did document\n  did?: never\n  didDocument?: never\n  secret?: never\n\n  /**\n   * You can create a did:key based on an existing `keyId`, or provide `createKey` options\n   * to create a new key.\n   */\n  options: XOR<{ createKey: KmsCreateKeyOptions<KmsCreateKeyTypeAssymetric> }, { keyId: string }>\n}\n\n// Update and Deactivate not supported for did:key\nexport type KeyDidUpdateOptions = never\nexport type KeyDidDeactivateOptions = never\n"],"mappings":";;;;;;;;;;;;AAeA,IAAa,kBAAb,MAAqD;;OACnC,mBAAmB,CAAC,MAAM;;CAE1C,MAAa,OAAO,cAA4B,SAAwD;EACtG,MAAM,gBAAgB,aAAa,kBAAkB,QAAQ,cAAc;AAE3E,MAAI;GACF,IAAI;GACJ,IAAI;GACJ,MAAM,MAAM,aAAa,kBAAkB,QAAQ,iBAAiB;AAEpE,OAAI,QAAQ,QAAQ,WAAW;IAC7B,MAAM,kBAAkB,MAAM,IAAI,UAAU,QAAQ,QAAQ,UAAU;AACtE,gBAAY,gBAAgB;AAC5B,YAAQ,gBAAgB;UACnB;IACL,MAAM,aAAa,MAAM,IAAI,aAAa,EACxC,OAAO,QAAQ,QAAQ,OACxB,CAAC;AACF,YAAQ,QAAQ,QAAQ;AACxB,QAAI,CAAC,WACH,QAAO;KACL,qBAAqB,EAAE;KACvB,yBAAyB,EAAE;KAC3B,UAAU;MACR,OAAO;MACP,QAAQ,8BAA8B,QAAQ,QAAQ,MAAM;MAC7D;KACF;AAGH,QAAI,WAAW,QAAQ,MACrB,QAAO;KACL,qBAAqB,EAAE;KACvB,yBAAyB,EAAE;KAC3B,UAAU;MACR,OAAO;MACP,QAAQ,8BAA8B,QAAQ,QAAQ,MAAM;MAC7D;KACF;AAGH,gBAAY;;GAId,MAAM,SAAS,IAAI,OADP,UAAU,cAAc,UAAU,CAChB;GAG9B,MAAM,YAAY,IAAI,UAAU;IAC9B,KAAK,OAAO;IACZ,MAAM,gBAAgB;IAEtB,MAAM,CACJ;KACE,0BAA0B,IAAI,OAAO,UAAU;KAC/C,UAAU;KACX,CACF;IACF,CAAC;AACF,SAAM,cAAc,KAAK,cAAc,UAAU;AAEjD,UAAO;IACL,qBAAqB,EAAE;IACvB,yBAAyB,EAAE;IAC3B,UAAU;KACR,OAAO;KACP,KAAK,OAAO;KACZ,aAAa,OAAO;KACpB,QAAQ,EAAE;KACX;IACF;WACM,OAAO;AACd,UAAO;IACL,qBAAqB,EAAE;IACvB,yBAAyB,EAAE;IAC3B,UAAU;KACR,OAAO;KACP,QAAQ,iBAAiB,MAAM;KAChC;IACF;;;CAIL,MAAa,SAAmC;AAC9C,SAAO;GACL,qBAAqB,EAAE;GACvB,yBAAyB,EAAE;GAC3B,UAAU;IACR,OAAO;IACP,QAAQ;IACT;GACF;;CAGH,MAAa,aAA2C;AACtD,SAAO;GACL,qBAAqB,EAAE;GACvB,yBAAyB,EAAE;GAC3B,UAAU;IACR,OAAO;IACP,QAAQ;IACT;GACF"}