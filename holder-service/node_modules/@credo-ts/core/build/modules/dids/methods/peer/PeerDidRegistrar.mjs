

import { JsonTransformer } from "../../../../utils/JsonTransformer.mjs";
import "../../../../utils/index.mjs";
import { PublicJwk } from "../../../kms/jwk/PublicJwk.mjs";
import { KeyManagementApi } from "../../../kms/KeyManagementApi.mjs";
import "../../../kms/index.mjs";
import { DidDocument } from "../../domain/DidDocument.mjs";
import { DidDocumentRole } from "../../domain/DidDocumentRole.mjs";
import "../../domain/index.mjs";
import { DidRecord } from "../../repository/DidRecord.mjs";
import { DidRepository } from "../../repository/DidRepository.mjs";
import "../../repository/index.mjs";
import { didDocumentToNumAlgo4Did } from "./peerDidNumAlgo4.mjs";
import { PeerDidNumAlgo, getAlternativeDidsForPeerDid } from "./didPeer.mjs";
import { publicJwkToNumAlgo0DidDocument } from "./peerDidNumAlgo0.mjs";
import { didDocumentJsonToNumAlgo1Did } from "./peerDidNumAlgo1.mjs";
import { didDocumentToNumAlgo2Did } from "./peerDidNumAlgo2.mjs";

//#region src/modules/dids/methods/peer/PeerDidRegistrar.ts
var PeerDidRegistrar = class {
	constructor() {
		this.supportedMethods = ["peer"];
	}
	async create(agentContext, options) {
		const kms = agentContext.dependencyManager.resolve(KeyManagementApi);
		const didRepository = agentContext.dependencyManager.resolve(DidRepository);
		let did;
		let didDocument;
		let keys;
		try {
			if (isPeerDidNumAlgo0CreateOptions(options)) {
				let publicJwk;
				if (options.options.createKey) {
					const createKeyResult = await kms.createKey(options.options.createKey);
					publicJwk = PublicJwk.fromPublicJwk(createKeyResult.publicJwk);
					keys = [{
						didDocumentRelativeKeyId: `#${publicJwk.fingerprint}`,
						kmsKeyId: createKeyResult.keyId
					}];
				} else {
					const _publicJwk = await kms.getPublicKey({ keyId: options.options.keyId });
					if (!_publicJwk) return {
						didDocumentMetadata: {},
						didRegistrationMetadata: {},
						didState: {
							state: "failed",
							reason: `notFound: key with key id '${options.options.keyId}' not found`
						}
					};
					if (_publicJwk.kty === "oct") return {
						didDocumentMetadata: {},
						didRegistrationMetadata: {},
						didState: {
							state: "failed",
							reason: `notFound: key with key id '${options.options.keyId}' uses unsupported kty 'oct' for did:key`
						}
					};
					publicJwk = PublicJwk.fromPublicJwk(_publicJwk);
					keys = [{
						didDocumentRelativeKeyId: `#${publicJwk.fingerprint}`,
						kmsKeyId: options.options.keyId
					}];
				}
				didDocument = publicJwkToNumAlgo0DidDocument(publicJwk);
				did = didDocument.id;
			} else if (isPeerDidNumAlgo1CreateOptions(options)) {
				const didDocumentJson = options.didDocument.toJSON();
				did = didDocumentJsonToNumAlgo1Did(didDocumentJson);
				keys = options.options.keys;
				didDocument = JsonTransformer.fromJSON({
					...didDocumentJson,
					id: did
				}, DidDocument);
			} else if (isPeerDidNumAlgo2CreateOptions(options)) {
				const didDocumentJson = options.didDocument.toJSON();
				did = didDocumentToNumAlgo2Did(options.didDocument);
				keys = options.options.keys;
				didDocument = JsonTransformer.fromJSON({
					...didDocumentJson,
					id: did
				}, DidDocument);
			} else if (isPeerDidNumAlgo4CreateOptions(options)) {
				const didDocumentJson = options.didDocument.toJSON();
				keys = options.options.keys;
				const { longFormDid, shortFormDid } = didDocumentToNumAlgo4Did(options.didDocument);
				did = longFormDid;
				didDocument = JsonTransformer.fromJSON({
					...didDocumentJson,
					id: longFormDid,
					alsoKnownAs: [shortFormDid]
				}, DidDocument);
			} else return {
				didDocumentMetadata: {},
				didRegistrationMetadata: {},
				didState: {
					state: "failed",
					reason: "Missing or incorrect numAlgo provided"
				}
			};
			if (!keys || keys.length === 0) return {
				didDocumentMetadata: {},
				didRegistrationMetadata: {},
				didState: {
					state: "failed",
					reason: `Missing required 'keys' linking did document verification method id to the kms key id. Provide at least one key in the create options`
				}
			};
			const didRecord = new DidRecord({
				did,
				role: DidDocumentRole.Created,
				didDocument: isPeerDidNumAlgo1CreateOptions(options) ? didDocument : void 0,
				keys,
				tags: {
					recipientKeyFingerprints: didDocument.recipientKeys.map((key) => key.fingerprint),
					alternativeDids: getAlternativeDidsForPeerDid(did)
				}
			});
			await didRepository.save(agentContext, didRecord);
			return {
				didDocumentMetadata: {},
				didRegistrationMetadata: {},
				didState: {
					state: "finished",
					did: didDocument.id,
					didDocument
				}
			};
		} catch (error) {
			return {
				didDocumentMetadata: {},
				didRegistrationMetadata: {},
				didState: {
					state: "failed",
					reason: `unknownError: ${error.message}`
				}
			};
		}
	}
	async update() {
		return {
			didDocumentMetadata: {},
			didRegistrationMetadata: {},
			didState: {
				state: "failed",
				reason: "notImplemented: updating did:peer not implemented yet"
			}
		};
	}
	async deactivate() {
		return {
			didDocumentMetadata: {},
			didRegistrationMetadata: {},
			didState: {
				state: "failed",
				reason: "notImplemented: deactivating did:peer not implemented yet"
			}
		};
	}
};
function isPeerDidNumAlgo1CreateOptions(options) {
	return options.options.numAlgo === PeerDidNumAlgo.GenesisDoc;
}
function isPeerDidNumAlgo0CreateOptions(options) {
	return options.options.numAlgo === PeerDidNumAlgo.InceptionKeyWithoutDoc;
}
function isPeerDidNumAlgo2CreateOptions(options) {
	return options.options.numAlgo === PeerDidNumAlgo.MultipleInceptionKeyWithoutDoc;
}
function isPeerDidNumAlgo4CreateOptions(options) {
	return options.options.numAlgo === PeerDidNumAlgo.ShortFormAndLongForm;
}

//#endregion
export { PeerDidRegistrar };
//# sourceMappingURL=PeerDidRegistrar.mjs.map