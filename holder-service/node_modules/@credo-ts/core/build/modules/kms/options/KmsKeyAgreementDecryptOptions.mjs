

import { zAnyUint8Array } from "../../../utils/zod.mjs";
import { zKmsJwkPublicOkp } from "../jwk/kty/okp/okpJwk.mjs";
import { zKmsKeyId } from "./common.mjs";
import { zKmsJwkPublicEcdh, zKmsKeyAgreementEcdhEs } from "./KmsKeyAgreementEncryptOptions.mjs";
import { zKmsEncryptedKey } from "./KmsEncryptOptions.mjs";
import { z } from "zod";

//#region src/modules/kms/options/KmsKeyAgreementDecryptOptions.ts
const zKmsKeyAgreementDecryptEcdhEsKw = z.object({
	keyId: zKmsKeyId,
	algorithm: z.enum([
		"ECDH-ES+A128KW",
		"ECDH-ES+A192KW",
		"ECDH-ES+A256KW"
	]),
	externalPublicJwk: zKmsJwkPublicEcdh,
	encryptedKey: zKmsEncryptedKey,
	apu: z.optional(zAnyUint8Array),
	apv: z.optional(zAnyUint8Array)
});
const zKmsKeyAgreementDecryptEcdhHsalsa20 = z.object({
	keyId: zKmsKeyId,
	algorithm: z.literal("ECDH-HSALSA20"),
	externalPublicJwk: zKmsJwkPublicOkp.extend({ crv: zKmsJwkPublicOkp.shape.crv.extract(["X25519"]) }).optional()
});
const zKmsKeyAgreementDecryptOptions = z.discriminatedUnion("algorithm", [
	zKmsKeyAgreementEcdhEs,
	zKmsKeyAgreementDecryptEcdhEsKw,
	zKmsKeyAgreementDecryptEcdhHsalsa20
]).describe("Options for key agreement based on an assymetric key.");

//#endregion
export { zKmsKeyAgreementDecryptOptions };
//# sourceMappingURL=KmsKeyAgreementDecryptOptions.mjs.map