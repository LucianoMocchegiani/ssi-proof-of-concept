

import { zAnyUint8Array } from "../../../utils/zod.mjs";
import { zKmsJwkPublicEc } from "../jwk/kty/ec/ecJwk.mjs";
import { zKmsJwkPublicOkp } from "../jwk/kty/okp/okpJwk.mjs";
import { zKmsKeyId } from "./common.mjs";
import { z } from "zod";

//#region src/modules/kms/options/KmsKeyAgreementEncryptOptions.ts
const zKmsJwkPublicEcdh = z.union([zKmsJwkPublicOkp.extend({ crv: zKmsJwkPublicOkp.shape.crv.extract(["X25519"]) }), zKmsJwkPublicEc.extend({ crv: zKmsJwkPublicEc.shape.crv.extract([
	"P-256",
	"P-384",
	"P-521",
	"secp256k1"
]) })]);
const zKmsKeyAgreementEcdhEs = z.object({
	keyId: zKmsKeyId,
	algorithm: z.literal("ECDH-ES"),
	externalPublicJwk: zKmsJwkPublicEcdh,
	apu: z.optional(zAnyUint8Array),
	apv: z.optional(zAnyUint8Array)
});
const zKmsKeyAgreementEncryptEcdhEsKw = z.object({
	keyId: zKmsKeyId,
	algorithm: z.enum([
		"ECDH-ES+A128KW",
		"ECDH-ES+A192KW",
		"ECDH-ES+A256KW"
	]),
	externalPublicJwk: zKmsJwkPublicEcdh,
	apu: z.optional(zAnyUint8Array),
	apv: z.optional(zAnyUint8Array)
});
const zKmsKeyAgreementEncryptEcdhHsalsa20 = z.object({
	keyId: zKmsKeyId.optional(),
	algorithm: z.literal("ECDH-HSALSA20"),
	externalPublicJwk: zKmsJwkPublicOkp.extend({ crv: zKmsJwkPublicOkp.shape.crv.extract(["X25519"]) })
});
const zKmsKeyAgreementEncryptOptions = z.discriminatedUnion("algorithm", [
	zKmsKeyAgreementEcdhEs,
	zKmsKeyAgreementEncryptEcdhEsKw,
	zKmsKeyAgreementEncryptEcdhHsalsa20
]).describe("Options for key agreement based on an assymetric key.");

//#endregion
export { zKmsJwkPublicEcdh, zKmsKeyAgreementEcdhEs, zKmsKeyAgreementEncryptOptions };
//# sourceMappingURL=KmsKeyAgreementEncryptOptions.mjs.map