import { KmsCreateKeyForSignatureAlgorithmOptions, KmsCreateKeyOptions, KmsCreateKeyReturn, KmsCreateKeyType, KmsCreateKeyTypeAssymetric } from "./options/KmsCreateKeyOptions.mjs";
import { KmsDecryptOptions, KmsDecryptReturn } from "./options/KmsDecryptOptions.mjs";
import { KmsDeleteKeyOptions } from "./options/KmsDeleteKeyOptions.mjs";
import { KmsEncryptOptions, KmsEncryptReturn } from "./options/KmsEncryptOptions.mjs";
import { KmsGetPublicKeyOptions } from "./options/KmsGetPublicKeyOptions.mjs";
import { KmsImportKeyOptions, KmsImportKeyReturn } from "./options/KmsImportKeyOptions.mjs";
import { KmsOperation } from "./options/KmsOperation.mjs";
import { KmsRandomBytesOptions, KmsRandomBytesReturn } from "./options/KmsRandomBytesOptions.mjs";
import { KmsSignOptions, KmsSignReturn } from "./options/KmsSignOptions.mjs";
import { KmsVerifyOptions, KmsVerifyReturn } from "./options/KmsVerifyOptions.mjs";
import "./options/index.mjs";
import { KmsJwkPrivate } from "./jwk/knownJwk.mjs";
import "./jwk/index.mjs";
import { KeyManagementModuleConfig } from "./KeyManagementModuleConfig.mjs";
import { WithBackend } from "./options/backend.mjs";
import { AgentContext } from "../../agent/context/AgentContext.mjs";
import "../../agent/index.mjs";

//#region src/modules/kms/KeyManagementApi.d.ts
declare class KeyManagementApi {
  private keyManagementConfig;
  private agentContext;
  constructor(keyManagementConfig: KeyManagementModuleConfig, agentContext: AgentContext);
  /**
   * Whether an operation is supported.
   *
   * @returns a list of backends that support the operation. In case
   * no backends are supported it returns an empty array
   */
  supportedBackendsForOperation(operation: KmsOperation): string[];
  /**
   * Create a key.
   */
  createKey<Type extends KmsCreateKeyType>(options: WithBackend<KmsCreateKeyOptions<Type>>): Promise<KmsCreateKeyReturn<Type>>;
  /**
   * Create a key.
   */
  createKeyForSignatureAlgorithm(options: WithBackend<KmsCreateKeyForSignatureAlgorithmOptions>): Promise<KmsCreateKeyReturn<KmsCreateKeyTypeAssymetric>>;
  /**
   * Sign using a key.
   */
  sign(options: WithBackend<KmsSignOptions>): Promise<KmsSignReturn>;
  /**
   * Verify using a key.
   */
  verify(options: WithBackend<KmsVerifyOptions>): Promise<KmsVerifyReturn>;
  /**
   * Encrypt.
   */
  encrypt(options: WithBackend<KmsEncryptOptions>): Promise<KmsEncryptReturn>;
  /**
   * Decrypt.
   */
  decrypt(options: WithBackend<KmsDecryptOptions>): Promise<KmsDecryptReturn>;
  /**
   * Import a key.
   */
  importKey<Jwk extends KmsJwkPrivate>(options: WithBackend<KmsImportKeyOptions<Jwk>>): Promise<KmsImportKeyReturn<Jwk>>;
  /**
   * Get a public key.
   */
  getPublicKey(options: WithBackend<KmsGetPublicKeyOptions>): Promise<{
    kty: "EC";
    crv: "P-256" | "P-384" | "P-521" | "secp256k1";
    x: string;
    y: string;
    d?: undefined;
    kid?: string | undefined;
    alg?: string | undefined;
    key_ops?: string[] | undefined;
    use?: string | undefined;
    ext?: boolean | undefined;
    x5c?: string[] | undefined;
    x5t?: string | undefined;
    'x5t#S256'?: string | undefined;
    x5u?: string | undefined;
  } | {
    kty: "RSA";
    n: string;
    e: string;
    d?: undefined;
    p?: undefined;
    q?: undefined;
    dp?: undefined;
    dq?: undefined;
    qi?: undefined;
    oth?: undefined;
    kid?: string | undefined;
    alg?: string | undefined;
    key_ops?: string[] | undefined;
    use?: string | undefined;
    ext?: boolean | undefined;
    x5c?: string[] | undefined;
    x5t?: string | undefined;
    'x5t#S256'?: string | undefined;
    x5u?: string | undefined;
  } | {
    kty: "oct";
    k?: undefined;
    kid?: string | undefined;
    alg?: string | undefined;
    key_ops?: string[] | undefined;
    use?: string | undefined;
    ext?: boolean | undefined;
    x5c?: string[] | undefined;
    x5t?: string | undefined;
    'x5t#S256'?: string | undefined;
    x5u?: string | undefined;
  } | {
    kty: "OKP";
    crv: "Ed25519" | "X25519";
    x: string;
    d?: string | undefined;
    kid?: string | undefined;
    alg?: string | undefined;
    key_ops?: string[] | undefined;
    use?: string | undefined;
    ext?: boolean | undefined;
    x5c?: string[] | undefined;
    x5t?: string | undefined;
    'x5t#S256'?: string | undefined;
    x5u?: string | undefined;
  }>;
  /**
   * Delete a key.
   */
  deleteKey(options: WithBackend<KmsDeleteKeyOptions>): Promise<boolean>;
  /**
   * Generate random bytes
   */
  randomBytes(options: WithBackend<KmsRandomBytesOptions>): KmsRandomBytesReturn;
  /**
   * Get the kms associated with a specific `keyId`.
   *
   * This uses a naive approach of fetching the key for each configured kms
   * until it finds the registered key.
   *
   * In the future this approach might be optimized based on:
   * - caching
   * - keeping a registry
   * - backend specific key prefixes
   */
  private getKmsForOperationAndKeyId;
  /**
   * Get the kms backend for a specific operation.
   *
   * If a backend is provided, it will be checked if the backend supports
   * the operation. Otherwise the first backend that supports the operation
   * will be used.
   */
  private getKms;
}
//#endregion
export { KeyManagementApi };
//# sourceMappingURL=KeyManagementApi.d.mts.map