import { KmsCreateKeyOptions, KmsCreateKeyReturn, KmsCreateKeyType } from "./options/KmsCreateKeyOptions.mjs";
import { KmsDecryptOptions, KmsDecryptReturn } from "./options/KmsDecryptOptions.mjs";
import { KmsDeleteKeyOptions } from "./options/KmsDeleteKeyOptions.mjs";
import { KmsEncryptOptions, KmsEncryptReturn } from "./options/KmsEncryptOptions.mjs";
import { KmsImportKeyOptions, KmsImportKeyReturn } from "./options/KmsImportKeyOptions.mjs";
import { KmsOperation } from "./options/KmsOperation.mjs";
import { KmsRandomBytesOptions, KmsRandomBytesReturn } from "./options/KmsRandomBytesOptions.mjs";
import { KmsSignOptions, KmsSignReturn } from "./options/KmsSignOptions.mjs";
import { KmsVerifyOptions, KmsVerifyReturn } from "./options/KmsVerifyOptions.mjs";
import "./options/index.mjs";
import { KmsJwkPrivate, KmsJwkPublic } from "./jwk/knownJwk.mjs";
import { AgentContext } from "../../agent/context/AgentContext.mjs";
import "../../agent/index.mjs";

//#region src/modules/kms/KeyManagementService.d.ts
interface KeyManagementService {
  /**
   * The 'backend' name of this key management service
   */
  readonly backend: string;
  /**
   * Whether this backend supports an operation. Generally if no backend is provided
   * for an operation the first supported backend will be chosen. For operations based on
   * a key id, the first supported backed will be checked whether it can handle that specific
   * key id.
   */
  isOperationSupported(agentContext: AgentContext, operation: KmsOperation): boolean;
  /**
   * Get the public representation of a key.
   *
   * In case of a symmetric key the returned JWK won't include
   * any cryptographic key material itself, but will include
   * all the key related metadata.
   */
  getPublicKey(agentContext: AgentContext, keyId: string): Promise<KmsJwkPublic | null>;
  /**
   * Create a key
   */
  createKey<Type extends KmsCreateKeyType>(agentContext: AgentContext, options: KmsCreateKeyOptions<Type>): Promise<KmsCreateKeyReturn<Type>>;
  /**
   * Import a key
   */
  importKey<Jwk extends KmsJwkPrivate>(agentContext: AgentContext, options: KmsImportKeyOptions<Jwk>): Promise<KmsImportKeyReturn<Jwk>>;
  /**
   * Delete a key.
   *
   * @returns boolean whether the key was removed.
   */
  deleteKey(agentContext: AgentContext, options: KmsDeleteKeyOptions): Promise<boolean>;
  /**
   * Sign with a specific key
   */
  sign(agentContext: AgentContext, options: KmsSignOptions): Promise<KmsSignReturn>;
  /**
   * Verify with a specific key
   */
  verify(agentContext: AgentContext, options: KmsVerifyOptions): Promise<KmsVerifyReturn>;
  /**
   * Encrypt data
   */
  encrypt(agentContext: AgentContext, options: KmsEncryptOptions): Promise<KmsEncryptReturn>;
  /**
   * Decrypt data
   */
  decrypt(agentContext: AgentContext, options: KmsDecryptOptions): Promise<KmsDecryptReturn>;
  /**
   * Generate secure random bytes
   */
  randomBytes(agentContext: AgentContext, options: KmsRandomBytesOptions): KmsRandomBytesReturn;
}
//#endregion
export { KeyManagementService };
//# sourceMappingURL=KeyManagementService.d.mts.map