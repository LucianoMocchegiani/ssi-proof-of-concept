

import { KeyManagementError } from "../error/KeyManagementError.mjs";
import { getJwkHumanDescription } from "./humanDescription.mjs";

//#region src/modules/kms/jwk/equals.ts
/**
* Checks if two JWK public keys have matching key types
* Supports EC, OKP, and RSA key types
*/
function assymetricJwkKeyTypeMatches(first, second) {
	if (first.kty !== second.kty) return false;
	if (first.kty === "EC" && second.kty === "EC") return first.crv === second.crv;
	if (first.kty === "OKP" && second.kty === "OKP") return first.crv === second.crv;
	if (first.kty === "RSA" && second.kty === "RSA") return true;
	return false;
}
/**
* Checks if two JWK public keys have matching key types
* Supports EC, OKP, and RSA key types
*/
function assertAsymmetricJwkKeyTypeMatches(first, second) {
	if (!assymetricJwkKeyTypeMatches(first, second)) throw new KeyManagementError(`Expected jwk types to match, but found ${getJwkHumanDescription(first)} and ${getJwkHumanDescription(second)}`);
}
/**
* Checks if two JWK public keys have matching key material
* Supports EC, OKP, and RSA key types
*/
function asymmetricPublicJwkMatches(first, second) {
	if (!assymetricJwkKeyTypeMatches(first, second)) return false;
	if (first.kty === "EC" && second.kty === "EC") return first.x === second.x && first.y === second.y;
	if (first.kty === "OKP" && second.kty === "OKP") return first.x === second.x;
	if (first.kty === "RSA" && second.kty === "RSA") return first.n === second.n && first.e === second.e;
	return false;
}

//#endregion
export { assertAsymmetricJwkKeyTypeMatches, assymetricJwkKeyTypeMatches, asymmetricPublicJwkMatches };
//# sourceMappingURL=equals.mjs.map