

import { TypedArrayEncoder } from "../../../../../utils/TypedArrayEncoder.mjs";
import "../../../../../utils/index.mjs";
import { KeyManagementError } from "../../../error/KeyManagementError.mjs";
import { rsaPublicJwkToPublicKey, rsaPublicKeyToPublicJwk } from "./rsaPublicKey.mjs";

//#region src/modules/kms/jwk/kty/rsa/RsaPublicJwk.ts
var RsaPublicJwk = class RsaPublicJwk {
	get supportedSignatureAlgorithms() {
		const keyBits = TypedArrayEncoder.fromBase64(this.jwk.n).length * 8;
		const minBits2048 = ["PS256", "RS256"];
		const minBits3072 = [
			...minBits2048,
			"RS384",
			"PS384"
		];
		const minBits4096 = [
			...minBits3072,
			"RS512",
			"PS512"
		];
		return keyBits >= 4096 ? minBits4096 : keyBits >= 3072 ? minBits3072 : keyBits >= 2048 ? minBits2048 : [];
	}
	constructor(jwk) {
		this.jwk = jwk;
		this.multicodecPrefix = RsaPublicJwk.multicodecPrefix;
		this.supportedEncryptionKeyAgreementAlgorithms = RsaPublicJwk.supportedEncryptionKeyAgreementAlgorithms;
	}
	get publicKey() {
		return {
			kty: this.jwk.kty,
			...rsaPublicJwkToPublicKey(this.jwk)
		};
	}
	/**
	* Not supported for RSA
	*/
	get compressedPublicKey() {
		return null;
	}
	get multicodec() {
		throw new KeyManagementError("multicodec not supported for RsaPublicJwk");
	}
	static fromPublicKey(publicKey) {
		return new RsaPublicJwk(rsaPublicKeyToPublicJwk(publicKey));
	}
	static fromMulticodec(_multicodec) {
		throw new KeyManagementError("fromMulticodec not supported for RsaPublicJwk");
	}
};
RsaPublicJwk.supportedEncryptionKeyAgreementAlgorithms = [];
RsaPublicJwk.supportedSignatureAlgorithms = [
	"PS256",
	"RS256",
	"RS384",
	"PS384",
	"RS512",
	"PS512"
];
RsaPublicJwk.multicodecPrefix = 4613;

//#endregion
export { RsaPublicJwk };
//# sourceMappingURL=RsaPublicJwk.mjs.map