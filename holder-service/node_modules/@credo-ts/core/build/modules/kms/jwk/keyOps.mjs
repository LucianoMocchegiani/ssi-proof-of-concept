

import { KeyManagementError } from "../error/KeyManagementError.mjs";
import { getJwkHumanDescription } from "./humanDescription.mjs";
import { zUniqueArray } from "../../../utils/zod.mjs";
import { z } from "zod";

//#region src/modules/kms/jwk/keyOps.ts
const zKnownJwkUse = z.union([z.literal("sig").describe("signature"), z.literal("enc").describe("encryption")]);
const zJwkUse = z.union([zKnownJwkUse, z.string()]);
const zKnownJwkKeyOps = z.union([
	z.literal("sign").describe("compute digital signature or MAC"),
	z.literal("verify").describe("verify digital signature or MAC"),
	z.literal("encrypt").describe("encrypt content"),
	z.literal("decrypt").describe("decrypt content and validate decryption, if applicable"),
	z.literal("wrapKey").describe("encrypt key"),
	z.literal("unwrapKey").describe("decrypt key and validate decryption, if applicable"),
	z.literal("deriveKey").describe("derive key"),
	z.literal("deriveBits").describe("derive bits not to be used as a key")
]);
const zJwkKeyOps = zUniqueArray(z.union([zKnownJwkKeyOps, z.string()]));
function keyAllowsDerive(key) {
	if (key.use && key.use !== "enc") return false;
	if (key.key_ops && !key.key_ops.includes("deriveKey")) return false;
	return true;
}
function assertKeyAllowsDerive(jwk) {
	if (!keyAllowsDerive(jwk)) throw new KeyManagementError(`${getJwkHumanDescription(jwk)} usage does not allow key derivation operations`);
}
function keyAllowsVerify(key) {
	if (key.use && key.use !== "sig") return false;
	if (key.key_ops && !key.key_ops.includes("verify")) return false;
	return true;
}
function assertKeyAllowsVerify(jwk) {
	if (!keyAllowsVerify(jwk)) throw new KeyManagementError(`${getJwkHumanDescription(jwk)} usage does not allow verification operations`);
}
function keyAllowsSign(key) {
	if (key.use && key.use !== "sig") return false;
	if (key.key_ops && !key.key_ops.includes("sign")) return false;
	return true;
}
function assertKeyAllowsSign(jwk) {
	if (!keyAllowsSign(jwk)) throw new KeyManagementError(`${getJwkHumanDescription(jwk)} usage does not allow signing operations`);
}
function keyAllowsEncrypt(key) {
	if (key.use && key.use !== "enc") return false;
	if (key.key_ops && !key.key_ops.includes("encrypt")) return false;
	return true;
}
function assertKeyAllowsEncrypt(jwk) {
	if (!keyAllowsEncrypt(jwk)) throw new KeyManagementError(`${getJwkHumanDescription(jwk)} usage does not allow encryption operations`);
}
function keyAllowsDecrypt(key) {
	if (key.use && key.use !== "enc") return false;
	if (key.key_ops && !key.key_ops.includes("decrypt")) return false;
	return true;
}
function assertKeyAllowsDecrypt(jwk) {
	if (!keyAllowsDecrypt(jwk)) throw new KeyManagementError(`${getJwkHumanDescription(jwk)} usage does not allow decryption operations`);
}

//#endregion
export { assertKeyAllowsDecrypt, assertKeyAllowsDerive, assertKeyAllowsEncrypt, assertKeyAllowsSign, assertKeyAllowsVerify, keyAllowsDecrypt, keyAllowsEncrypt, keyAllowsSign, keyAllowsVerify, zJwkKeyOps, zJwkUse };
//# sourceMappingURL=keyOps.mjs.map