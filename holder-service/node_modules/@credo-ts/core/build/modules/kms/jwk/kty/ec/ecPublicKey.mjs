

import { TypedArrayEncoder } from "../../../../../utils/TypedArrayEncoder.mjs";
import "../../../../../utils/index.mjs";
import { KeyManagementError } from "../../../error/KeyManagementError.mjs";
import { AffinePoint, Secp256k1, Secp256r1, Secp384r1, Secp521r1, isValidCompressedPublicKeyFormat, isValidDecompressedPublicKeyFormat } from "ec-compression";

//#region src/modules/kms/jwk/kty/ec/ecPublicKey.ts
const ecCrvToCurveParams = {
	"P-256": Secp256r1,
	"P-384": Secp384r1,
	"P-521": Secp521r1,
	secp256k1: Secp256k1
};
function ecPublicJwkToPublicKey(publicJwk, { compressed = false } = {}) {
	const affinePoint = new AffinePoint(Uint8Array.from(TypedArrayEncoder.fromBase64(publicJwk.x)), Uint8Array.from(TypedArrayEncoder.fromBase64(publicJwk.y)));
	return compressed ? affinePoint.compressedForm : affinePoint.decompressedForm;
}
function ecPublicKeyToPublicJwk(publicKey, crv) {
	const curveParams = ecCrvToCurveParams[crv];
	if (!curveParams) throw new KeyManagementError(`kty EC with crv '${crv}' is not supported for creating jwk based on public key bytes`);
	let affinePoint;
	if (isValidCompressedPublicKeyFormat(publicKey, curveParams)) affinePoint = AffinePoint.fromCompressedPoint(publicKey, curveParams);
	else if (isValidDecompressedPublicKeyFormat(publicKey, curveParams)) affinePoint = AffinePoint.fromDecompressedPoint(publicKey, curveParams);
	else throw new KeyManagementError(`public key for kty EC with crv '${crv}' is neither a valid compressed or uncompressed key. Key prefix '${publicKey[0]}', key length '${publicKey.length}'`);
	return {
		kty: "EC",
		crv,
		x: TypedArrayEncoder.toBase64URL(affinePoint.xBytes),
		y: TypedArrayEncoder.toBase64URL(affinePoint.yBytes)
	};
}

//#endregion
export { ecCrvToCurveParams, ecPublicJwkToPublicKey, ecPublicKeyToPublicJwk };
//# sourceMappingURL=ecPublicKey.mjs.map