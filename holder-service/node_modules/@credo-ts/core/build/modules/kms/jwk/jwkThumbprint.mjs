

import { TypedArrayEncoder } from "../../../utils/TypedArrayEncoder.mjs";
import { Hasher } from "../../../crypto/hashes/Hasher.mjs";
import "../../../utils/index.mjs";
import { zParseWithErrorHandling } from "../../../utils/zod.mjs";
import { zKmsJwkPublic } from "./knownJwk.mjs";

//#region src/modules/kms/jwk/jwkThumbprint.ts
const zJwkThumbprintComponents = zKmsJwkPublic.transform((data) => {
	if (data.kty === "EC") return {
		crv: data.crv,
		kty: data.kty,
		x: data.x,
		y: data.y
	};
	if (data.kty === "OKP") return {
		crv: data.crv,
		kty: data.kty,
		x: data.x
	};
	if (data.kty === "RSA") return {
		e: data.e,
		kty: data.kty,
		n: data.n
	};
	if (data.kty === "oct") return {
		k: data.k,
		kty: data.kty
	};
	throw new Error("Unsupported kty");
});
function calculateJwkThumbprint(options) {
	const jwkThumbprintComponents = zParseWithErrorHandling(zJwkThumbprintComponents, options.jwk, `Provided jwk does not match a supported jwk structure. Either the 'kty' is not supported, or required values are missing.`);
	return Hasher.hash(TypedArrayEncoder.fromString(JSON.stringify(jwkThumbprintComponents)), options.hashAlgorithm);
}

//#endregion
export { calculateJwkThumbprint };
//# sourceMappingURL=jwkThumbprint.mjs.map