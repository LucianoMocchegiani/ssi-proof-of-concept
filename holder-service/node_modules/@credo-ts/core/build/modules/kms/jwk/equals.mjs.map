{"version":3,"file":"equals.mjs","names":[],"sources":["../../../../src/modules/kms/jwk/equals.ts"],"sourcesContent":["import { KeyManagementError } from '../error/KeyManagementError'\nimport { getJwkHumanDescription } from './humanDescription'\nimport type { KmsJwkPrivateAsymmetric, KmsJwkPublicAsymmetric } from './knownJwk'\n\n/**\n * Checks if two JWK public keys have matching key types\n * Supports EC, OKP, and RSA key types\n */\nexport function assymetricJwkKeyTypeMatches(\n  first: KmsJwkPublicAsymmetric | KmsJwkPrivateAsymmetric,\n  second: KmsJwkPublicAsymmetric | KmsJwkPrivateAsymmetric\n): boolean {\n  if (first.kty !== second.kty) return false\n\n  if (first.kty === 'EC' && second.kty === 'EC') {\n    return first.crv === second.crv\n  }\n\n  if (first.kty === 'OKP' && second.kty === 'OKP') {\n    return first.crv === second.crv\n  }\n\n  if (first.kty === 'RSA' && second.kty === 'RSA') {\n    // RSA doesn't have curve parameter, so key type match is sufficient\n    return true\n  }\n\n  // Unknown key type\n  return false\n}\n\n/**\n * Checks if two JWK public keys have matching key types\n * Supports EC, OKP, and RSA key types\n */\nexport function assertAsymmetricJwkKeyTypeMatches(\n  first: KmsJwkPublicAsymmetric | KmsJwkPrivateAsymmetric,\n  second: KmsJwkPublicAsymmetric | KmsJwkPrivateAsymmetric\n): asserts first is typeof second {\n  if (!assymetricJwkKeyTypeMatches(first, second)) {\n    throw new KeyManagementError(\n      `Expected jwk types to match, but found ${getJwkHumanDescription(first)} and ${getJwkHumanDescription(second)}`\n    )\n  }\n}\n\n/**\n * Checks if two JWK public keys have matching key material\n * Supports EC, OKP, and RSA key types\n */\nexport function asymmetricPublicJwkMatches(first: KmsJwkPublicAsymmetric, second: KmsJwkPublicAsymmetric): boolean {\n  // First check that types match\n  if (!assymetricJwkKeyTypeMatches(first, second)) {\n    return false\n  }\n\n  // For EC keys, compare x and y coordinates\n  if (first.kty === 'EC' && second.kty === 'EC') {\n    return first.x === second.x && first.y === second.y\n  }\n\n  // For OKP keys, compare x coordinate (Ed25519, X25519, etc.)\n  if (first.kty === 'OKP' && second.kty === 'OKP') {\n    return first.x === second.x\n  }\n\n  // For RSA keys, compare modulus (n) and exponent (e)\n  if (first.kty === 'RSA' && second.kty === 'RSA') {\n    return first.n === second.n && first.e === second.e\n  }\n\n  // Unknown key type\n  return false\n}\n"],"mappings":";;;;;;;;;;AAQA,SAAgB,4BACd,OACA,QACS;AACT,KAAI,MAAM,QAAQ,OAAO,IAAK,QAAO;AAErC,KAAI,MAAM,QAAQ,QAAQ,OAAO,QAAQ,KACvC,QAAO,MAAM,QAAQ,OAAO;AAG9B,KAAI,MAAM,QAAQ,SAAS,OAAO,QAAQ,MACxC,QAAO,MAAM,QAAQ,OAAO;AAG9B,KAAI,MAAM,QAAQ,SAAS,OAAO,QAAQ,MAExC,QAAO;AAIT,QAAO;;;;;;AAOT,SAAgB,kCACd,OACA,QACgC;AAChC,KAAI,CAAC,4BAA4B,OAAO,OAAO,CAC7C,OAAM,IAAI,mBACR,0CAA0C,uBAAuB,MAAM,CAAC,OAAO,uBAAuB,OAAO,GAC9G;;;;;;AAQL,SAAgB,2BAA2B,OAA+B,QAAyC;AAEjH,KAAI,CAAC,4BAA4B,OAAO,OAAO,CAC7C,QAAO;AAIT,KAAI,MAAM,QAAQ,QAAQ,OAAO,QAAQ,KACvC,QAAO,MAAM,MAAM,OAAO,KAAK,MAAM,MAAM,OAAO;AAIpD,KAAI,MAAM,QAAQ,SAAS,OAAO,QAAQ,MACxC,QAAO,MAAM,MAAM,OAAO;AAI5B,KAAI,MAAM,QAAQ,SAAS,OAAO,QAAQ,MACxC,QAAO,MAAM,MAAM,OAAO,KAAK,MAAM,MAAM,OAAO;AAIpD,QAAO"}