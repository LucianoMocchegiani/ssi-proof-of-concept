import { Constructor } from "../../../utils/mixins.mjs";
import { KnownJwaKeyAgreementAlgorithm, KnownJwaSignatureAlgorithm } from "./jwa.mjs";
import { KmsJwkPublicAsymmetric } from "./knownJwk.mjs";
import { P256PublicJwk } from "./kty/ec/P256PublicJwk.mjs";
import { P384PublicJwk } from "./kty/ec/P384PublicJwk.mjs";
import { P521PublicJwk } from "./kty/ec/P521PublicJwk.mjs";
import { Secp256k1PublicJwk } from "./kty/ec/Secp256k1PublicJwk.mjs";
import { Ed25519PublicJwk } from "./kty/okp/Ed25519PublicJwk.mjs";
import { X25519PublicJwk } from "./kty/okp/X25519PublicJwk.mjs";
import { RsaPublicJwk } from "./kty/rsa/RsaPublicJwk.mjs";
import "./kty/index.mjs";
import { HashName } from "../../../crypto/hashes/Hasher.mjs";
import "../../../crypto/index.mjs";

//#region src/modules/kms/jwk/PublicJwk.d.ts
declare const SupportedPublicJwks: (typeof Ed25519PublicJwk | typeof P256PublicJwk | typeof P384PublicJwk | typeof P521PublicJwk | typeof RsaPublicJwk | typeof Secp256k1PublicJwk | typeof X25519PublicJwk)[];
type SupportedPublicJwkClass = (typeof SupportedPublicJwks)[number];
type SupportedPublicJwk = Ed25519PublicJwk | P256PublicJwk | P384PublicJwk | P521PublicJwk | RsaPublicJwk | Secp256k1PublicJwk | X25519PublicJwk;
type ExtractByJwk<T, K> = T extends {
  jwk: infer J;
} ? (K extends J ? T : never) : never;
type ExtractByPublicKey<T, K> = T extends {
  publicKey: infer J;
} ? (K extends J ? T : never) : never;
declare class PublicJwk<Jwk extends SupportedPublicJwk = SupportedPublicJwk> {
  private readonly jwk;
  private constructor();
  static fromUnknown(jwkJson: unknown): PublicJwk<SupportedPublicJwk>;
  static fromPublicJwk<Jwk extends KmsJwkPublicAsymmetric>(jwk: Jwk): PublicJwk<ExtractByJwk<SupportedPublicJwk, Jwk> extends never ? SupportedPublicJwk : ExtractByJwk<SupportedPublicJwk, Jwk>>;
  toJson({
    includeKid
  }?: {
    includeKid?: boolean;
  }): Jwk['jwk'];
  /**
   * Get the signature algorithms supported for this jwk.
   *
   * If the jwk has an `alg` field defined it will only return that alg
   * and otherwise return all known supported signature algorithm.
   */
  get supportedSignatureAlgorithms(): KnownJwaSignatureAlgorithm[];
  get supportedEncryptionKeyAgreementAlgorithms(): KnownJwaKeyAgreementAlgorithm[];
  /**
   * key type as defined in [JWA Specification](https://tools.ietf.org/html/rfc7518#section-6.1)
   */
  get kty(): Jwk['jwk']['kty'];
  /**
   * Get the key id for a public jwk. If the public jwk does not have
   * a key id, an error will be thrown
   */
  get keyId(): string;
  get hasKeyId(): boolean;
  set keyId(keyId: string);
  get legacyKeyId(): string;
  get publicKey(): Jwk['publicKey'];
  /**
   * Return the compressed public key. If the key type does not support compressed public keys, it will return null
   */
  get compressedPublicKey(): Jwk['compressedPublicKey'];
  get JwkClass(): SupportedPublicJwkClass;
  /**
   * SHA-256 jwk thumbprint
   */
  getJwkThumbprint(hashAlgorithm?: HashName): Uint8Array<ArrayBuffer>;
  /**
   * Get the first signature algorithm to use with this jwk. If the jwk has an `alg` field defined
   * it will use that alg, and otherwise fall back to the first supported signature algorithm.
   *
   * If no algorithm is supported it will throw an error
   */
  get signatureAlgorithm(): this["supportedSignatureAlgorithms"][number];
  assertSignatureAlgorithmSupported(alg: KnownJwaSignatureAlgorithm): asserts alg is this['supportedSignatureAlgorithms'][number];
  static fromPublicKey<Supported extends SupportedPublicJwk['publicKey']>(publicKey: Supported): PublicJwk<ExtractByPublicKey<SupportedPublicJwk, Supported>>;
  /**
   * Returns the jwk encoded a Base58 multibase encoded multicodec key
   */
  get fingerprint(): string;
  /**
   * Create a jwk instance based on a Base58 multibase encoded multicodec key
   */
  static fromFingerprint(fingerprint: string): PublicJwk<Ed25519PublicJwk | P256PublicJwk | P384PublicJwk | P521PublicJwk | RsaPublicJwk | Secp256k1PublicJwk | X25519PublicJwk>;
  /**
   * Check whether this PublicJwk instance is of a specific type
   */
  is<Jwk1 extends SupportedPublicJwk, Jwk2 extends SupportedPublicJwk = Jwk1, Jwk3 extends SupportedPublicJwk = Jwk1>(jwkType1: Constructor<Jwk1>, jwkType2?: Constructor<Jwk2>, jwkType3?: Constructor<Jwk3>): this is PublicJwk<Jwk1> | PublicJwk<Jwk2> | PublicJwk<Jwk3>;
  /**
   * Convert the PublicJwk to another type.
   *
   * NOTE: only supported for Ed25519 to X25519 at the moment
   */
  convertTo(type: Jwk extends Ed25519PublicJwk ? typeof X25519PublicJwk : never): Jwk extends Ed25519PublicJwk ? PublicJwk<X25519PublicJwk> : never;
  /**
   * Check whether this jwk instance is the same as another jwk instance.
   * It does this by comparing the key types and public keys, not other fields
   * of the JWK such as keyId, use, etc..
   */
  equals(other: PublicJwk): boolean;
  /**
   * Get human description of a jwk type. This does
   * not include the (public) key material
   */
  get jwkTypeHumanDescription(): string;
  static supportedPublicJwkClassForSignatureAlgorithm(alg: KnownJwaSignatureAlgorithm): SupportedPublicJwkClass;
}
//#endregion
export { PublicJwk, SupportedPublicJwk, SupportedPublicJwkClass };
//# sourceMappingURL=PublicJwk.d.mts.map