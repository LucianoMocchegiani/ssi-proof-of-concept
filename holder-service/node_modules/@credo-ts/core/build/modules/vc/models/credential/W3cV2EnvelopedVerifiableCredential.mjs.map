{"version":3,"file":"W3cV2EnvelopedVerifiableCredential.mjs","names":[],"sources":["../../../../../src/modules/vc/models/credential/W3cV2EnvelopedVerifiableCredential.ts"],"sourcesContent":["import { Exclude, Expose, instanceToPlain, plainToInstance, Transform, TransformationType } from 'class-transformer'\nimport { buildMessage, IsDataURI, isInstance, ValidateBy, type ValidationOptions } from 'class-validator'\nimport { CredoError } from '../../../../error'\nimport type { JsonObject, SingleOrArray } from '../../../../types'\nimport { CREDENTIALS_CONTEXT_V2_URL, ENVELOPED_VERIFIABLE_CREDENTIAL_TYPE } from '../../constants'\nimport { W3cV2JwtVerifiableCredential } from '../../jwt-vc/W3cV2JwtVerifiableCredential'\nimport { W3cV2SdJwtVerifiableCredential } from '../../sd-jwt-vc/W3cV2SdJwtVerifiableCredential'\nimport { IsCredentialJsonLdContext } from '../../validators'\nimport { ClaimFormat } from '../ClaimFormat'\nimport { W3cV2Credential } from './W3cV2Credential'\n\nexport interface W3cV2EnvelopedVerifiableCredentialOptions {\n  id: string\n  context?: string | Array<string | JsonObject>\n  type?: SingleOrArray<string>\n}\n\nexport class W3cV2EnvelopedVerifiableCredential {\n  @Exclude()\n  private _envelopedCredential?: W3cV2SdJwtVerifiableCredential | W3cV2JwtVerifiableCredential\n\n  public constructor(options: W3cV2EnvelopedVerifiableCredentialOptions) {\n    if (options) {\n      this.context = options.context ?? CREDENTIALS_CONTEXT_V2_URL\n      this.id = options.id\n      this.type = options.type ?? ENVELOPED_VERIFIABLE_CREDENTIAL_TYPE\n      this._envelopedCredential = credentialFromDataUri(options.id)\n    }\n  }\n\n  public static fromVerifiableCredential(\n    credential: W3cV2SdJwtVerifiableCredential | W3cV2JwtVerifiableCredential\n  ): W3cV2EnvelopedVerifiableCredential {\n    return new W3cV2EnvelopedVerifiableCredential({\n      id: credentialToDataUri(credential),\n      context: CREDENTIALS_CONTEXT_V2_URL,\n      type: ENVELOPED_VERIFIABLE_CREDENTIAL_TYPE,\n    })\n  }\n\n  @Expose({ name: '@context' })\n  @IsCredentialJsonLdContext({ allowString: true, credentialContext: CREDENTIALS_CONTEXT_V2_URL })\n  public context!: string | Array<string | JsonObject>\n\n  @IsDataURI()\n  public id!: string\n\n  @IsEnvelopedVerifiableCredentialType()\n  public type!: SingleOrArray<string>\n\n  /**\n   * Gets the enveloped credential.\n   */\n  public get envelopedCredential() {\n    if (!this._envelopedCredential) {\n      this._envelopedCredential = credentialFromDataUri(this.id)\n    }\n\n    return this._envelopedCredential\n  }\n\n  /**\n   * Resolved credential is the fully resolved {@link W3cV2Credential} instance.\n   */\n  public get resolvedCredential(): W3cV2Credential {\n    return this.envelopedCredential.resolvedCredential\n  }\n\n  /**\n   * The {@link ClaimFormat} of the enveloped credential.\n   */\n  public get claimFormat(): ClaimFormat.SdJwtW3cVc | ClaimFormat.JwtW3cVc {\n    return this.envelopedCredential.claimFormat\n  }\n}\n\nconst jsonToClass = (v: unknown) => {\n  if (!v || typeof v !== 'object') {\n    throw new CredoError('Invalid plain W3cV2EnvelopedVerifiableCredential')\n  }\n\n  if (isInstance(v, W3cV2EnvelopedVerifiableCredential)) {\n    return v\n  }\n\n  return plainToInstance(W3cV2EnvelopedVerifiableCredential, v)\n}\n\nconst classToJson = (v: unknown) => {\n  return instanceToPlain(v)\n}\n\nexport function W3cV2EnvelopedVerifiableCredentialTransformer() {\n  return Transform(({ value, type }: { value: SingleOrArray<unknown>; type: TransformationType }) => {\n    if (type === TransformationType.PLAIN_TO_CLASS) {\n      return Array.isArray(value) ? value.map(jsonToClass) : jsonToClass(value)\n    }\n\n    if (type === TransformationType.CLASS_TO_PLAIN) {\n      if (Array.isArray(value)) return value.map(classToJson)\n      return classToJson(value)\n    }\n\n    // PLAIN_TO_PLAIN\n    return value\n  })\n}\n\nexport function IsEnvelopedVerifiableCredentialType(validationOptions?: ValidationOptions): PropertyDecorator {\n  return ValidateBy(\n    {\n      name: 'IsEnvelopedVerifiableCredentialType',\n      validator: {\n        validate: (value): boolean => {\n          return Array.isArray(value)\n            ? value.includes(ENVELOPED_VERIFIABLE_CREDENTIAL_TYPE) && value.every((v) => typeof v === 'string')\n            : value === ENVELOPED_VERIFIABLE_CREDENTIAL_TYPE\n        },\n        defaultMessage: buildMessage(\n          (eachPrefix) =>\n            `${eachPrefix}$property must be a string that equals, or an array of strings which includes \"${ENVELOPED_VERIFIABLE_CREDENTIAL_TYPE}\"`,\n          validationOptions\n        ),\n      },\n    },\n    validationOptions\n  )\n}\n\nfunction credentialFromDataUri(uri: string) {\n  if (!uri.startsWith('data:')) {\n    throw new CredoError('Invalid Enveloped Verifiable Credential: \"id\" is not a valid data URI')\n  }\n\n  const mimetypeData = uri.slice(5)\n  const commaIndex = mimetypeData.indexOf(',')\n  if (commaIndex === -1) {\n    throw new CredoError('Invalid Enveloped Verifiable Credential: \"id\" data URI is missing comma separator')\n  }\n\n  const mimetype = mimetypeData.slice(0, commaIndex)\n  const data = mimetypeData.slice(commaIndex + 1)\n\n  switch (mimetype) {\n    case 'application/vc+sd-jwt':\n      return W3cV2SdJwtVerifiableCredential.fromCompact(data)\n\n    case 'application/vc+jwt':\n      return W3cV2JwtVerifiableCredential.fromCompact(data)\n\n    default:\n      throw new CredoError(`Unsupported Enveloped Verifiable Credential: ${mimetype} not recognized`)\n  }\n}\n\nfunction credentialToDataUri(presentation: W3cV2SdJwtVerifiableCredential | W3cV2JwtVerifiableCredential) {\n  if (presentation instanceof W3cV2SdJwtVerifiableCredential) {\n    return `data:application/vc+sd-jwt,${presentation.encoded}`\n  }\n\n  if (presentation instanceof W3cV2JwtVerifiableCredential) {\n    return `data:application/vc+jwt,${presentation.encoded}`\n  }\n\n  throw new CredoError('Unsupported Verifiable Credential instance')\n}\n"],"mappings":";;;;;;;;;;;;;;;AAiBA,IAAa,qCAAb,MAAa,mCAAmC;CAI9C,AAAO,YAAY,SAAoD;AACrE,MAAI,SAAS;AACX,QAAK,UAAU,QAAQ,WAAW;AAClC,QAAK,KAAK,QAAQ;AAClB,QAAK,OAAO,QAAQ,QAAQ;AAC5B,QAAK,uBAAuB,sBAAsB,QAAQ,GAAG;;;CAIjE,OAAc,yBACZ,YACoC;AACpC,SAAO,IAAI,mCAAmC;GAC5C,IAAI,oBAAoB,WAAW;GACnC,SAAS;GACT,MAAM;GACP,CAAC;;;;;CAgBJ,IAAW,sBAAsB;AAC/B,MAAI,CAAC,KAAK,qBACR,MAAK,uBAAuB,sBAAsB,KAAK,GAAG;AAG5D,SAAO,KAAK;;;;;CAMd,IAAW,qBAAsC;AAC/C,SAAO,KAAK,oBAAoB;;;;;CAMlC,IAAW,cAA6D;AACtE,SAAO,KAAK,oBAAoB;;;YAtDjC,SAAS;;CAsBT,OAAO,EAAE,MAAM,YAAY,CAAC;CAC5B,0BAA0B;EAAE,aAAa;EAAM,mBAAmB;EAA4B,CAAC;;;YAG/F,WAAW;YAGX,qCAAqC;AA6BxC,MAAM,eAAe,MAAe;AAClC,KAAI,CAAC,KAAK,OAAO,MAAM,SACrB,OAAM,IAAI,WAAW,mDAAmD;AAG1E,KAAI,WAAW,GAAG,mCAAmC,CACnD,QAAO;AAGT,QAAO,gBAAgB,oCAAoC,EAAE;;AAG/D,MAAM,eAAe,MAAe;AAClC,QAAO,gBAAgB,EAAE;;AAG3B,SAAgB,gDAAgD;AAC9D,QAAO,WAAW,EAAE,OAAO,WAAwE;AACjG,MAAI,SAAS,mBAAmB,eAC9B,QAAO,MAAM,QAAQ,MAAM,GAAG,MAAM,IAAI,YAAY,GAAG,YAAY,MAAM;AAG3E,MAAI,SAAS,mBAAmB,gBAAgB;AAC9C,OAAI,MAAM,QAAQ,MAAM,CAAE,QAAO,MAAM,IAAI,YAAY;AACvD,UAAO,YAAY,MAAM;;AAI3B,SAAO;GACP;;AAGJ,SAAgB,oCAAoC,mBAA0D;AAC5G,QAAO,WACL;EACE,MAAM;EACN,WAAW;GACT,WAAW,UAAmB;AAC5B,WAAO,MAAM,QAAQ,MAAM,GACvB,MAAM,SAAS,qCAAqC,IAAI,MAAM,OAAO,MAAM,OAAO,MAAM,SAAS,GACjG,UAAU;;GAEhB,gBAAgB,cACb,eACC,GAAG,WAAW,iFAAiF,qCAAqC,IACtI,kBACD;GACF;EACF,EACD,kBACD;;AAGH,SAAS,sBAAsB,KAAa;AAC1C,KAAI,CAAC,IAAI,WAAW,QAAQ,CAC1B,OAAM,IAAI,WAAW,0EAAwE;CAG/F,MAAM,eAAe,IAAI,MAAM,EAAE;CACjC,MAAM,aAAa,aAAa,QAAQ,IAAI;AAC5C,KAAI,eAAe,GACjB,OAAM,IAAI,WAAW,sFAAoF;CAG3G,MAAM,WAAW,aAAa,MAAM,GAAG,WAAW;CAClD,MAAM,OAAO,aAAa,MAAM,aAAa,EAAE;AAE/C,SAAQ,UAAR;EACE,KAAK,wBACH,QAAO,+BAA+B,YAAY,KAAK;EAEzD,KAAK,qBACH,QAAO,6BAA6B,YAAY,KAAK;EAEvD,QACE,OAAM,IAAI,WAAW,gDAAgD,SAAS,iBAAiB;;;AAIrG,SAAS,oBAAoB,cAA6E;AACxG,KAAI,wBAAwB,+BAC1B,QAAO,8BAA8B,aAAa;AAGpD,KAAI,wBAAwB,6BAC1B,QAAO,2BAA2B,aAAa;AAGjD,OAAM,IAAI,WAAW,6CAA6C"}