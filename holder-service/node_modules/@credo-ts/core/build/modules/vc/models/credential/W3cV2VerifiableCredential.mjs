

import { CredoError } from "../../../../error/CredoError.mjs";
import { ClassValidationError } from "../../../../error/ClassValidationError.mjs";
import "../../../../error/index.mjs";
import { W3cV2JwtVerifiableCredential } from "../../jwt-vc/W3cV2JwtVerifiableCredential.mjs";
import { W3cV2SdJwtVerifiableCredential } from "../../sd-jwt-vc/W3cV2SdJwtVerifiableCredential.mjs";
import "../../sd-jwt-vc/index.mjs";
import "../../jwt-vc/index.mjs";
import { Transform, TransformationType } from "class-transformer";
import { ValidationError } from "class-validator";

//#region src/modules/vc/models/credential/W3cV2VerifiableCredential.ts
const decodeCredential = (v) => {
	try {
		if (typeof v !== "string") throw new CredoError("Expected a plain string encoding");
		if (v.includes("~")) return W3cV2SdJwtVerifiableCredential.fromCompact(v);
		return W3cV2JwtVerifiableCredential.fromCompact(v);
	} catch (error) {
		if (error instanceof ValidationError || error instanceof ClassValidationError) throw error;
		throw new CredoError(`Value '${v}' is not a valid W3cV2VerifiableCredential. ${error.message}`);
	}
};
const encodeCredential = (v) => {
	if (v instanceof W3cV2JwtVerifiableCredential) return v.encoded;
	if (v instanceof W3cV2SdJwtVerifiableCredential) return v.encoded;
	throw new CredoError(`Value '${v}' is not a valid W3cV2VerifiableCredential`);
};
function W3cV2VerifiableCredentialTransformer() {
	return Transform(({ value, type }) => {
		if (type === TransformationType.PLAIN_TO_CLASS) return Array.isArray(value) ? value.map(decodeCredential) : decodeCredential(value);
		if (type === TransformationType.CLASS_TO_PLAIN) {
			if (Array.isArray(value)) return value.map(encodeCredential);
			return encodeCredential(value);
		}
		return value;
	});
}

//#endregion
export { W3cV2VerifiableCredentialTransformer };
//# sourceMappingURL=W3cV2VerifiableCredential.mjs.map