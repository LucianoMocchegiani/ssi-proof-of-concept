

import { CredoError } from "../../../../error/CredoError.mjs";
import "../../../../error/index.mjs";
import { __decorateMetadata } from "../../../../_virtual/_@oxc-project_runtime@0.110.0/helpers/decorateMetadata.mjs";
import { __decorate } from "../../../../_virtual/_@oxc-project_runtime@0.110.0/helpers/decorate.mjs";
import { CREDENTIALS_CONTEXT_V2_URL, ENVELOPED_VERIFIABLE_CREDENTIAL_TYPE } from "../../constants.mjs";
import { IsCredentialJsonLdContext } from "../../validators.mjs";
import "./W3cV2Credential.mjs";
import { W3cV2JwtVerifiableCredential } from "../../jwt-vc/W3cV2JwtVerifiableCredential.mjs";
import { W3cV2SdJwtVerifiableCredential } from "../../sd-jwt-vc/W3cV2SdJwtVerifiableCredential.mjs";
import { Exclude, Expose, Transform, TransformationType, instanceToPlain, plainToInstance } from "class-transformer";
import { IsDataURI, ValidateBy, buildMessage, isInstance } from "class-validator";

//#region src/modules/vc/models/credential/W3cV2EnvelopedVerifiableCredential.ts
var W3cV2EnvelopedVerifiableCredential = class W3cV2EnvelopedVerifiableCredential {
	constructor(options) {
		if (options) {
			this.context = options.context ?? CREDENTIALS_CONTEXT_V2_URL;
			this.id = options.id;
			this.type = options.type ?? ENVELOPED_VERIFIABLE_CREDENTIAL_TYPE;
			this._envelopedCredential = credentialFromDataUri(options.id);
		}
	}
	static fromVerifiableCredential(credential) {
		return new W3cV2EnvelopedVerifiableCredential({
			id: credentialToDataUri(credential),
			context: CREDENTIALS_CONTEXT_V2_URL,
			type: ENVELOPED_VERIFIABLE_CREDENTIAL_TYPE
		});
	}
	/**
	* Gets the enveloped credential.
	*/
	get envelopedCredential() {
		if (!this._envelopedCredential) this._envelopedCredential = credentialFromDataUri(this.id);
		return this._envelopedCredential;
	}
	/**
	* Resolved credential is the fully resolved {@link W3cV2Credential} instance.
	*/
	get resolvedCredential() {
		return this.envelopedCredential.resolvedCredential;
	}
	/**
	* The {@link ClaimFormat} of the enveloped credential.
	*/
	get claimFormat() {
		return this.envelopedCredential.claimFormat;
	}
};
__decorate([Exclude(), __decorateMetadata("design:type", Object)], W3cV2EnvelopedVerifiableCredential.prototype, "_envelopedCredential", void 0);
__decorate([
	Expose({ name: "@context" }),
	IsCredentialJsonLdContext({
		allowString: true,
		credentialContext: CREDENTIALS_CONTEXT_V2_URL
	}),
	__decorateMetadata("design:type", Object)
], W3cV2EnvelopedVerifiableCredential.prototype, "context", void 0);
__decorate([IsDataURI(), __decorateMetadata("design:type", String)], W3cV2EnvelopedVerifiableCredential.prototype, "id", void 0);
__decorate([IsEnvelopedVerifiableCredentialType(), __decorateMetadata("design:type", Object)], W3cV2EnvelopedVerifiableCredential.prototype, "type", void 0);
const jsonToClass = (v) => {
	if (!v || typeof v !== "object") throw new CredoError("Invalid plain W3cV2EnvelopedVerifiableCredential");
	if (isInstance(v, W3cV2EnvelopedVerifiableCredential)) return v;
	return plainToInstance(W3cV2EnvelopedVerifiableCredential, v);
};
const classToJson = (v) => {
	return instanceToPlain(v);
};
function W3cV2EnvelopedVerifiableCredentialTransformer() {
	return Transform(({ value, type }) => {
		if (type === TransformationType.PLAIN_TO_CLASS) return Array.isArray(value) ? value.map(jsonToClass) : jsonToClass(value);
		if (type === TransformationType.CLASS_TO_PLAIN) {
			if (Array.isArray(value)) return value.map(classToJson);
			return classToJson(value);
		}
		return value;
	});
}
function IsEnvelopedVerifiableCredentialType(validationOptions) {
	return ValidateBy({
		name: "IsEnvelopedVerifiableCredentialType",
		validator: {
			validate: (value) => {
				return Array.isArray(value) ? value.includes(ENVELOPED_VERIFIABLE_CREDENTIAL_TYPE) && value.every((v) => typeof v === "string") : value === ENVELOPED_VERIFIABLE_CREDENTIAL_TYPE;
			},
			defaultMessage: buildMessage((eachPrefix) => `${eachPrefix}$property must be a string that equals, or an array of strings which includes "${ENVELOPED_VERIFIABLE_CREDENTIAL_TYPE}"`, validationOptions)
		}
	}, validationOptions);
}
function credentialFromDataUri(uri) {
	if (!uri.startsWith("data:")) throw new CredoError("Invalid Enveloped Verifiable Credential: \"id\" is not a valid data URI");
	const mimetypeData = uri.slice(5);
	const commaIndex = mimetypeData.indexOf(",");
	if (commaIndex === -1) throw new CredoError("Invalid Enveloped Verifiable Credential: \"id\" data URI is missing comma separator");
	const mimetype = mimetypeData.slice(0, commaIndex);
	const data = mimetypeData.slice(commaIndex + 1);
	switch (mimetype) {
		case "application/vc+sd-jwt": return W3cV2SdJwtVerifiableCredential.fromCompact(data);
		case "application/vc+jwt": return W3cV2JwtVerifiableCredential.fromCompact(data);
		default: throw new CredoError(`Unsupported Enveloped Verifiable Credential: ${mimetype} not recognized`);
	}
}
function credentialToDataUri(presentation) {
	if (presentation instanceof W3cV2SdJwtVerifiableCredential) return `data:application/vc+sd-jwt,${presentation.encoded}`;
	if (presentation instanceof W3cV2JwtVerifiableCredential) return `data:application/vc+jwt,${presentation.encoded}`;
	throw new CredoError("Unsupported Verifiable Credential instance");
}

//#endregion
export { IsEnvelopedVerifiableCredentialType, W3cV2EnvelopedVerifiableCredential, W3cV2EnvelopedVerifiableCredentialTransformer };
//# sourceMappingURL=W3cV2EnvelopedVerifiableCredential.mjs.map