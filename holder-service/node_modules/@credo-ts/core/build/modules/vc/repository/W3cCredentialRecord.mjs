

import { JsonTransformer } from "../../../utils/JsonTransformer.mjs";
import "../../../utils/index.mjs";
import { BaseRecord } from "../../../storage/BaseRecord.mjs";
import { uuid } from "../../../utils/uuid.mjs";
import { CredentialMultiInstanceState } from "../../../utils/credentialUseTypes.mjs";
import { ClaimFormat } from "../models/ClaimFormat.mjs";
import { W3cJsonLdVerifiableCredential } from "../data-integrity/models/W3cJsonLdVerifiableCredential.mjs";
import { W3cJwtVerifiableCredential } from "../jwt-vc/W3cJwtVerifiableCredential.mjs";
import "../jwt-vc/index.mjs";
import "../models/index.mjs";
import "../data-integrity/index.mjs";

//#region src/modules/vc/repository/W3cCredentialRecord.ts
var W3cCredentialRecord = class W3cCredentialRecord extends BaseRecord {
	constructor(props) {
		super();
		this.type = W3cCredentialRecord.type;
		this.multiInstanceState = CredentialMultiInstanceState.SingleInstanceUsed;
		if (props) {
			this.id = props.id ?? uuid();
			this.createdAt = props.createdAt ?? /* @__PURE__ */ new Date();
			this._tags = props.tags ?? {};
			this.credentialInstances = props.credentialInstances;
			this.multiInstanceState = this.credentialInstances.length === 1 ? CredentialMultiInstanceState.SingleInstanceUnused : CredentialMultiInstanceState.MultiInstanceFirstUnused;
		}
	}
	/**
	* Only here for class transformation. If credential is set we transform
	* it to the new credentialInstances array format
	*/
	set credential(credential) {
		this.credentialInstances = [{ credential }];
	}
	get firstCredential() {
		const credential = this.credentialInstances[0].credential;
		return typeof credential === "string" ? W3cJwtVerifiableCredential.fromSerializedJwt(credential) : W3cJsonLdVerifiableCredential.fromJson(credential);
	}
	static fromCredential(credential) {
		return new W3cCredentialRecord({
			credentialInstances: [{ credential: credential.encoded }],
			tags: {}
		});
	}
	getTags() {
		const credential = this.firstCredential;
		const stringContexts = credential.contexts.filter((ctx) => typeof ctx === "string");
		const tags = {
			...this._tags,
			issuerId: credential.issuerId,
			subjectIds: credential.credentialSubjectIds,
			schemaIds: credential.credentialSchemaIds,
			contexts: stringContexts,
			givenId: credential.id,
			claimFormat: credential.claimFormat,
			types: credential.type,
			multiInstanceState: this.multiInstanceState
		};
		if (credential.claimFormat === ClaimFormat.LdpVc) {
			tags.proofTypes = credential.proofTypes;
			tags.cryptosuites = credential.dataIntegrityCryptosuites;
		} else if (credential.claimFormat === ClaimFormat.JwtVc) tags.algs = [credential.jwt.header.alg];
		return tags;
	}
	/**
	* This overwrites the default clone method for records
	* as the W3cRecord has issues with the default clone method
	* due to how W3cJwtVerifiableCredential is implemented. This is
	* a temporary way to make sure the clone still works, but ideally
	* we find an alternative.
	*/
	clone() {
		return JsonTransformer.fromJSON(JsonTransformer.toJSON(this), this.constructor);
	}
	/**
	* encoded is convenience method added to all credential records
	*/
	get encoded() {
		return this.credentialInstances[0].credential;
	}
};
W3cCredentialRecord.type = "W3cCredentialRecord";

//#endregion
export { W3cCredentialRecord };
//# sourceMappingURL=W3cCredentialRecord.mjs.map