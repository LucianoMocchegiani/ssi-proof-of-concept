

import { asArray } from "../../../utils/array.mjs";
import { JsonTransformer } from "../../../utils/JsonTransformer.mjs";
import "../../../utils/index.mjs";
import { BaseRecord } from "../../../storage/BaseRecord.mjs";
import { uuid } from "../../../utils/uuid.mjs";
import { CredentialMultiInstanceState } from "../../../utils/credentialUseTypes.mjs";
import { ClaimFormat } from "../models/ClaimFormat.mjs";
import { W3cV2JwtVerifiableCredential } from "../jwt-vc/W3cV2JwtVerifiableCredential.mjs";
import { W3cV2SdJwtVerifiableCredential } from "../sd-jwt-vc/W3cV2SdJwtVerifiableCredential.mjs";
import "../sd-jwt-vc/index.mjs";
import "../jwt-vc/index.mjs";
import "../models/index.mjs";

//#region src/modules/vc/repository/W3cV2CredentialRecord.ts
var W3cV2CredentialRecord = class W3cV2CredentialRecord extends BaseRecord {
	constructor(props) {
		super();
		this.type = W3cV2CredentialRecord.type;
		this.multiInstanceState = CredentialMultiInstanceState.SingleInstanceUsed;
		if (props) {
			this.id = props.id ?? uuid();
			this.createdAt = props.createdAt ?? /* @__PURE__ */ new Date();
			this.credentialInstances = props.credentialInstances;
			this.multiInstanceState = this.credentialInstances.length === 1 ? CredentialMultiInstanceState.SingleInstanceUnused : CredentialMultiInstanceState.MultiInstanceFirstUnused;
		}
	}
	/**
	* Only here for class transformation. If credential is set we transform
	* it to the new credentialInstances array format
	*/
	set credential(credential) {
		this.credentialInstances = [{ credential }];
	}
	get firstCredential() {
		const credential = this.credentialInstances[0].credential;
		return credential.includes("~") ? W3cV2SdJwtVerifiableCredential.fromCompact(credential) : W3cV2JwtVerifiableCredential.fromCompact(credential);
	}
	static fromCredential(credential) {
		return new W3cV2CredentialRecord({ credentialInstances: [{ credential: credential.encoded }] });
	}
	getTags() {
		const credential = this.firstCredential;
		const resolvedCredential = credential.resolvedCredential;
		const stringContexts = resolvedCredential.contexts.filter((ctx) => typeof ctx === "string");
		const tags = {
			...this._tags,
			issuerId: resolvedCredential.issuerId,
			subjectIds: resolvedCredential.credentialSubjectIds,
			schemaIds: resolvedCredential.credentialSchemaIds,
			contexts: stringContexts,
			givenId: resolvedCredential.id,
			claimFormat: credential.claimFormat,
			types: asArray(resolvedCredential.type),
			multiInstanceState: this.multiInstanceState
		};
		if (credential.claimFormat === ClaimFormat.JwtW3cVc) tags.algs = [credential.jwt.header.alg];
		else if (credential.claimFormat === ClaimFormat.SdJwtW3cVc) tags.algs = [credential.sdJwt.header.alg];
		return tags;
	}
	/**
	* This overwrites the default `clone` method for records, as the W3cV3CredentialRecord
	* has issues with the default clone method due to the way the JWT and SD-JWT
	* records are implemented. This is a temporary way to make sure the clone still works, but ideally
	* we find an alternative.
	*/
	clone() {
		return JsonTransformer.fromJSON(JsonTransformer.toJSON(this), this.constructor);
	}
	/**
	* encoded is convenience method added to all credential records
	*/
	get encoded() {
		return this.credentialInstances[0].credential;
	}
};
W3cV2CredentialRecord.type = "W3cV2CredentialRecord";

//#endregion
export { W3cV2CredentialRecord };
//# sourceMappingURL=W3cV2CredentialRecord.mjs.map