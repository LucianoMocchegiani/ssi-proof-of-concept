

import { JsonTransformer } from "../../../utils/JsonTransformer.mjs";
import "../../../utils/index.mjs";
import { SECURITY_PROOF_URL } from "../constants.mjs";
import jsonld_default from "./libraries/jsonld.mjs";
import { W3cJsonLdVerifiableCredential } from "./models/W3cJsonLdVerifiableCredential.mjs";
import { getProofs, getTypeInfo } from "./jsonldUtil.mjs";

//#region src/modules/vc/data-integrity/deriveProof.ts
/**
* Derives a proof from a document featuring a supported linked data proof
*
* NOTE - This is a temporary API extending JSON-LD signatures
*
* @param proofDocument A document featuring a linked data proof capable of proof derivation
* @param revealDocument A document of the form of a JSON-LD frame describing the terms to selectively derive from the proof document
* @param options Options for proof derivation
*/
const deriveProof = async (proofDocument, revealDocument, { suite, skipProofCompaction, documentLoader, nonce }) => {
	if (!suite) throw new TypeError("\"options.suite\" is required.");
	if (Array.isArray(proofDocument)) throw new TypeError("proofDocument should be an object not an array.");
	const { proofs, document } = await getProofs({
		document: proofDocument,
		proofType: suite.supportedDeriveProofType,
		documentLoader
	});
	if (proofs.length === 0) throw new Error("There were not any proofs provided that can be used to derive a proof with this suite.");
	let derivedProof = await suite.deriveProof({
		document,
		proof: proofs[0],
		revealDocument,
		documentLoader,
		nonce
	});
	if (proofs.length > 1) {
		derivedProof = {
			...derivedProof,
			proof: [derivedProof.proof]
		};
		proofs.splice(0, 1);
		for (const proof of proofs) {
			const additionalDerivedProofValue = await suite.deriveProof({
				document,
				proof,
				revealDocument,
				documentLoader
			});
			derivedProof.proof.push(additionalDerivedProofValue.proof);
		}
	}
	if (!skipProofCompaction) {
		const expandedProof = { [SECURITY_PROOF_URL]: { "@graph": derivedProof.proof } };
		const { types, alias } = await getTypeInfo(derivedProof.document, { documentLoader });
		expandedProof["@type"] = types;
		const ctx = jsonld_default.getValues(derivedProof.document, "@context");
		const compactProof = await jsonld_default.compact(expandedProof, ctx, {
			documentLoader,
			compactToRelative: false
		});
		delete compactProof[alias];
		delete compactProof["@context"];
		/**
		* removes the @included tag when multiple proofs exist because the
		* @included tag messes up the canonicalized bytes leading to a bad
		* signature that won't verify.
		**/
		if (compactProof.proof?.["@included"]) compactProof.proof = compactProof.proof["@included"];
		const key = Object.keys(compactProof)[0];
		jsonld_default.addValue(derivedProof.document, key, compactProof[key]);
	} else {
		delete derivedProof.proof["@context"];
		jsonld_default.addValue(derivedProof.document, "proof", derivedProof.proof);
	}
	return JsonTransformer.fromJSON(derivedProof.document, W3cJsonLdVerifiableCredential);
};

//#endregion
export { deriveProof };
//# sourceMappingURL=deriveProof.mjs.map