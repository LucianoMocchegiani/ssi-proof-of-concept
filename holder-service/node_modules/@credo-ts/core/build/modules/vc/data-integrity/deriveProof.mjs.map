{"version":3,"file":"deriveProof.mjs","names":["jsonld"],"sources":["../../../../src/modules/vc/data-integrity/deriveProof.ts"],"sourcesContent":["/*\n * Copyright 2020 - MATTR Limited\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { JsonObject } from '../../../types'\n\nimport { JsonTransformer } from '../../../utils'\nimport { SECURITY_PROOF_URL } from '../constants'\n\nimport { getProofs, getTypeInfo } from './jsonldUtil'\nimport jsonld from './libraries/jsonld'\nimport { W3cJsonLdVerifiableCredential } from './models/W3cJsonLdVerifiableCredential'\n\nexport interface W3cJsonLdDeriveProofOptions {\n  credential: W3cJsonLdVerifiableCredential\n  revealDocument: JsonObject\n  verificationMethod: string\n}\n\n/**\n * Derives a proof from a document featuring a supported linked data proof\n *\n * NOTE - This is a temporary API extending JSON-LD signatures\n *\n * @param proofDocument A document featuring a linked data proof capable of proof derivation\n * @param revealDocument A document of the form of a JSON-LD frame describing the terms to selectively derive from the proof document\n * @param options Options for proof derivation\n */\nexport const deriveProof = async (\n  proofDocument: JsonObject,\n  revealDocument: JsonObject,\n  // biome-ignore lint/suspicious/noExplicitAny: no explanation\n  { suite, skipProofCompaction, documentLoader, nonce }: any\n): Promise<W3cJsonLdVerifiableCredential> => {\n  if (!suite) {\n    throw new TypeError('\"options.suite\" is required.')\n  }\n\n  if (Array.isArray(proofDocument)) {\n    throw new TypeError('proofDocument should be an object not an array.')\n  }\n\n  const { proofs, document } = await getProofs({\n    document: proofDocument,\n    proofType: suite.supportedDeriveProofType,\n    documentLoader,\n  })\n\n  if (proofs.length === 0) {\n    throw new Error('There were not any proofs provided that can be used to derive a proof with this suite.')\n  }\n\n  let derivedProof = await suite.deriveProof({\n    document,\n    proof: proofs[0],\n    revealDocument,\n    documentLoader,\n\n    nonce,\n  })\n\n  if (proofs.length > 1) {\n    // convert the proof property value from object ot array of objects\n    derivedProof = { ...derivedProof, proof: [derivedProof.proof] }\n\n    // drop the first proof because it's already been processed\n    proofs.splice(0, 1)\n\n    // add all the additional proofs to the derivedProof document\n    for (const proof of proofs) {\n      const additionalDerivedProofValue = await suite.deriveProof({\n        document,\n        proof,\n        revealDocument,\n        documentLoader,\n      })\n      derivedProof.proof.push(additionalDerivedProofValue.proof)\n    }\n  }\n\n  if (!skipProofCompaction) {\n    const expandedProof: Record<string, unknown> = {\n      [SECURITY_PROOF_URL]: {\n        '@graph': derivedProof.proof,\n      },\n    }\n\n    // account for type-scoped `proof` definition by getting document types\n    const { types, alias } = await getTypeInfo(derivedProof.document, {\n      documentLoader,\n    })\n\n    expandedProof['@type'] = types\n\n    const ctx = jsonld.getValues(derivedProof.document, '@context')\n\n    const compactProof = await jsonld.compact(expandedProof, ctx, {\n      documentLoader,\n      compactToRelative: false,\n    })\n\n    delete compactProof[alias]\n    // biome-ignore lint/performance/noDelete: no explanation\n    delete compactProof['@context']\n\n    /**\n     * removes the @included tag when multiple proofs exist because the\n     * @included tag messes up the canonicalized bytes leading to a bad\n     * signature that won't verify.\n     **/\n    if (compactProof.proof?.['@included']) {\n      compactProof.proof = compactProof.proof['@included']\n    }\n\n    // add proof to document\n    const key = Object.keys(compactProof)[0]\n    jsonld.addValue(derivedProof.document, key, compactProof[key])\n  } else {\n    // biome-ignore lint/performance/noDelete: no explanation\n    delete derivedProof.proof['@context']\n    jsonld.addValue(derivedProof.document, 'proof', derivedProof.proof)\n  }\n\n  return JsonTransformer.fromJSON(derivedProof.document, W3cJsonLdVerifiableCredential)\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;AAqCA,MAAa,cAAc,OACzB,eACA,gBAEA,EAAE,OAAO,qBAAqB,gBAAgB,YACH;AAC3C,KAAI,CAAC,MACH,OAAM,IAAI,UAAU,iCAA+B;AAGrD,KAAI,MAAM,QAAQ,cAAc,CAC9B,OAAM,IAAI,UAAU,kDAAkD;CAGxE,MAAM,EAAE,QAAQ,aAAa,MAAM,UAAU;EAC3C,UAAU;EACV,WAAW,MAAM;EACjB;EACD,CAAC;AAEF,KAAI,OAAO,WAAW,EACpB,OAAM,IAAI,MAAM,yFAAyF;CAG3G,IAAI,eAAe,MAAM,MAAM,YAAY;EACzC;EACA,OAAO,OAAO;EACd;EACA;EAEA;EACD,CAAC;AAEF,KAAI,OAAO,SAAS,GAAG;AAErB,iBAAe;GAAE,GAAG;GAAc,OAAO,CAAC,aAAa,MAAM;GAAE;AAG/D,SAAO,OAAO,GAAG,EAAE;AAGnB,OAAK,MAAM,SAAS,QAAQ;GAC1B,MAAM,8BAA8B,MAAM,MAAM,YAAY;IAC1D;IACA;IACA;IACA;IACD,CAAC;AACF,gBAAa,MAAM,KAAK,4BAA4B,MAAM;;;AAI9D,KAAI,CAAC,qBAAqB;EACxB,MAAM,gBAAyC,GAC5C,qBAAqB,EACpB,UAAU,aAAa,OACxB,EACF;EAGD,MAAM,EAAE,OAAO,UAAU,MAAM,YAAY,aAAa,UAAU,EAChE,gBACD,CAAC;AAEF,gBAAc,WAAW;EAEzB,MAAM,MAAMA,eAAO,UAAU,aAAa,UAAU,WAAW;EAE/D,MAAM,eAAe,MAAMA,eAAO,QAAQ,eAAe,KAAK;GAC5D;GACA,mBAAmB;GACpB,CAAC;AAEF,SAAO,aAAa;AAEpB,SAAO,aAAa;;;;;;AAOpB,MAAI,aAAa,QAAQ,aACvB,cAAa,QAAQ,aAAa,MAAM;EAI1C,MAAM,MAAM,OAAO,KAAK,aAAa,CAAC;AACtC,iBAAO,SAAS,aAAa,UAAU,KAAK,aAAa,KAAK;QACzD;AAEL,SAAO,aAAa,MAAM;AAC1B,iBAAO,SAAS,aAAa,UAAU,SAAS,aAAa,MAAM;;AAGrE,QAAO,gBAAgB,SAAS,aAAa,UAAU,8BAA8B"}