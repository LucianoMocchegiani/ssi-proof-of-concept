{"version":3,"file":"W3cJsonLdVerifiableCredential.mjs","names":[],"sources":["../../../../../src/modules/vc/data-integrity/models/W3cJsonLdVerifiableCredential.ts"],"sourcesContent":["import { ValidateNested } from 'class-validator'\nimport type { SingleOrArray } from '../../../../types'\nimport { asArray, IsInstanceOrArrayOfInstances, JsonTransformer, mapSingleOrArray } from '../../../../utils'\nimport { ClaimFormat } from '../../models/ClaimFormat'\nimport type { W3cCredentialOptions } from '../../models/credential/W3cCredential'\nimport { W3cCredential } from '../../models/credential/W3cCredential'\nimport type { W3cJsonCredential } from '../../models/credential/W3cJsonCredential'\nimport type { DataIntegrityProofOptions } from './DataIntegrityProof'\nimport { DataIntegrityProof } from './DataIntegrityProof'\nimport type { LinkedDataProofOptions } from './LinkedDataProof'\nimport { LinkedDataProof } from './LinkedDataProof'\nimport { ProofTransformer } from './ProofTransformer'\n\nexport interface W3cJsonLdVerifiableCredentialOptions extends W3cCredentialOptions {\n  proof: SingleOrArray<LinkedDataProofOptions | DataIntegrityProofOptions>\n}\n\nexport class W3cJsonLdVerifiableCredential extends W3cCredential {\n  public constructor(options: W3cJsonLdVerifiableCredentialOptions) {\n    super(options)\n    if (options) {\n      this.proof = mapSingleOrArray(options.proof, (proof) => {\n        if (proof.cryptosuite) return new DataIntegrityProof(proof)\n        return new LinkedDataProof(proof as LinkedDataProofOptions)\n      })\n    }\n  }\n\n  @ProofTransformer()\n  @IsInstanceOrArrayOfInstances({ classType: [LinkedDataProof, DataIntegrityProof] })\n  @ValidateNested()\n  public proof!: SingleOrArray<LinkedDataProof | DataIntegrityProof>\n\n  public get proofTypes(): Array<string> {\n    const proofArray = asArray(this.proof) ?? []\n    return proofArray.map((proof) => proof.type)\n  }\n\n  public get dataIntegrityCryptosuites(): Array<string> {\n    const proofArray = asArray(this.proof) ?? []\n    return proofArray\n      .filter((proof): proof is DataIntegrityProof => proof.type === 'DataIntegrityProof' && 'cryptosuite' in proof)\n      .map((proof) => proof.cryptosuite)\n  }\n\n  public toJson() {\n    return JsonTransformer.toJSON(this) as W3cJsonCredential\n  }\n\n  public static fromJson(json: Record<string, unknown>) {\n    return JsonTransformer.fromJSON(json, W3cJsonLdVerifiableCredential)\n  }\n\n  /**\n   * The {@link ClaimFormat} of the credential. For JSON-LD credentials this is always `ldp_vc`.\n   */\n  public get claimFormat(): ClaimFormat.LdpVc {\n    return ClaimFormat.LdpVc\n  }\n\n  /**\n   * Get the encoded variant of the W3C Verifiable Credential. For JSON-LD credentials this is\n   * a JSON object.\n   */\n  public get encoded() {\n    return this.toJson()\n  }\n\n  public get jsonCredential(): W3cJsonCredential {\n    return this.toJson() as W3cJsonCredential\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;AAiBA,IAAa,gCAAb,MAAa,sCAAsC,cAAc;CAC/D,AAAO,YAAY,SAA+C;AAChE,QAAM,QAAQ;AACd,MAAI,QACF,MAAK,QAAQ,iBAAiB,QAAQ,QAAQ,UAAU;AACtD,OAAI,MAAM,YAAa,QAAO,IAAI,mBAAmB,MAAM;AAC3D,UAAO,IAAI,gBAAgB,MAAgC;IAC3D;;CASN,IAAW,aAA4B;AAErC,UADmB,QAAQ,KAAK,MAAM,IAAI,EAAE,EAC1B,KAAK,UAAU,MAAM,KAAK;;CAG9C,IAAW,4BAA2C;AAEpD,UADmB,QAAQ,KAAK,MAAM,IAAI,EAAE,EAEzC,QAAQ,UAAuC,MAAM,SAAS,wBAAwB,iBAAiB,MAAM,CAC7G,KAAK,UAAU,MAAM,YAAY;;CAGtC,AAAO,SAAS;AACd,SAAO,gBAAgB,OAAO,KAAK;;CAGrC,OAAc,SAAS,MAA+B;AACpD,SAAO,gBAAgB,SAAS,MAAM,8BAA8B;;;;;CAMtE,IAAW,cAAiC;AAC1C,SAAO,YAAY;;;;;;CAOrB,IAAW,UAAU;AACnB,SAAO,KAAK,QAAQ;;CAGtB,IAAW,iBAAoC;AAC7C,SAAO,KAAK,QAAQ;;;;CAzCrB,kBAAkB;CAClB,6BAA6B,EAAE,WAAW,CAAC,iBAAiB,mBAAmB,EAAE,CAAC;CAClF,gBAAgB"}