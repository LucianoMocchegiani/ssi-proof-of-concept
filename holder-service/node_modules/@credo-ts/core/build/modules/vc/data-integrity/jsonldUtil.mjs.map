{"version":3,"file":"jsonldUtil.mjs","names":["jsonld"],"sources":["../../../../src/modules/vc/data-integrity/jsonldUtil.ts"],"sourcesContent":["import { CredoError } from '../../../error'\nimport type { JsonObject, JsonValue } from '../../../types'\nimport { SECURITY_CONTEXT_URL } from '../constants'\nimport jsonld from './libraries/jsonld'\nimport type { GetProofsOptions } from './models/GetProofsOptions'\nimport type { GetProofsResult } from './models/GetProofsResult'\nimport type { GetTypeOptions } from './models/GetTypeOptions'\nimport { W3cJsonLdVerifiableCredential } from './models/W3cJsonLdVerifiableCredential'\n\nexport type JsonLdDoc = Record<string, unknown>\nexport interface VerificationMethod extends JsonObject {\n  id: string\n  [key: string]: JsonValue\n}\n\nexport interface Proof extends JsonObject {\n  verificationMethod: string | VerificationMethod\n  [key: string]: JsonValue\n}\n\nexport interface DocumentLoaderResult {\n  contextUrl?: string | null\n  documentUrl: string\n  document: Record<string, unknown>\n}\n\nexport type DocumentLoader = (url: string) => Promise<DocumentLoaderResult>\n\nexport const _includesContext = (options: { document: JsonLdDoc; contextUrl: string }) => {\n  const context = options.document['@context']\n\n  return context === options.contextUrl || (Array.isArray(context) && context.includes(options.contextUrl))\n}\n\nexport function assertOnlyW3cJsonLdVerifiableCredentials(\n  credentials: unknown[]\n): asserts credentials is W3cJsonLdVerifiableCredential[] {\n  if (credentials.some((c) => !(c instanceof W3cJsonLdVerifiableCredential))) {\n    throw new CredoError('JSON-LD VPs can only contain JSON-LD VCs')\n  }\n}\n\n/*\n * The code in this file originated from\n * @see https://github.com/digitalbazaar/jsonld-signatures\n * Hence the following copyright notice applies\n *\n * Copyright (c) 2017-2018 Digital Bazaar, Inc. All rights reserved.\n */\n\n/**\n * The property identifying the linked data proof\n * Note - this will not work for legacy systems that\n * relying on `signature`\n */\nconst PROOF_PROPERTY = 'proof'\n\n/**\n * Gets a supported linked data proof from a JSON-LD Document\n * Note - unless instructed not to the document will be compacted\n * against the security v2 context @see https://w3id.org/security/v2\n *\n * @param options Options for extracting the proof from the document\n *\n * @returns {GetProofsResult} An object containing the matched proofs and the JSON-LD document\n */\nexport const getProofs = async (options: GetProofsOptions): Promise<GetProofsResult> => {\n  const { proofType, skipProofCompaction, documentLoader } = options\n  let { document } = options\n\n  // biome-ignore lint/suspicious/noImplicitAnyLet: no explanation\n  let proofs\n  if (!skipProofCompaction) {\n    // If we must compact the proof then we must first compact the input\n    // document to find the proof\n    document = await jsonld.compact(document, SECURITY_CONTEXT_URL, {\n      documentLoader,\n      compactToRelative: false,\n    })\n  }\n\n  proofs = jsonld.getValues(document, PROOF_PROPERTY)\n  delete document[PROOF_PROPERTY]\n\n  if (typeof proofType === 'string') {\n    proofs = proofs.filter((_: Record<string, unknown>) => _.type === proofType)\n  }\n  if (Array.isArray(proofType)) {\n    proofs = proofs.filter((_: Record<string, unknown>) => proofType.includes(_.type))\n  }\n\n  proofs = proofs.map((matchedProof: Record<string, unknown>) => ({\n    '@context': SECURITY_CONTEXT_URL,\n    ...matchedProof,\n  }))\n\n  return {\n    proofs,\n    document,\n  }\n}\n\n/**\n * Gets the JSON-LD type information for a document\n * @param document {any} JSON-LD document to extract the type information from\n * @param options {GetTypeInfoOptions} Options for extracting the JSON-LD document\n *\n * @returns {object} Type info for the JSON-LD document\n */\nexport const getTypeInfo = async (\n  document: JsonObject,\n  options: GetTypeOptions\n): Promise<{ types: string[]; alias: string }> => {\n  const { documentLoader } = options\n\n  // determine `@type` alias, if any\n  const context = jsonld.getValues(document, '@context')\n\n  const compacted = await jsonld.compact({ '@type': '_:b0' }, context, {\n    documentLoader,\n  })\n\n  // biome-ignore lint/performance/noDelete: no explanation\n  delete compacted['@context']\n\n  const alias = Object.keys(compacted)[0]\n\n  // optimize: expand only `@type` and `type` values\n  const toExpand: Record<string, unknown> = { '@context': context }\n\n  toExpand['@type'] = jsonld.getValues(document, '@type').concat(jsonld.getValues(document, alias))\n\n  const expanded = (await jsonld.expand(toExpand, { documentLoader }))[0] || {}\n\n  return { types: jsonld.getValues(expanded, '@type'), alias }\n}\n"],"mappings":";;;;;;;;;AA4BA,MAAa,oBAAoB,YAAyD;CACxF,MAAM,UAAU,QAAQ,SAAS;AAEjC,QAAO,YAAY,QAAQ,cAAe,MAAM,QAAQ,QAAQ,IAAI,QAAQ,SAAS,QAAQ,WAAW;;AAG1G,SAAgB,yCACd,aACwD;AACxD,KAAI,YAAY,MAAM,MAAM,EAAE,aAAa,+BAA+B,CACxE,OAAM,IAAI,WAAW,2CAA2C;;;;;;;AAiBpE,MAAM,iBAAiB;;;;;;;;;;AAWvB,MAAa,YAAY,OAAO,YAAwD;CACtF,MAAM,EAAE,WAAW,qBAAqB,mBAAmB;CAC3D,IAAI,EAAE,aAAa;CAGnB,IAAI;AACJ,KAAI,CAAC,oBAGH,YAAW,MAAMA,eAAO,QAAQ,UAAU,sBAAsB;EAC9D;EACA,mBAAmB;EACpB,CAAC;AAGJ,UAASA,eAAO,UAAU,UAAU,eAAe;AACnD,QAAO,SAAS;AAEhB,KAAI,OAAO,cAAc,SACvB,UAAS,OAAO,QAAQ,MAA+B,EAAE,SAAS,UAAU;AAE9E,KAAI,MAAM,QAAQ,UAAU,CAC1B,UAAS,OAAO,QAAQ,MAA+B,UAAU,SAAS,EAAE,KAAK,CAAC;AAGpF,UAAS,OAAO,KAAK,kBAA2C;EAC9D,YAAY;EACZ,GAAG;EACJ,EAAE;AAEH,QAAO;EACL;EACA;EACD;;;;;;;;;AAUH,MAAa,cAAc,OACzB,UACA,YACgD;CAChD,MAAM,EAAE,mBAAmB;CAG3B,MAAM,UAAUA,eAAO,UAAU,UAAU,WAAW;CAEtD,MAAM,YAAY,MAAMA,eAAO,QAAQ,EAAE,SAAS,QAAQ,EAAE,SAAS,EACnE,gBACD,CAAC;AAGF,QAAO,UAAU;CAEjB,MAAM,QAAQ,OAAO,KAAK,UAAU,CAAC;CAGrC,MAAM,WAAoC,EAAE,YAAY,SAAS;AAEjE,UAAS,WAAWA,eAAO,UAAU,UAAU,QAAQ,CAAC,OAAOA,eAAO,UAAU,UAAU,MAAM,CAAC;CAEjG,MAAM,YAAY,MAAMA,eAAO,OAAO,UAAU,EAAE,gBAAgB,CAAC,EAAE,MAAM,EAAE;AAE7E,QAAO;EAAE,OAAOA,eAAO,UAAU,UAAU,QAAQ;EAAE;EAAO"}