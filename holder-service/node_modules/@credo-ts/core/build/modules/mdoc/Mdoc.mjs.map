{"version":3,"file":"Mdoc.mjs","names":[],"sources":["../../../src/modules/mdoc/Mdoc.ts"],"sourcesContent":["import type { IssuerSignedDocument } from '@animo-id/mdoc'\nimport {\n  COSEKey,\n  cborEncode,\n  DeviceSignedDocument,\n  Document,\n  parseDeviceSigned,\n  parseIssuerSigned,\n  Verifier,\n} from '@animo-id/mdoc'\nimport type { AgentContext } from '../../agent'\nimport { TypedArrayEncoder } from './../../utils'\nimport { type KnownJwaSignatureAlgorithm, PublicJwk } from '../kms'\nimport { isKnownJwaSignatureAlgorithm } from '../kms/jwk/jwa'\nimport { ClaimFormat } from '../vc/index'\nimport { X509Certificate, X509ModuleConfig } from '../x509'\nimport { getMdocContext } from './MdocContext'\nimport { MdocError } from './MdocError'\nimport type { MdocNameSpaces, MdocSignOptions, MdocVerifyOptions } from './MdocOptions'\nimport { isMdocSupportedSignatureAlgorithm, mdocSupportedSignatureAlgorithms } from './mdocSupportedAlgs'\n\n/**\n * This class represents a IssuerSigned Mdoc Document,\n * which are the actual credentials being issued to holders.\n */\nexport class Mdoc {\n  public base64Url: string\n  #deviceKeyId?: string\n\n  private constructor(public issuerSignedDocument: IssuerSignedDocument | DeviceSignedDocument) {\n    const issuerSigned = issuerSignedDocument.prepare().get('issuerSigned')\n    this.base64Url = TypedArrayEncoder.toBase64URL(cborEncode(issuerSigned))\n  }\n\n  /**\n   * claim format is convenience method added to all credential instances\n   */\n  public get claimFormat() {\n    return ClaimFormat.MsoMdoc as const\n  }\n\n  /**\n   * Encoded is convenience method added to all credential instances\n   */\n  public get encoded() {\n    return this.base64Url\n  }\n\n  /**\n   * Get the device key to which the mdoc is bound\n   */\n  public get deviceKey(): PublicJwk {\n    const deviceKeyRaw = this.issuerSignedDocument.issuerSigned.issuerAuth.decodedPayload.deviceKeyInfo?.deviceKey\n    if (!deviceKeyRaw) throw new MdocError('Could not extract device key from mdoc')\n\n    const publicJwk = PublicJwk.fromUnknown(COSEKey.import(deviceKeyRaw).toJWK())\n    if (this.#deviceKeyId) publicJwk.keyId = this.#deviceKeyId\n    return publicJwk\n  }\n\n  public set deviceKeyId(keyId: string | undefined) {\n    this.#deviceKeyId = keyId\n  }\n\n  public get deviceKeyId() {\n    const deviceKey = this.deviceKey\n\n    if (deviceKey.hasKeyId) return deviceKey.keyId\n    return undefined\n  }\n\n  public static fromBase64Url(mdocBase64Url: string, expectedDocType?: string): Mdoc {\n    const issuerSignedDocument = parseIssuerSigned(TypedArrayEncoder.fromBase64(mdocBase64Url), expectedDocType)\n    return new Mdoc(issuerSignedDocument)\n  }\n\n  public static fromIssuerSignedDocument(issuerSignedBase64Url: string, expectedDocType?: string): Mdoc {\n    return new Mdoc(parseIssuerSigned(TypedArrayEncoder.fromBase64(issuerSignedBase64Url), expectedDocType))\n  }\n\n  public static fromDeviceSignedDocument(\n    issuerSignedBase64Url: string,\n    deviceSignedBase64Url: string,\n    expectedDocType?: string\n  ): Mdoc {\n    return new Mdoc(\n      parseDeviceSigned(\n        TypedArrayEncoder.fromBase64(deviceSignedBase64Url),\n        TypedArrayEncoder.fromBase64(issuerSignedBase64Url),\n        expectedDocType\n      )\n    )\n  }\n\n  public get docType(): string {\n    return this.issuerSignedDocument.docType\n  }\n\n  public get alg(): KnownJwaSignatureAlgorithm {\n    const algName = this.issuerSignedDocument.issuerSigned.issuerAuth.algName\n    if (!algName) {\n      throw new MdocError('Cannot extract the signature algorithm from the mdoc.')\n    }\n    if (isKnownJwaSignatureAlgorithm(algName)) {\n      return algName\n    }\n\n    throw new MdocError(`Cannot parse mdoc. The signature algorithm '${algName}' is not supported.`)\n  }\n\n  public get validityInfo() {\n    return this.issuerSignedDocument.issuerSigned.issuerAuth.decodedPayload.validityInfo\n  }\n\n  public get deviceSignedNamespaces(): MdocNameSpaces | null {\n    if (this.issuerSignedDocument instanceof DeviceSignedDocument === false) {\n      return null\n    }\n\n    return Object.fromEntries(\n      Array.from(this.issuerSignedDocument.allDeviceSignedNamespaces.entries()).map(([namespace, value]) => [\n        namespace,\n        Object.fromEntries(Array.from(value.entries())),\n      ])\n    )\n  }\n\n  public get issuerSignedCertificateChain() {\n    return this.issuerSignedDocument.issuerSigned.issuerAuth.certificateChain\n  }\n\n  public get signingCertificate() {\n    return this.issuerSignedDocument.issuerSigned.issuerAuth.certificate\n  }\n\n  public get issuerSignedNamespaces(): MdocNameSpaces {\n    return Object.fromEntries(\n      Array.from(this.issuerSignedDocument.allIssuerSignedNamespaces.entries()).map(([namespace, value]) => [\n        namespace,\n        Object.fromEntries(Array.from(value.entries())),\n      ])\n    )\n  }\n\n  public static async sign(agentContext: AgentContext, options: MdocSignOptions) {\n    const { docType, validityInfo, namespaces, holderKey, issuerCertificate } = options\n    const mdocContext = getMdocContext(agentContext)\n\n    const document = new Document(docType, mdocContext)\n      .useDigestAlgorithm('SHA-256')\n      .addValidityInfo(validityInfo)\n      .addDeviceKeyInfo({ deviceKey: holderKey.toJson() })\n\n    for (const [namespace, namespaceRecord] of Object.entries(namespaces)) {\n      document.addIssuerNameSpace(namespace, namespaceRecord)\n    }\n\n    const issuerKey = issuerCertificate.publicJwk\n    const alg = issuerKey.supportedSignatureAlgorithms.find(isMdocSupportedSignatureAlgorithm)\n    if (!alg) {\n      throw new MdocError(\n        `Unable to create sign mdoc. No supported signature algorithm found to sign mdoc for jwk with key ${\n          issuerKey.jwkTypeHumanDescription\n        }. Key supports algs ${issuerKey.supportedSignatureAlgorithms.join(\n          ', '\n        )}. mdoc supports algs ${mdocSupportedSignatureAlgorithms.join(', ')}`\n      )\n    }\n\n    const issuerSignedDocument = await document.sign(\n      {\n        issuerPrivateKey: issuerKey.toJson(),\n        alg,\n        issuerCertificate: issuerCertificate.rawCertificate,\n      },\n      mdocContext\n    )\n\n    return new Mdoc(issuerSignedDocument)\n  }\n\n  public async verify(\n    agentContext: AgentContext,\n    options?: MdocVerifyOptions\n  ): Promise<{ isValid: true } | { isValid: false; error: string }> {\n    const x509ModuleConfig = agentContext.dependencyManager.resolve(X509ModuleConfig)\n    const certificateChain = this.issuerSignedDocument.issuerSigned.issuerAuth.certificateChain.map((certificate) =>\n      X509Certificate.fromRawCertificate(certificate)\n    )\n\n    let trustedCertificates = options?.trustedCertificates\n    if (!trustedCertificates) {\n      trustedCertificates =\n        (await x509ModuleConfig.getTrustedCertificatesForVerification?.(agentContext, {\n          verification: {\n            type: 'credential',\n            credential: this,\n          },\n          certificateChain,\n        })) ?? x509ModuleConfig.trustedCertificates\n    }\n\n    if (!trustedCertificates) {\n      throw new MdocError('No trusted certificates found. Cannot verify mdoc.')\n    }\n\n    const mdocContext = getMdocContext(agentContext)\n    try {\n      const verifier = new Verifier()\n      await verifier.verifyIssuerSignature(\n        {\n          trustedCertificates: trustedCertificates.map(\n            (cert) => X509Certificate.fromEncodedCertificate(cert).rawCertificate\n          ),\n          issuerAuth: this.issuerSignedDocument.issuerSigned.issuerAuth,\n          disableCertificateChainValidation: false,\n          now: options?.now,\n        },\n        mdocContext\n      )\n\n      await verifier.verifyData({ mdoc: this.issuerSignedDocument }, mdocContext)\n      return { isValid: true }\n    } catch (error) {\n      return { isValid: false, error: error.message }\n    }\n  }\n}\n"],"mappings":"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"}