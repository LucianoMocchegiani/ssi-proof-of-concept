{"version":3,"file":"MdocApi.mjs","names":[],"sources":["../../../src/modules/mdoc/MdocApi.ts"],"sourcesContent":["import { AgentContext } from '../../agent'\nimport { injectable } from '../../plugins'\nimport type { Query, QueryOptions } from '../../storage/StorageService'\nimport { Mdoc } from './Mdoc'\nimport type { MdocSignOptions, MdocStoreOptions, MdocVerifyOptions } from './MdocOptions'\nimport { MdocService } from './MdocService'\nimport type { MdocRecord } from './repository'\n\n/**\n * @public\n */\n@injectable()\nexport class MdocApi {\n  private agentContext: AgentContext\n  private mdocService: MdocService\n\n  public constructor(agentContext: AgentContext, mdocService: MdocService) {\n    this.agentContext = agentContext\n    this.mdocService = mdocService\n  }\n\n  /**\n   * Create a new Mdoc, with a spcific doctype, namespace, and validity info.\n   *\n   * @param options {MdocSignOptions}\n   * @returns {Promise<Mdoc>}\n   */\n  public async sign(options: MdocSignOptions) {\n    return await this.mdocService.signMdoc(this.agentContext, options)\n  }\n\n  /**\n   *\n   * Verify an incoming mdoc. It will check whether everything is valid, but also returns parts of the validation.\n   *\n   * For example, you might still want to continue with a flow if not all the claims are included, but the signature is valid.\n   *\n   */\n  public async verify(mdoc: Mdoc, options: MdocVerifyOptions) {\n    return await this.mdocService.verifyMdoc(this.agentContext, mdoc, options)\n  }\n\n  /**\n   * Create a Mdoc class from a base64url encoded Mdoc Issuer-Signed structure\n   */\n  public fromBase64Url(base64Url: string) {\n    return Mdoc.fromBase64Url(base64Url)\n  }\n\n  public async store(options: MdocStoreOptions) {\n    return await this.mdocService.store(this.agentContext, options)\n  }\n\n  public async getById(id: string): Promise<MdocRecord> {\n    return await this.mdocService.getById(this.agentContext, id)\n  }\n\n  public async getAll(): Promise<Array<MdocRecord>> {\n    return await this.mdocService.getAll(this.agentContext)\n  }\n\n  public async findAllByQuery(query: Query<MdocRecord>, queryOptions?: QueryOptions): Promise<Array<MdocRecord>> {\n    return await this.mdocService.findByQuery(this.agentContext, query, queryOptions)\n  }\n\n  public async deleteById(id: string) {\n    return await this.mdocService.deleteById(this.agentContext, id)\n  }\n\n  public async update(mdocRecord: MdocRecord) {\n    return await this.mdocService.update(this.agentContext, mdocRecord)\n  }\n}\n"],"mappings":";;;;;;;;;;;;AAYO,oBAAM,QAAQ;CAInB,AAAO,YAAY,cAA4B,aAA0B;AACvE,OAAK,eAAe;AACpB,OAAK,cAAc;;;;;;;;CASrB,MAAa,KAAK,SAA0B;AAC1C,SAAO,MAAM,KAAK,YAAY,SAAS,KAAK,cAAc,QAAQ;;;;;;;;;CAUpE,MAAa,OAAO,MAAY,SAA4B;AAC1D,SAAO,MAAM,KAAK,YAAY,WAAW,KAAK,cAAc,MAAM,QAAQ;;;;;CAM5E,AAAO,cAAc,WAAmB;AACtC,SAAO,KAAK,cAAc,UAAU;;CAGtC,MAAa,MAAM,SAA2B;AAC5C,SAAO,MAAM,KAAK,YAAY,MAAM,KAAK,cAAc,QAAQ;;CAGjE,MAAa,QAAQ,IAAiC;AACpD,SAAO,MAAM,KAAK,YAAY,QAAQ,KAAK,cAAc,GAAG;;CAG9D,MAAa,SAAqC;AAChD,SAAO,MAAM,KAAK,YAAY,OAAO,KAAK,aAAa;;CAGzD,MAAa,eAAe,OAA0B,cAAyD;AAC7G,SAAO,MAAM,KAAK,YAAY,YAAY,KAAK,cAAc,OAAO,aAAa;;CAGnF,MAAa,WAAW,IAAY;AAClC,SAAO,MAAM,KAAK,YAAY,WAAW,KAAK,cAAc,GAAG;;CAGjE,MAAa,OAAO,YAAwB;AAC1C,SAAO,MAAM,KAAK,YAAY,OAAO,KAAK,cAAc,WAAW;;;sBA3DtE,YAAY"}