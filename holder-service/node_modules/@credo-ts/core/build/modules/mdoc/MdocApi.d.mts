import { Query, QueryOptions } from "../../storage/StorageService.mjs";
import { MdocRecord } from "./repository/MdocRecord.mjs";
import "./repository/index.mjs";
import { MdocSignOptions, MdocStoreOptions, MdocVerifyOptions } from "./MdocOptions.mjs";
import { MdocService } from "./MdocService.mjs";
import { Mdoc } from "./Mdoc.mjs";
import { AgentContext } from "../../agent/context/AgentContext.mjs";
import "../../agent/index.mjs";

//#region src/modules/mdoc/MdocApi.d.ts
/**
 * @public
 */
declare class MdocApi {
  private agentContext;
  private mdocService;
  constructor(agentContext: AgentContext, mdocService: MdocService);
  /**
   * Create a new Mdoc, with a spcific doctype, namespace, and validity info.
   *
   * @param options {MdocSignOptions}
   * @returns {Promise<Mdoc>}
   */
  sign(options: MdocSignOptions): Promise<Mdoc>;
  /**
   *
   * Verify an incoming mdoc. It will check whether everything is valid, but also returns parts of the validation.
   *
   * For example, you might still want to continue with a flow if not all the claims are included, but the signature is valid.
   *
   */
  verify(mdoc: Mdoc, options: MdocVerifyOptions): Promise<{
    isValid: true;
  } | {
    isValid: false;
    error: string;
  }>;
  /**
   * Create a Mdoc class from a base64url encoded Mdoc Issuer-Signed structure
   */
  fromBase64Url(base64Url: string): Mdoc;
  store(options: MdocStoreOptions): Promise<MdocRecord>;
  getById(id: string): Promise<MdocRecord>;
  getAll(): Promise<Array<MdocRecord>>;
  findAllByQuery(query: Query<MdocRecord>, queryOptions?: QueryOptions): Promise<Array<MdocRecord>>;
  deleteById(id: string): Promise<void>;
  update(mdocRecord: MdocRecord): Promise<void>;
}
//#endregion
export { MdocApi };
//# sourceMappingURL=MdocApi.d.mts.map