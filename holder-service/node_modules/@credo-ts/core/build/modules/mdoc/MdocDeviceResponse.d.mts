import { ClaimFormat } from "../vc/models/ClaimFormat.mjs";
import { MdocDeviceResponseOptions, MdocDeviceResponsePresentationDefinitionOptions, MdocDeviceResponseVerifyOptions } from "./MdocOptions.mjs";
import { DifPresentationExchangeDefinition } from "../dif-presentation-exchange/models/index.mjs";
import "../dif-presentation-exchange/index.mjs";
import "../vc/index.mjs";
import { Mdoc } from "./Mdoc.mjs";
import { AgentContext } from "../../agent/context/AgentContext.mjs";
import "../../agent/index.mjs";
import * as _sphereon_pex_models0 from "@sphereon/pex-models";
import { InputDescriptorV2 } from "@sphereon/pex-models";

//#region src/modules/mdoc/MdocDeviceResponse.d.ts
declare class MdocDeviceResponse {
  base64Url: string;
  documents: Mdoc[];
  private constructor();
  /**
   * claim format is convenience method added to all credential instances
   */
  get claimFormat(): ClaimFormat.MsoMdoc;
  /**
   * Encoded is convenience method added to all credential instances
   */
  get encoded(): string;
  /**
   * To support a single DeviceResponse with multiple documents in OpenID4VP
   */
  splitIntoSingleDocumentResponses(): MdocDeviceResponse[];
  private static fromDeviceResponse;
  static fromBase64Url(base64Url: string): MdocDeviceResponse;
  private static assertMdocInputDescriptor;
  static partitionPresentationDefinition: (pd: DifPresentationExchangeDefinition) => {
    mdocPresentationDefinition: {
      format: {
        mso_mdoc: _sphereon_pex_models0.MsoMdocObject | undefined;
      };
      input_descriptors: {
        format: {
          mso_mdoc: _sphereon_pex_models0.MsoMdocObject;
        };
        constraints: {
          limit_disclosure: string;
          fields: {
            intent_to_retain: boolean;
            id?: string;
            path: Array<string>;
            purpose?: string;
            filter?: _sphereon_pex_models0.FilterV2;
            predicate?: _sphereon_pex_models0.Optionality;
            name?: string;
            optional?: boolean;
          }[];
          statuses?: _sphereon_pex_models0.Statuses;
          subject_is_issuer?: _sphereon_pex_models0.Optionality;
          is_holder?: Array<_sphereon_pex_models0.HolderSubject>;
          same_subject?: Array<_sphereon_pex_models0.HolderSubject>;
        };
        id: string;
        name?: string;
        purpose?: string;
        group?: Array<string>;
        issuance?: Array<_sphereon_pex_models0.Issuance>;
      }[];
      id: string;
      name?: string;
      purpose?: string;
      submission_requirements?: Array<_sphereon_pex_models0.SubmissionRequirement>;
    } | {
      format: {
        mso_mdoc: _sphereon_pex_models0.MsoMdocObject | undefined;
      };
      input_descriptors: {
        format: {
          mso_mdoc: _sphereon_pex_models0.MsoMdocObject;
        };
        constraints: {
          limit_disclosure: string;
          fields: {
            intent_to_retain: boolean;
            id?: string;
            path: Array<string>;
            purpose?: string;
            filter?: _sphereon_pex_models0.FilterV2;
            predicate?: _sphereon_pex_models0.Optionality;
            name?: string;
            optional?: boolean;
          }[];
          statuses?: _sphereon_pex_models0.Statuses;
          subject_is_issuer?: _sphereon_pex_models0.Optionality;
          is_holder?: Array<_sphereon_pex_models0.HolderSubject>;
          same_subject?: Array<_sphereon_pex_models0.HolderSubject>;
        };
        id: string;
        name?: string;
        purpose?: string;
        group?: Array<string>;
        issuance?: Array<_sphereon_pex_models0.Issuance>;
      }[];
      id: string;
      name?: string;
      purpose?: string;
      submission_requirements?: Array<_sphereon_pex_models0.SubmissionRequirement>;
      frame?: object;
    };
    nonMdocPresentationDefinition: DifPresentationExchangeDefinition;
  };
  private static createPresentationSubmission;
  static limitDisclosureToInputDescriptor(options: {
    inputDescriptor: InputDescriptorV2;
    mdoc: Mdoc;
  }): {
    [k: string]: {
      [k: string]: unknown;
    };
  };
  static createPresentationDefinitionDeviceResponse(agentContext: AgentContext, options: MdocDeviceResponsePresentationDefinitionOptions): Promise<{
    deviceResponseBase64Url: string;
    presentationSubmission: {
      id: string;
      definition_id: string;
      descriptor_map: {
        id: string;
        format: string;
        path: string;
      }[];
    };
  }>;
  static createDeviceResponse(agentContext: AgentContext, options: MdocDeviceResponseOptions): Promise<Uint8Array<ArrayBufferLike>>;
  verify(agentContext: AgentContext, options: Omit<MdocDeviceResponseVerifyOptions, 'deviceResponse'>): Promise<Mdoc[]>;
  private static getSessionTranscriptBytesForOptions;
  private static getAlgForDeviceKeyJwk;
}
//#endregion
export { MdocDeviceResponse };
//# sourceMappingURL=MdocDeviceResponse.d.mts.map