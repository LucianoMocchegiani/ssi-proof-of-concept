{"version":3,"file":"MdocRecord.mjs","names":[],"sources":["../../../../src/modules/mdoc/repository/MdocRecord.ts"],"sourcesContent":["import type { TagsBase } from '../../../storage/BaseRecord'\nimport { BaseRecord } from '../../../storage/BaseRecord'\nimport type { NonEmptyArray } from '../../../types'\nimport { JsonTransformer } from '../../../utils'\nimport { CredentialMultiInstanceState } from '../../../utils/credentialUseTypes'\nimport type { Constructable } from '../../../utils/mixins'\nimport { uuid } from '../../../utils/uuid'\nimport type { KnownJwaSignatureAlgorithm } from '../../kms'\nimport { Mdoc } from '../Mdoc'\n\nexport type DefaultMdocRecordTags = {\n  docType: string\n\n  /**\n   *\n   * The Jwa Signature Algorithm used to sign the Mdoc.\n   */\n  alg: KnownJwaSignatureAlgorithm\n\n  /**\n   * @since 0.6 - tag was not defined before 0.6\n   */\n  multiInstanceState?: CredentialMultiInstanceState\n}\n\nexport type MdocRecordStorageProps = {\n  id?: string\n  createdAt?: Date\n  tags?: TagsBase\n\n  /**\n   * The mDOC instances to store on the record.\n   *\n   * NOTE that all instances should contain roughly the same data (e.g. exp can differ slighty), as they should be usable\n   * interchangeably for presentations (allowing single-use credentials and batch issuance).\n   */\n  credentialInstances: MdocRecordInstances\n}\n\nexport type MdocRecordInstances = NonEmptyArray<{\n  issuerSignedBase64Url: string\n\n  /**\n   * The kms key id to which the credential is bound. If not defined the\n   * credential is bound to a legacy key id (which can be calculated based on the key)\n   */\n  kmsKeyId?: string\n}>\n\nexport class MdocRecord extends BaseRecord<DefaultMdocRecordTags> {\n  public static readonly type = 'MdocRecord'\n  public readonly type = MdocRecord.type\n\n  public credentialInstances!: MdocRecordInstances\n\n  /**\n   * Tracks the state of credential instances on this record.\n   *\n   * NOTE: This defaults to `CredentialMultiInstanceState.SingleInstanceUsed` for records that\n   * don't have a value set from before 0.6. We assume the credential has already been used.\n   */\n  public multiInstanceState = CredentialMultiInstanceState.SingleInstanceUsed\n\n  /**\n   * Only here for class transformation. If base64Url is set we transform\n   * it to the new mdocs array format\n   */\n  private set base64Url(base64Url: string) {\n    this.credentialInstances = [\n      {\n        issuerSignedBase64Url: base64Url,\n      },\n    ]\n  }\n\n  public constructor(props: MdocRecordStorageProps) {\n    super()\n\n    if (props) {\n      this.id = props.id ?? uuid()\n      this.createdAt = props.createdAt ?? new Date()\n      this.credentialInstances = props.credentialInstances\n\n      // Set multiInstanceState based on the number of initial instances. We\n      // assume the instance is unused when the record is created.\n      this.multiInstanceState =\n        this.credentialInstances.length === 1\n          ? CredentialMultiInstanceState.SingleInstanceUnused\n          : CredentialMultiInstanceState.MultiInstanceFirstUnused\n\n      this._tags = props.tags ?? {}\n    }\n  }\n\n  public get firstCredential(): Mdoc {\n    const mdoc = Mdoc.fromBase64Url(this.credentialInstances[0].issuerSignedBase64Url)\n\n    mdoc.deviceKeyId = this.credentialInstances[0].kmsKeyId ?? mdoc.deviceKey?.legacyKeyId\n\n    return mdoc\n  }\n\n  public static fromMdoc(mdoc: Mdoc) {\n    return new MdocRecord({\n      credentialInstances: [\n        {\n          issuerSignedBase64Url: mdoc.base64Url,\n          kmsKeyId: mdoc.deviceKeyId,\n        },\n      ],\n    })\n  }\n\n  public getTags() {\n    const mdoc = this.firstCredential\n    const docType = mdoc.docType\n    const alg = mdoc.alg\n\n    return {\n      ...this._tags,\n      docType,\n      alg,\n      multiInstanceState: this.multiInstanceState,\n    }\n  }\n\n  public clone(): this {\n    return JsonTransformer.fromJSON(JsonTransformer.toJSON(this), this.constructor as Constructable<this>)\n  }\n\n  /**\n   * encoded is convenience method added to all credential records\n   */\n  public get encoded(): string {\n    return this.credentialInstances[0].issuerSignedBase64Url\n  }\n}\n"],"mappings":";;;;;;;;;;AAiDA,IAAa,aAAb,MAAa,mBAAmB,WAAkC;;;;;CAkBhE,IAAY,UAAU,WAAmB;AACvC,OAAK,sBAAsB,CACzB,EACE,uBAAuB,WACxB,CACF;;CAGH,AAAO,YAAY,OAA+B;AAChD,SAAO;OAzBO,OAAO,WAAW;OAU3B,qBAAqB,6BAA6B;AAiBvD,MAAI,OAAO;AACT,QAAK,KAAK,MAAM,MAAM,MAAM;AAC5B,QAAK,YAAY,MAAM,6BAAa,IAAI,MAAM;AAC9C,QAAK,sBAAsB,MAAM;AAIjC,QAAK,qBACH,KAAK,oBAAoB,WAAW,IAChC,6BAA6B,uBAC7B,6BAA6B;AAEnC,QAAK,QAAQ,MAAM,QAAQ,EAAE;;;CAIjC,IAAW,kBAAwB;EACjC,MAAM,OAAO,KAAK,cAAc,KAAK,oBAAoB,GAAG,sBAAsB;AAElF,OAAK,cAAc,KAAK,oBAAoB,GAAG,YAAY,KAAK,WAAW;AAE3E,SAAO;;CAGT,OAAc,SAAS,MAAY;AACjC,SAAO,IAAI,WAAW,EACpB,qBAAqB,CACnB;GACE,uBAAuB,KAAK;GAC5B,UAAU,KAAK;GAChB,CACF,EACF,CAAC;;CAGJ,AAAO,UAAU;EACf,MAAM,OAAO,KAAK;EAClB,MAAM,UAAU,KAAK;EACrB,MAAM,MAAM,KAAK;AAEjB,SAAO;GACL,GAAG,KAAK;GACR;GACA;GACA,oBAAoB,KAAK;GAC1B;;CAGH,AAAO,QAAc;AACnB,SAAO,gBAAgB,SAAS,gBAAgB,OAAO,KAAK,EAAE,KAAK,YAAmC;;;;;CAMxG,IAAW,UAAkB;AAC3B,SAAO,KAAK,oBAAoB,GAAG;;;WApFd,OAAO"}