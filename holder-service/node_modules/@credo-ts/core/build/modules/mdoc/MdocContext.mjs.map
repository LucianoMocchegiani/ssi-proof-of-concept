{"version":3,"file":"MdocContext.mjs","names":[],"sources":["../../../src/modules/mdoc/MdocContext.ts"],"sourcesContent":["import type { MdocContext, X509Context } from '@animo-id/mdoc'\nimport { p256 } from '@noble/curves/nist.js'\nimport { hkdf } from '@noble/hashes/hkdf.js'\nimport { sha256 } from '@noble/hashes/sha2.js'\nimport type { AgentContext } from '../../agent'\nimport { CredoWebCrypto, Hasher } from '../../crypto'\nimport { TypedArrayEncoder } from '../../utils'\nimport { KeyManagementApi, type KmsJwkPublicAsymmetric, type KnownJwaSignatureAlgorithm, PublicJwk } from '../kms'\nimport { X509Certificate, X509Service } from '../x509'\n\nexport const getMdocContext = (agentContext: AgentContext): MdocContext => {\n  const crypto = new CredoWebCrypto(agentContext)\n  const kms = agentContext.resolve(KeyManagementApi)\n\n  return {\n    crypto: {\n      digest: async (input) => {\n        const { bytes, digestAlgorithm } = input\n\n        return new Uint8Array(\n          crypto.digest(\n            digestAlgorithm,\n            // NOTE: extra Uint8Array wrapping is needed here, somehow if we use `bytes.buffer` directly\n            // it's not working. Maybe due to Uint8array lengt\n            new Uint8Array(bytes).buffer\n          )\n        )\n      },\n      random: (length) => {\n        return crypto.getRandomValues(new Uint8Array(length))\n      },\n      calculateEphemeralMacKeyJwk: async (input) => {\n        const { privateKey, publicKey, sessionTranscriptBytes } = input\n        const ikm = p256.getSharedSecret(privateKey, publicKey, true).slice(1)\n        const salt = Hasher.hash(sessionTranscriptBytes, 'sha-256')\n        const info = TypedArrayEncoder.fromString('EMacKey')\n        const hk1 = hkdf(sha256, ikm, salt, info, 32)\n\n        return {\n          key_ops: ['sign', 'verify'],\n          ext: true,\n          kty: 'oct',\n          k: TypedArrayEncoder.toBase64URL(hk1),\n          alg: 'HS256',\n        }\n      },\n    },\n\n    cose: {\n      mac0: {\n        sign: async (input) => {\n          const { jwk, mac0 } = input\n          const { data } = mac0.getRawSigningData()\n\n          const publicJwk = PublicJwk.fromUnknown(jwk)\n          const algorithm = mac0.algName ?? publicJwk.signatureAlgorithm\n\n          const { signature } = await kms.sign({\n            data,\n            algorithm,\n            keyId: publicJwk.keyId,\n          })\n\n          return signature\n        },\n        verify: async (input) => {\n          const { mac0, jwk, options } = input\n          const { data, signature } = mac0.getRawVerificationData(options)\n\n          const publicJwk = PublicJwk.fromUnknown(jwk)\n          const algorithm = mac0.algName ?? publicJwk.signatureAlgorithm\n\n          const { verified } = await kms.verify({\n            key: {\n              publicJwk: jwk as KmsJwkPublicAsymmetric,\n            },\n            data,\n            algorithm,\n            signature,\n          })\n\n          return verified\n        },\n      },\n      sign1: {\n        sign: async (input) => {\n          const { jwk, sign1 } = input\n          const { data } = sign1.getRawSigningData()\n\n          const publicJwk = PublicJwk.fromUnknown(jwk)\n          const algorithm = sign1.algName ?? publicJwk.signatureAlgorithm\n\n          const { signature } = await kms.sign({\n            data,\n            algorithm: algorithm as KnownJwaSignatureAlgorithm,\n            keyId: publicJwk.keyId,\n          })\n\n          return signature\n        },\n        verify: async (input) => {\n          const { sign1, jwk, options } = input\n          const { data, signature } = sign1.getRawVerificationData(options)\n\n          const publicJwk = PublicJwk.fromUnknown(jwk)\n          const algorithm = sign1.algName ?? publicJwk.signatureAlgorithm\n\n          const { verified } = await kms.verify({\n            key: {\n              publicJwk: jwk as KmsJwkPublicAsymmetric,\n            },\n            data,\n            algorithm: algorithm as KnownJwaSignatureAlgorithm,\n            signature,\n          })\n\n          return verified\n        },\n      },\n    },\n\n    x509: {\n      getIssuerNameField: (input) => {\n        const { certificate, field } = input\n        const x509Certificate = X509Certificate.fromRawCertificate(certificate)\n        return x509Certificate.getIssuerNameField(field)\n      },\n      getPublicKey: async (input) => {\n        const certificate = X509Certificate.fromRawCertificate(input.certificate)\n        return certificate.publicJwk.toJson()\n      },\n      validateCertificateChain: async (input) => {\n        const certificateChain = input.x5chain.map((cert) => X509Certificate.fromRawCertificate(cert).toString('pem'))\n        const trustedCertificates = input.trustedCertificates.map((cert) =>\n          X509Certificate.fromRawCertificate(cert).toString('pem')\n        ) as [string, ...string[]]\n\n        await X509Service.validateCertificateChain(agentContext, {\n          certificateChain,\n          trustedCertificates,\n        })\n      },\n      getCertificateData: async (input) => {\n        const { certificate } = input\n        const x509Certificate = X509Certificate.fromRawCertificate(certificate)\n        return {\n          ...x509Certificate.data,\n          thumbprint: await x509Certificate.getThumbprintInHex(agentContext),\n        }\n      },\n    } satisfies X509Context,\n  }\n}\n"],"mappings":"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"}