{"version":3,"file":"BaseRecord.mjs","names":[],"sources":["../../src/storage/BaseRecord.ts"],"sourcesContent":["import { Exclude } from 'class-transformer'\n\nimport { JsonTransformer } from '../utils/JsonTransformer'\nimport { DateTransformer, MetadataTransformer } from '../utils/transformers'\n\nimport { Metadata } from './Metadata'\n\nexport type TagValue = string | boolean | undefined | Array<string> | null\nexport type TagsBase = {\n  [key: string]: TagValue\n  [key: number]: never\n}\n\nexport type Tags<DefaultTags extends TagsBase, CustomTags extends TagsBase> = CustomTags & DefaultTags\n\nexport type RecordTags<Record extends BaseRecord> = ReturnType<Record['getTags']>\n\n// The BaseRecord requires a DefaultTags and CustomTags type, but we want to be\n// able to use the BaseRecord without specifying these types. If we don't specify\n// these types, the default TagsBase will be used, but this is not compatible\n// with records that have specified a custom type.\n// biome-ignore lint/suspicious/noExplicitAny: no explanation\nexport type BaseRecordAny = BaseRecord<any, any, any>\n\nexport abstract class BaseRecord<\n  DefaultTags extends TagsBase = TagsBase,\n  CustomTags extends TagsBase = TagsBase,\n  // We want an empty object, as Record<string, unknown> will make typescript\n  // not infer the types correctly\n  // biome-ignore lint/complexity/noBannedTypes: no explanation\n  MetadataValues = {},\n> {\n  protected _tags: CustomTags & TagsBase = {} as CustomTags & TagsBase\n\n  public id!: string\n\n  @DateTransformer()\n  public createdAt!: Date\n\n  @DateTransformer()\n  public updatedAt?: Date\n\n  @Exclude()\n  public readonly type = BaseRecord.type\n  public static readonly type: string = 'BaseRecord'\n\n  @Exclude()\n  public readonly allowCache = BaseRecord.allowCache\n  public static readonly allowCache: boolean = false\n\n  /** @inheritdoc {Metadata#Metadata} */\n  @MetadataTransformer()\n  public metadata: Metadata<MetadataValues> = new Metadata({})\n\n  /**\n   * Get all tags. This is includes custom and default tags\n   * @returns tags object\n   */\n  public abstract getTags(): Tags<DefaultTags, CustomTags>\n\n  /**\n   * Set the value for a tag\n   * @param name name of the tag\n   * @param value value of the tag\n   */\n  public setTag(name: keyof CustomTags | (string & {}), value: CustomTags[keyof CustomTags]) {\n    this._tags[name] = value as (typeof this._tags)[string]\n  }\n\n  /**\n   * Get the value for a tag\n   * @param name name of the tag\n   * @returns The tag value, or undefined if not found\n   */\n  public getTag(name: keyof CustomTags | keyof DefaultTags | (string & {})) {\n    return this.getTags()[name]\n  }\n\n  /**\n   * Set custom tags. This will merge the tags object with passed in tag properties\n   *\n   * @param tags the tags to set\n   */\n  public setTags(tags: Partial<CustomTags | TagsBase>) {\n    this._tags = {\n      ...this._tags,\n      ...tags,\n    } as typeof this._tags\n  }\n\n  /**\n   * Replace tags. This will replace the whole tags object.\n   * Default tags will still be overridden when retrieving tags\n   *\n   * @param tags the tags to set\n   */\n  public replaceTags(tags: CustomTags & Partial<TagsBase>) {\n    this._tags = tags\n  }\n\n  public toJSON(): Record<string, unknown> {\n    return JsonTransformer.toJSON(this)\n  }\n\n  /**\n   * Clones the record.\n   */\n  public clone() {\n    return JsonTransformer.clone(this)\n  }\n}\n"],"mappings":";;;;;;;;;;;AAwBA,IAAsB,aAAtB,MAAsB,WAOpB;;OACU,QAA+B,EAAE;OAW3B,OAAO,WAAW;OAIlB,aAAa,WAAW;OAKjC,WAAqC,IAAI,SAAS,EAAE,CAAC;;;;;;;CAa5D,AAAO,OAAO,MAAwC,OAAqC;AACzF,OAAK,MAAM,QAAQ;;;;;;;CAQrB,AAAO,OAAO,MAA4D;AACxE,SAAO,KAAK,SAAS,CAAC;;;;;;;CAQxB,AAAO,QAAQ,MAAsC;AACnD,OAAK,QAAQ;GACX,GAAG,KAAK;GACR,GAAG;GACJ;;;;;;;;CASH,AAAO,YAAY,MAAsC;AACvD,OAAK,QAAQ;;CAGf,AAAO,SAAkC;AACvC,SAAO,gBAAgB,OAAO,KAAK;;;;;CAMrC,AAAO,QAAQ;AACb,SAAO,gBAAgB,MAAM,KAAK;;;WAhEb,OAAe;WAIf,aAAsB;YAZ5C,iBAAiB;YAGjB,iBAAiB;YAGjB,SAAS;YAIT,SAAS;YAKT,qBAAqB"}