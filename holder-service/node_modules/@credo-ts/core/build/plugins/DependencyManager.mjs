

import { CredoError } from "../error/CredoError.mjs";
import "../error/index.mjs";
import { Lifecycle, container as container$1 } from "tsyringe";

//#region src/plugins/DependencyManager.ts
var DependencyManager = class DependencyManager {
	/**
	* @internal
	*/
	constructor(container = container$1.createChildContainer(), registeredModules = {}) {
		this.container = container;
		this.registeredModules = registeredModules;
	}
	/**
	* @internal
	*/
	registerModules(modules) {
		for (const [moduleKey, module] of Object.entries(modules)) {
			if (this.registeredModules[moduleKey]) throw new CredoError(`Module with key ${moduleKey} has already been registered. Only a single module can be registered with the same key.`);
			this.registeredModules[moduleKey] = module;
			if (module.api) this.registerContextScoped(module.api);
			try {
				module.register(this);
			} catch (error) {
				throw new CredoError(`Cannot register ${moduleKey}: ${error}`);
			}
		}
	}
	/**
	* @internal
	*/
	async initializeModules(agentContext) {
		if (agentContext.dependencyManager.container !== this.container) throw new CredoError(`Method 'initializeModule' called on DependencyManager different from the agent context for which 'initializeModule' is called. Make sure to call 'initializeModule' on the DependencyManager associated with the agent context.`);
		for (const [moduleName, module] of Object.entries(this.registeredModules)) try {
			await module.initialize?.(agentContext);
		} catch (error) {
			throw new CredoError(`Error during call to 'initialize' method in module '${moduleName}' for agent context '${agentContext.contextCorrelationId}'.`, { cause: error });
		}
	}
	/**
	* @internal
	*/
	async shutdownModules(agentContext) {
		if (agentContext.dependencyManager.container !== this.container) throw new CredoError(`Method 'shutdownModules' called on DependencyManager different from the agent context for which 'shutdownModules' is called. Make sure to call 'shutdownModules' on the DependencyManager associated with the agent context.`);
		for (const [moduleName, module] of Object.entries(this.registeredModules)) try {
			await module.shutdown?.(agentContext);
		} catch (error) {
			throw new CredoError(`Error during call to 'shutdown' method in module '${moduleName}' for agent context '${agentContext.contextCorrelationId}'.`, { cause: error });
		}
	}
	/**
	* @internal
	*/
	async initializeAgentContext(agentContext) {
		if (agentContext.dependencyManager.container !== this.container) throw new CredoError(`Method 'initializeAgentContext' called on DependencyManager different from the agent context for which 'initializeAgentContext' is called. Make sure to call 'initializeAgentContext' on the DependencyManager associated with the agent context.`);
		for (const [moduleName, module] of Object.entries(this.registeredModules)) try {
			await module.onInitializeContext?.(agentContext);
		} catch (error) {
			throw new CredoError(`Error during call to 'onInitializeContext' method in module '${moduleName}' for agent context '${agentContext.contextCorrelationId}'.`, { cause: error });
		}
	}
	/**
	* @internal
	*/
	async deleteAgentContext(agentContext) {
		if (agentContext.dependencyManager.container !== this.container) throw new CredoError(`Method 'deleteAgentContext' called on DependencyManager different from the agent context for which 'deleteAgentContext' is called. Make sure to call 'deleteAgentContext' on the DependencyManager associated with the agent context.`);
		try {
			for (const [moduleName, module] of Object.entries(this.registeredModules)) try {
				await module.onDeleteContext?.(agentContext);
			} catch (error) {
				throw new CredoError(`Error during call to 'onDeleteContext' method in module '${moduleName}' for agent context '${agentContext.contextCorrelationId}'.`, { cause: error });
			}
		} finally {
			await this.container.dispose();
		}
	}
	/**
	* @internal
	*/
	async provisionAgentContext(agentContext) {
		if (agentContext.dependencyManager.container !== this.container) throw new CredoError(`Method 'provisionAgentContext' called on DependencyManager different from the agent context for which 'provisionAgentContext' is called. Make sure to call 'provisionAgentContext' on the DependencyManager associated with the agent context.`);
		for (const [moduleName, module] of Object.entries(this.registeredModules)) try {
			await module.onProvisionContext?.(agentContext);
		} catch (error) {
			throw new CredoError(`Error during call to 'onProvisionContext' method in module '${moduleName}' for agent context '${agentContext.contextCorrelationId}'.`, { cause: error });
		}
		return agentContext;
	}
	/**
	* @internal
	*/
	async closeAgentContext(agentContext) {
		if (agentContext.dependencyManager.container !== this.container) throw new CredoError(`Method 'closeAgentContext' called on DependencyManager different from the agent context for which 'closeAgentContext' is called. Make sure to call 'closeAgentContext' on the DependencyManager associated with the agent context.`);
		try {
			for (const [moduleName, module] of Object.entries(this.registeredModules)) try {
				await module.onCloseContext?.(agentContext);
			} catch (error) {
				throw new CredoError(`Error during call to 'onCloseContext' method in module '${moduleName}' for agent context '${agentContext.contextCorrelationId}'.`, { cause: error });
			}
		} finally {
			if (!agentContext.isRootAgentContext) await this.container.dispose();
		}
	}
	registerSingleton(fromOrToken, to) {
		this.container.registerSingleton(fromOrToken, to);
	}
	resolve(token) {
		return this.container.resolve(token);
	}
	registerInstance(token, instance) {
		this.container.registerInstance(token, instance);
	}
	isRegistered(token, recursive = false) {
		return this.container.isRegistered(token, recursive);
	}
	registerContextScoped(token, provider) {
		if (provider) this.container.register(token, provider, { lifecycle: Lifecycle.ContainerScoped });
		else this.container.register(token, token, { lifecycle: Lifecycle.ContainerScoped });
	}
	/**
	* @internal
	*/
	createChild() {
		return new DependencyManager(this.container.createChildContainer(), this.registeredModules);
	}
};

//#endregion
export { DependencyManager };
//# sourceMappingURL=DependencyManager.mjs.map