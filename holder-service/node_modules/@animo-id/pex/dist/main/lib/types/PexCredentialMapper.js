"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getMdocDecodedPayload = exports.PexCredentialMapper = void 0;
/* eslint-disable @typescript-eslint/no-explicit-any */
const mdoc_1 = require("@animo-id/mdoc");
const ssi_types_1 = require("@sphereon/ssi-types");
const u8a = __importStar(require("uint8arrays"));
// NOTE: this is partial reimplementation of CredentialMapper from ssi-types to overwrite the
// methods relying on Sphereon's mdoc implementation
class PexCredentialMapper {
    static isMsoMdocDecodedPresentation(original) {
        return original instanceof mdoc_1.MDoc;
    }
    static isMsoMdocDecodedCredential(original) {
        return original instanceof mdoc_1.IssuerSignedDocument;
    }
    /**
     * Decodes a Verifiable Presentation to a uniform format.
     *
     * When decoding SD-JWT credentials, a hasher implementation must be provided. The hasher implementation must be sync. When using
     * an async hasher implementation, use the decodeSdJwtVcAsync method instead and you can provide the decoded payload to methods
     * instead of the compact SD-JWT.
     *
     * @param presentation
     * @param hasher Hasher implementation to use for SD-JWT decoding.
     */
    static decodeVerifiablePresentation(presentation, hasher) {
        if (ssi_types_1.CredentialMapper.isMsoMdocOid4VPEncoded(presentation)) {
            return presentation;
        }
        else if (this.isMsoMdocDecodedPresentation(presentation)) {
            return presentation;
        }
        else {
            return ssi_types_1.CredentialMapper.decodeVerifiablePresentation(presentation, hasher);
        }
    }
    static isW3cCredential(credential) {
        return ssi_types_1.CredentialMapper.isW3cCredential(credential);
    }
    /**
     * Converts a presentation to a wrapped presentation.
     *
     * When decoding SD-JWT credentials, a hasher implementation must be provided. The hasher implementation must be sync. When using
     * an async hasher implementation, use the decodeSdJwtVcAsync method instead and you can provide the decoded payload to methods
     * instead of the compact SD-JWT.
     *
     * @param hasher Hasher implementation to use for SD-JWT decoding
     */
    static toWrappedVerifiablePresentation(originalPresentation, opts) {
        var _a;
        // MSO_MDOC
        if (this.isMsoMdocDecodedPresentation(originalPresentation) || ssi_types_1.CredentialMapper.isMsoMdocOid4VPEncoded(originalPresentation)) {
            let deviceResponse;
            let originalType;
            if (ssi_types_1.CredentialMapper.isMsoMdocOid4VPEncoded(originalPresentation)) {
                deviceResponse = (0, mdoc_1.parseDeviceResponse)(convertBase64urlToBinary(originalPresentation));
                originalType = ssi_types_1.OriginalType.MSO_MDOC_ENCODED;
            }
            else {
                deviceResponse = originalPresentation;
                originalType = ssi_types_1.OriginalType.MSO_MDOC_DECODED;
            }
            const mdocCredentials = (_a = deviceResponse.documents) === null || _a === void 0 ? void 0 : _a.map((doc) => PexCredentialMapper.toWrappedVerifiableCredential(doc, opts));
            if (!mdocCredentials || mdocCredentials.length === 0) {
                throw new Error('could not extract any mdoc credentials from mdoc device response');
            }
            return {
                type: originalType,
                format: 'mso_mdoc',
                original: originalPresentation,
                presentation: deviceResponse,
                decoded: deviceResponse,
                vcs: mdocCredentials,
            };
        }
        return ssi_types_1.CredentialMapper.toWrappedVerifiablePresentation(originalPresentation, opts);
    }
    /**
     * Converts a credential to a wrapped credential.
     *
     * When decoding SD-JWT credentials, a hasher implementation must be provided. The hasher implementation must be sync. When using
     * an async hasher implementation, use the decodeSdJwtVcAsync method instead and you can provide the decoded payload to methods
     * instead of the compact SD-JWT.
     *
     * @param hasher Hasher implementation to use for SD-JWT decoding
     */
    static toWrappedVerifiableCredential(verifiableCredential, opts) {
        // MSO_MDOC
        if (this.isMsoMdocDecodedCredential(verifiableCredential) || ssi_types_1.CredentialMapper.isMsoMdocOid4VPEncoded(verifiableCredential)) {
            let mdoc;
            if (ssi_types_1.CredentialMapper.isMsoMdocOid4VPEncoded(verifiableCredential)) {
                mdoc = (0, mdoc_1.parseIssuerSigned)(convertBase64urlToBinary(verifiableCredential));
            }
            else {
                mdoc = verifiableCredential;
            }
            return {
                type: ssi_types_1.CredentialMapper.isMsoMdocDecodedCredential(verifiableCredential)
                    ? ssi_types_1.OriginalType.MSO_MDOC_DECODED
                    : ssi_types_1.OriginalType.MSO_MDOC_ENCODED,
                format: 'mso_mdoc',
                original: verifiableCredential,
                credential: mdoc,
                decoded: getMdocDecodedPayload(mdoc),
            };
        }
        return ssi_types_1.CredentialMapper.toWrappedVerifiableCredential(verifiableCredential, opts);
    }
    static isW3cPresentation(presentation) {
        return ssi_types_1.CredentialMapper.isW3cPresentation(presentation);
    }
    static isSdJwtDecodedCredential(original) {
        return ssi_types_1.CredentialMapper.isSdJwtDecodedCredential(original);
    }
    static isJwtDecodedCredential(original) {
        return ssi_types_1.CredentialMapper.isJwtDecodedCredential(original);
    }
    static isSdJwtEncoded(original) {
        return ssi_types_1.CredentialMapper.isSdJwtEncoded(original);
    }
    static isJwtEncoded(original) {
        return ssi_types_1.CredentialMapper.isJwtEncoded(original);
    }
    static decodeVerifiableCredential(credential, hasher) {
        return ssi_types_1.CredentialMapper.decodeVerifiableCredential(credential, hasher);
    }
    static isCredential(original) {
        return ssi_types_1.CredentialMapper.isCredential(original);
    }
    static areOriginalVerifiableCredentialsEqual(firstOriginal, secondOriginal) {
        if (this.isMsoMdocDecodedCredential(firstOriginal) || this.isMsoMdocDecodedCredential(secondOriginal)) {
            return (0, mdoc_1.uint8ArrayToBase64Url)((0, mdoc_1.cborEncode)(firstOriginal)) === (0, mdoc_1.uint8ArrayToBase64Url)((0, mdoc_1.cborEncode)(secondOriginal));
        }
        return ssi_types_1.CredentialMapper.areOriginalVerifiableCredentialsEqual(firstOriginal, secondOriginal);
    }
}
exports.PexCredentialMapper = PexCredentialMapper;
PexCredentialMapper.isWrappedSdJwtVerifiableCredential = (vc) => ssi_types_1.CredentialMapper.isWrappedSdJwtVerifiableCredential(vc);
PexCredentialMapper.isWrappedSdJwtVerifiablePresentation = (vc) => ssi_types_1.CredentialMapper.isWrappedSdJwtVerifiablePresentation(vc);
PexCredentialMapper.isWrappedW3CVerifiableCredential = (vc) => ssi_types_1.CredentialMapper.isWrappedW3CVerifiableCredential(vc);
PexCredentialMapper.isWrappedW3CVerifiablePresentation = (vc) => ssi_types_1.CredentialMapper.isWrappedW3CVerifiablePresentation(vc);
PexCredentialMapper.isWrappedMdocCredential = (vc) => ssi_types_1.CredentialMapper.isWrappedMdocCredential(vc);
PexCredentialMapper.isWrappedMdocPresentation = (vc) => ssi_types_1.CredentialMapper.isWrappedMdocPresentation(vc);
function getMdocDecodedPayload(mdoc) {
    const namespaces = mdoc.issuerSigned.nameSpaces;
    const decodedPayload = {};
    for (const [namespace, items] of Array.from(namespaces.entries())) {
        decodedPayload[namespace] = items.reduce((acc, item) => (Object.assign(Object.assign({}, acc), { [item.elementIdentifier]: encodeMdocValue(item.elementValue) })), {});
    }
    return decodedPayload;
}
exports.getMdocDecodedPayload = getMdocDecodedPayload;
function encodeMdocValue(value) {
    if (typeof value === 'string' || typeof value === 'number' || typeof value === 'undefined' || value === null)
        return value;
    if (value instanceof Date || value instanceof mdoc_1.DateOnly)
        return value.toISOString();
    // TODO: we don't want undefined, but empty object might also not work?
    return {};
}
function convertBase64urlToBinary(data) {
    return u8a.fromString(data, 'base64url');
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUGV4Q3JlZGVudGlhbE1hcHBlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL2xpYi90eXBlcy9QZXhDcmVkZW50aWFsTWFwcGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsdURBQXVEO0FBQ3ZELHlDQUFpSjtBQUNqSixtREFrQjZCO0FBQzdCLGlEQUFtQztBQXVFbkMsNkZBQTZGO0FBQzdGLG9EQUFvRDtBQUNwRCxNQUFhLG1CQUFtQjtJQUN2QixNQUFNLENBQUMsNEJBQTRCLENBQUMsUUFBd0M7UUFDakYsT0FBTyxRQUFRLFlBQVksV0FBSSxDQUFDO0lBQ2xDLENBQUM7SUFFTSxNQUFNLENBQUMsMEJBQTBCLENBQ3RDLFFBQXFHO1FBRXJHLE9BQU8sUUFBUSxZQUFZLDJCQUFvQixDQUFDO0lBQ2xELENBQUM7SUFFRDs7Ozs7Ozs7O09BU0c7SUFDSCxNQUFNLENBQUMsNEJBQTRCLENBQ2pDLFlBQTRDLEVBQzVDLE1BQW1CO1FBRW5CLElBQUksNEJBQWdCLENBQUMsc0JBQXNCLENBQUMsWUFBbUIsQ0FBQyxFQUFFLENBQUM7WUFDakUsT0FBTyxZQUFzQixDQUFDO1FBQ2hDLENBQUM7YUFBTSxJQUFJLElBQUksQ0FBQyw0QkFBNEIsQ0FBQyxZQUFZLENBQUMsRUFBRSxDQUFDO1lBQzNELE9BQU8sWUFBb0IsQ0FBQztRQUM5QixDQUFDO2FBQU0sQ0FBQztZQUNOLE9BQU8sNEJBQWdCLENBQUMsNEJBQTRCLENBQUMsWUFBWSxFQUFFLE1BQU0sQ0FBUSxDQUFDO1FBQ3BGLENBQUM7SUFDSCxDQUFDO0lBRU0sTUFBTSxDQUFDLGVBQWUsQ0FBQyxVQUFpRjtRQUM3RyxPQUFPLDRCQUFnQixDQUFDLGVBQWUsQ0FBQyxVQUFpQixDQUFDLENBQUM7SUFDN0QsQ0FBQztJQUVEOzs7Ozs7OztPQVFHO0lBQ0gsTUFBTSxDQUFDLCtCQUErQixDQUNwQyxvQkFBb0QsRUFDcEQsSUFB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