import { IssuerSignedDocument, MDoc } from '@animo-id/mdoc';
import { WrappedVerifiableCredential as _WrappedVerifiableCredential, WrappedVerifiablePresentation as _WrappedVerifiablePresentation, HasherSync, ICredential, IPresentation, IVerifiablePresentation, JwtDecodedVerifiableCredential, JwtDecodedVerifiablePresentation, OriginalType, SdJwtDecodedVerifiableCredential, W3CVerifiableCredential, W3CVerifiablePresentation, WrappedSdJwtVerifiableCredential, WrappedSdJwtVerifiablePresentation, WrappedW3CVerifiableCredential, WrappedW3CVerifiablePresentation } from '@sphereon/ssi-types';
export interface WrappedMdocCredential {
    /**
     * Original IssuerSigned to Mdoc that we've received. Can be either the encoded or decoded variant.
     */
    original: IssuerSignedDocument | string;
    /**
     * Record where keys are the namespaces and the values are objects again with the namespace values
     * @todo which types can be there? (it doesn't matter for matching as mdoc only matches on path)
     */
    decoded: MdocDecodedPayload;
    /**
     * Type of this credential.
     */
    type: OriginalType.MSO_MDOC_DECODED | OriginalType.MSO_MDOC_ENCODED;
    /**
     * The claim format, typically used during exchange transport protocols
     */
    format: 'mso_mdoc';
    /**
     * Internal stable representation of a Credential
     */
    credential: IssuerSignedDocument;
}
export interface WrappedMdocPresentation {
    /**
     * Original VP that we've received. Can be either the encoded or decoded variant.
     */
    original: MDoc | string;
    /**
     * Decoded version of the mdoc payload. This is the decoded payload, rather than the whole mdoc
     */
    decoded: MDoc;
    /**
     * Type of this Presentation.
     */
    type: OriginalType.MSO_MDOC_ENCODED | OriginalType.MSO_MDOC_DECODED;
    /**
     * The claim format, typically used during exchange transport protocols
     */
    format: 'mso_mdoc';
    /**
     * Internal stable representation of a Presentation
     */
    presentation: MDoc;
    /**
     * Wrapped Mdocs belonging to the Presentation. There can be multiple
     * documents in a single device response
     */
    vcs: WrappedMdocCredential[];
}
export type OriginalVerifiablePresentation = W3CVerifiablePresentation | JwtDecodedVerifiablePresentation | SdJwtDecodedVerifiableCredential | string | MDoc;
export type OriginalVerifiableCredential = W3CVerifiableCredential | JwtDecodedVerifiableCredential | SdJwtDecodedVerifiableCredential | string | IssuerSignedDocument;
export type WrappedVerifiableCredential = Exclude<_WrappedVerifiableCredential, {
    format: 'mso_mdoc';
}> | WrappedMdocCredential;
export type WrappedVerifiablePresentation = Exclude<_WrappedVerifiablePresentation, {
    format: 'mso_mdoc';
}> | WrappedMdocPresentation;
export declare class PexCredentialMapper {
    static isMsoMdocDecodedPresentation(original: OriginalVerifiablePresentation): original is MDoc;
    static isMsoMdocDecodedCredential(original: OriginalVerifiableCredential | OriginalVerifiablePresentation | ICredential | IPresentation): original is IssuerSignedDocument;
    /**
     * Decodes a Verifiable Presentation to a uniform format.
     *
     * When decoding SD-JWT credentials, a hasher implementation must be provided. The hasher implementation must be sync. When using
     * an async hasher implementation, use the decodeSdJwtVcAsync method instead and you can provide the decoded payload to methods
     * instead of the compact SD-JWT.
     *
     * @param presentation
     * @param hasher Hasher implementation to use for SD-JWT decoding.
     */
    static decodeVerifiablePresentation(presentation: OriginalVerifiablePresentation, hasher?: HasherSync): JwtDecodedVerifiablePresentation | IVerifiablePresentation | SdJwtDecodedVerifiableCredential | string | MDoc;
    static isW3cCredential(credential: ICredential | SdJwtDecodedVerifiableCredential | IssuerSignedDocument): credential is ICredential;
    /**
     * Converts a presentation to a wrapped presentation.
     *
     * When decoding SD-JWT credentials, a hasher implementation must be provided. The hasher implementation must be sync. When using
     * an async hasher implementation, use the decodeSdJwtVcAsync method instead and you can provide the decoded payload to methods
     * instead of the compact SD-JWT.
     *
     * @param hasher Hasher implementation to use for SD-JWT decoding
     */
    static toWrappedVerifiablePresentation(originalPresentation: OriginalVerifiablePresentation, opts?: {
        maxTimeSkewInMS?: number;
        hasher?: HasherSync;
    }): WrappedVerifiablePresentation;
    /**
     * Converts a credential to a wrapped credential.
     *
     * When decoding SD-JWT credentials, a hasher implementation must be provided. The hasher implementation must be sync. When using
     * an async hasher implementation, use the decodeSdJwtVcAsync method instead and you can provide the decoded payload to methods
     * instead of the compact SD-JWT.
     *
     * @param hasher Hasher implementation to use for SD-JWT decoding
     */
    static toWrappedVerifiableCredential(verifiableCredential: OriginalVerifiableCredential, opts?: {
        maxTimeSkewInMS?: number;
        hasher?: HasherSync;
    }): WrappedVerifiableCredential;
    static isW3cPresentation(presentation: unknown): presentation is IPresentation;
    static isWrappedSdJwtVerifiableCredential: (vc: unknown) => vc is WrappedSdJwtVerifiableCredential;
    static isWrappedSdJwtVerifiablePresentation: (vc: unknown) => vc is WrappedSdJwtVerifiablePresentation;
    static isWrappedW3CVerifiableCredential: (vc: unknown) => vc is WrappedW3CVerifiableCredential;
    static isWrappedW3CVerifiablePresentation: (vc: unknown) => vc is WrappedW3CVerifiablePresentation;
    static isWrappedMdocCredential: (vc: unknown) => vc is WrappedMdocCredential;
    static isWrappedMdocPresentation: (vc: unknown) => vc is WrappedMdocPresentation;
    static isSdJwtDecodedCredential(original: unknown): original is SdJwtDecodedVerifiableCredential;
    static isJwtDecodedCredential(original: unknown): original is JwtDecodedVerifiableCredential;
    static isSdJwtEncoded(original: unknown): original is string;
    static isJwtEncoded(original: unknown): original is string;
    static decodeVerifiableCredential(credential: OriginalVerifiableCredential, hasher?: HasherSync): SdJwtDecodedVerifiableCredential | import("@sphereon/ssi-types").IVerifiableCredential | JwtDecodedVerifiableCredential;
    static isCredential(original: OriginalVerifiableCredential | OriginalVerifiablePresentation): original is OriginalVerifiableCredential;
    static areOriginalVerifiableCredentialsEqual(firstOriginal: OriginalVerifiableCredential, secondOriginal: OriginalVerifiableCredential): boolean;
}
/**
 * Record where keys are the namespaces and the values are objects again with the namespace values
 */
export type MdocDecodedPayload = Record<string, Record<string, string | number | boolean>>;
export declare function getMdocDecodedPayload(mdoc: IssuerSignedDocument): MdocDecodedPayload;
